\doxysection{Week9-\/1-\/\+Quad\+Tessellation.cpp}
\label{_week9-1-_quad_tessellation_8cpp_source}\index{Week9/QuadTessellation/Week9-\/1-\/QuadTessellation.cpp@{Week9/QuadTessellation/Week9-\/1-\/QuadTessellation.cpp}}
\textbf{ Go to the documentation of this file.}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001 \textcolor{comment}{//***************************************************************************************}}
\DoxyCodeLine{00002 \textcolor{comment}{// Quad Tessellation}}
\DoxyCodeLine{00003 \textcolor{comment}{//}}
\DoxyCodeLine{00004 \textcolor{comment}{//***************************************************************************************}}
\DoxyCodeLine{00005 }
\DoxyCodeLine{00006 \textcolor{preprocessor}{\#include "{}../../Common/d3dApp.h"{}}}
\DoxyCodeLine{00007 \textcolor{preprocessor}{\#include "{}../../Common/MathHelper.h"{}}}
\DoxyCodeLine{00008 \textcolor{preprocessor}{\#include "{}../../Common/UploadBuffer.h"{}}}
\DoxyCodeLine{00009 \textcolor{preprocessor}{\#include "{}../../Common/GeometryGenerator.h"{}}}
\DoxyCodeLine{00010 \textcolor{preprocessor}{\#include "{}FrameResource.h"{}}}
\DoxyCodeLine{00011 }
\DoxyCodeLine{00012 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{00013 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{00014 }
\DoxyCodeLine{00015 \textcolor{keyword}{using} Microsoft::WRL::ComPtr;}
\DoxyCodeLine{00016 \textcolor{keyword}{using namespace }DirectX;}
\DoxyCodeLine{00017 \textcolor{keyword}{using namespace }DirectX::PackedVector;}
\DoxyCodeLine{00018 }
\DoxyCodeLine{00019 \textcolor{comment}{//Our application class will then instantiate a vector of three frame resources, }}
\DoxyCodeLine{00020 \textcolor{keyword}{const} \textcolor{keywordtype}{int} gNumFrameResources = 3;}
\DoxyCodeLine{00021 }
\DoxyCodeLine{00022 \textcolor{comment}{//Lightweight structure stores parameters to draw a shape.  This will vary from app-\/to-\/app.}}
\DoxyCodeLine{00023 \textcolor{keyword}{struct }RenderItem}
\DoxyCodeLine{00024 \{}
\DoxyCodeLine{00025     RenderItem() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{00026 }
\DoxyCodeLine{00027     \textcolor{comment}{// World matrix of the shape that describes the object's local space}}
\DoxyCodeLine{00028     \textcolor{comment}{// relative to the world space, which defines the position, orientation,}}
\DoxyCodeLine{00029     \textcolor{comment}{// and scale of the object in the world.}}
\DoxyCodeLine{00030     XMFLOAT4X4 World = MathHelper::Identity4x4();}
\DoxyCodeLine{00031 }
\DoxyCodeLine{00032     \textcolor{comment}{// Dirty flag indicating the object data has changed and we need to update the constant buffer.}}
\DoxyCodeLine{00033     \textcolor{comment}{// Because we have an object cbuffer for each FrameResource, we have to apply the}}
\DoxyCodeLine{00034     \textcolor{comment}{// update to each FrameResource.  Thus, when we modify object data, we should set }}
\DoxyCodeLine{00035     \textcolor{comment}{// NumFramesDirty = gNumFrameResources so that each frame resource gets the update.}}
\DoxyCodeLine{00036     \textcolor{keywordtype}{int} NumFramesDirty = gNumFrameResources;}
\DoxyCodeLine{00037 }
\DoxyCodeLine{00038     \textcolor{comment}{// Index into GPU constant buffer corresponding to the ObjectCB for this render item.}}
\DoxyCodeLine{00039     UINT ObjCBIndex = -\/1;}
\DoxyCodeLine{00040 }
\DoxyCodeLine{00041     \textcolor{comment}{// Geometry associated with this render-\/item. Note that multiple}}
\DoxyCodeLine{00042     \textcolor{comment}{// render-\/items can share the same geometry.}}
\DoxyCodeLine{00043     MeshGeometry* Geo = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00044 }
\DoxyCodeLine{00045     \textcolor{comment}{// Primitive topology.}}
\DoxyCodeLine{00046     D3D12\_PRIMITIVE\_TOPOLOGY PrimitiveType = D3D\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST;}
\DoxyCodeLine{00047 }
\DoxyCodeLine{00048     \textcolor{comment}{// DrawIndexedInstanced parameters.}}
\DoxyCodeLine{00049     UINT IndexCount = 0; \textcolor{comment}{//Number of indices read from the index buffer for each instance.}}
\DoxyCodeLine{00050     UINT StartIndexLocation = 0; \textcolor{comment}{//The location of the first index read by the GPU from the index buffer.}}
\DoxyCodeLine{00051     \textcolor{keywordtype}{int} BaseVertexLocation = 0; \textcolor{comment}{//A value added to each index before reading a vertex from the vertex buffer.}}
\DoxyCodeLine{00052 \};}
\DoxyCodeLine{00053 }
\DoxyCodeLine{00054 \textcolor{keyword}{class }ShapesApp : \textcolor{keyword}{public} D3DApp}
\DoxyCodeLine{00055 \{}
\DoxyCodeLine{00056 \textcolor{keyword}{public}:}
\DoxyCodeLine{00057     ShapesApp(HINSTANCE hInstance);}
\DoxyCodeLine{00058     ShapesApp(\textcolor{keyword}{const} ShapesApp\& rhs) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00059     ShapesApp\& operator=(\textcolor{keyword}{const} ShapesApp\& rhs) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00060     \string~ShapesApp();}
\DoxyCodeLine{00061 }
\DoxyCodeLine{00062     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} Initialize()\textcolor{keyword}{override};}
\DoxyCodeLine{00063 }
\DoxyCodeLine{00064 \textcolor{keyword}{private}:}
\DoxyCodeLine{00065     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnResize()\textcolor{keyword}{override};}
\DoxyCodeLine{00066     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Update(\textcolor{keyword}{const} GameTimer\& gt)\textcolor{keyword}{override};}
\DoxyCodeLine{00067     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Draw(\textcolor{keyword}{const} GameTimer\& gt)\textcolor{keyword}{override};}
\DoxyCodeLine{00068 }
\DoxyCodeLine{00069     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnMouseDown(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)\textcolor{keyword}{override};}
\DoxyCodeLine{00070     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnMouseUp(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)\textcolor{keyword}{override};}
\DoxyCodeLine{00071     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnMouseMove(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)\textcolor{keyword}{override};}
\DoxyCodeLine{00072 }
\DoxyCodeLine{00073     \textcolor{keywordtype}{void} OnKeyboardInput(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00074     \textcolor{keywordtype}{void} UpdateCamera(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00075     \textcolor{keywordtype}{void} UpdateObjectCBs(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00076     \textcolor{keywordtype}{void} UpdateMainPassCB(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00077 }
\DoxyCodeLine{00078     \textcolor{keywordtype}{void} BuildDescriptorHeaps();}
\DoxyCodeLine{00079     \textcolor{keywordtype}{void} BuildConstantBufferViews();}
\DoxyCodeLine{00080     \textcolor{keywordtype}{void} BuildRootSignature();}
\DoxyCodeLine{00081     \textcolor{keywordtype}{void} BuildShadersAndInputLayout();}
\DoxyCodeLine{00082     \textcolor{keywordtype}{void} BuildShapeGeometry();}
\DoxyCodeLine{00083     \textcolor{keywordtype}{void} BuildPSOs();}
\DoxyCodeLine{00084     \textcolor{keywordtype}{void} BuildFrameResources();}
\DoxyCodeLine{00085     \textcolor{keywordtype}{void} BuildRenderItems();}
\DoxyCodeLine{00086     \textcolor{keywordtype}{void} DrawRenderItems(ID3D12GraphicsCommandList* cmdList, \textcolor{keyword}{const} std::vector<RenderItem*>\& ritems);}
\DoxyCodeLine{00087 }
\DoxyCodeLine{00088 \textcolor{keyword}{private}:}
\DoxyCodeLine{00089 }
\DoxyCodeLine{00090     \textcolor{comment}{//keep member variables to track the current frame resource :}}
\DoxyCodeLine{00091     std::vector<std::unique\_ptr<FrameResource>> mFrameResources;}
\DoxyCodeLine{00092     FrameResource* mCurrFrameResource = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00093     \textcolor{keywordtype}{int} mCurrFrameResourceIndex = 0;}
\DoxyCodeLine{00094 }
\DoxyCodeLine{00095     ComPtr<ID3D12RootSignature> mRootSignature = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00096     ComPtr<ID3D12DescriptorHeap> mCbvHeap = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00097 }
\DoxyCodeLine{00098     ComPtr<ID3D12DescriptorHeap> mSrvDescriptorHeap = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00099 }
\DoxyCodeLine{00100     std::unordered\_map<std::string, std::unique\_ptr<MeshGeometry>> mGeometries;}
\DoxyCodeLine{00101     std::unordered\_map<std::string, ComPtr<ID3DBlob>> mShaders;}
\DoxyCodeLine{00102     std::unordered\_map<std::string, ComPtr<ID3D12PipelineState>> mPSOs;}
\DoxyCodeLine{00103 }
\DoxyCodeLine{00104     std::vector<D3D12\_INPUT\_ELEMENT\_DESC> mInputLayout;}
\DoxyCodeLine{00105 }
\DoxyCodeLine{00106     \textcolor{comment}{// List of all the render items.}}
\DoxyCodeLine{00107     std::vector<std::unique\_ptr<RenderItem>> mAllRitems;}
\DoxyCodeLine{00108 }
\DoxyCodeLine{00109     \textcolor{comment}{//Our application will maintain lists of render items based on how they need to be}}
\DoxyCodeLine{00110     \textcolor{comment}{//drawn; that is, render items that need different PSOs will be kept in different lists.}}
\DoxyCodeLine{00111 }
\DoxyCodeLine{00112     \textcolor{comment}{// Render items divided by PSO.}}
\DoxyCodeLine{00113     std::vector<RenderItem*> mOpaqueRitems;}
\DoxyCodeLine{00114 }
\DoxyCodeLine{00115     \textcolor{comment}{//std::vector<RenderItem*> mTransparentRitems;  //we could have render items for transparant items}}
\DoxyCodeLine{00116 }
\DoxyCodeLine{00117 }
\DoxyCodeLine{00118 }
\DoxyCodeLine{00119     \textcolor{comment}{//this mMainPassCB stores constant data that is fixed over a given}}
\DoxyCodeLine{00120     \textcolor{comment}{//rendering pass such as the eye position, the view and projection matrices, and information}}
\DoxyCodeLine{00121     \textcolor{comment}{//about the screen(render target) dimensions; it also includes game timing information,}}
\DoxyCodeLine{00122     \textcolor{comment}{//which is useful data to have access to in shader programs.}}
\DoxyCodeLine{00123 }
\DoxyCodeLine{00124     PassConstants mMainPassCB;}
\DoxyCodeLine{00125 }
\DoxyCodeLine{00126     UINT mPassCbvOffset = 0;}
\DoxyCodeLine{00127 }
\DoxyCodeLine{00128     \textcolor{keywordtype}{bool} mIsWireframe = \textcolor{keyword}{false};}
\DoxyCodeLine{00129 }
\DoxyCodeLine{00130     XMFLOAT3 mEyePos = \{ 0.0f, 0.0f, 0.0f \};}
\DoxyCodeLine{00131     XMFLOAT4X4 mView = MathHelper::Identity4x4();}
\DoxyCodeLine{00132     XMFLOAT4X4 mProj = MathHelper::Identity4x4();}
\DoxyCodeLine{00133 }
\DoxyCodeLine{00134     \textcolor{keywordtype}{float} mTheta = 1.5f * XM\_PI;}
\DoxyCodeLine{00135     \textcolor{keywordtype}{float} mPhi = 0.2f * XM\_PI;}
\DoxyCodeLine{00136     \textcolor{keywordtype}{float} mRadius = 15.0f;}
\DoxyCodeLine{00137 }
\DoxyCodeLine{00138     POINT mLastMousePos;}
\DoxyCodeLine{00139 \};}
\DoxyCodeLine{00140 }
\DoxyCodeLine{00141 \textcolor{keywordtype}{int} WINAPI WinMain(HINSTANCE hInstance, HINSTANCE prevInstance,}
\DoxyCodeLine{00142     PSTR cmdLine, \textcolor{keywordtype}{int} showCmd)}
\DoxyCodeLine{00143 \{}
\DoxyCodeLine{00144     \textcolor{comment}{// Enable run-\/time memory check for debug builds.}}
\DoxyCodeLine{00145 \textcolor{preprocessor}{\#if defined(DEBUG) | defined(\_DEBUG)}}
\DoxyCodeLine{00146     \_CrtSetDbgFlag(\_CRTDBG\_ALLOC\_MEM\_DF | \_CRTDBG\_LEAK\_CHECK\_DF);}
\DoxyCodeLine{00147 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00148 }
\DoxyCodeLine{00149     \textcolor{keywordflow}{try}}
\DoxyCodeLine{00150     \{}
\DoxyCodeLine{00151         ShapesApp theApp(hInstance);}
\DoxyCodeLine{00152         \textcolor{keywordflow}{if} (!theApp.Initialize())}
\DoxyCodeLine{00153             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00154 }
\DoxyCodeLine{00155         \textcolor{keywordflow}{return} theApp.Run();}
\DoxyCodeLine{00156     \}}
\DoxyCodeLine{00157     \textcolor{keywordflow}{catch} (DxException\& e)}
\DoxyCodeLine{00158     \{}
\DoxyCodeLine{00159         MessageBox(\textcolor{keyword}{nullptr}, e.ToString().c\_str(), L\textcolor{stringliteral}{"{}HR Failed"{}}, MB\_OK);}
\DoxyCodeLine{00160         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00161     \}}
\DoxyCodeLine{00162 \}}
\DoxyCodeLine{00163 }
\DoxyCodeLine{00164 ShapesApp::ShapesApp(HINSTANCE hInstance)}
\DoxyCodeLine{00165     : D3DApp(hInstance)}
\DoxyCodeLine{00166 \{}
\DoxyCodeLine{00167 \}}
\DoxyCodeLine{00168 }
\DoxyCodeLine{00169 ShapesApp::\string~ShapesApp()}
\DoxyCodeLine{00170 \{}
\DoxyCodeLine{00171     \textcolor{keywordflow}{if} (md3dDevice != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00172         FlushCommandQueue();}
\DoxyCodeLine{00173 \}}
\DoxyCodeLine{00174 }
\DoxyCodeLine{00175 \textcolor{keywordtype}{bool} ShapesApp::Initialize()}
\DoxyCodeLine{00176 \{}
\DoxyCodeLine{00177     \textcolor{keywordflow}{if} (!D3DApp::Initialize())}
\DoxyCodeLine{00178         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{00179 }
\DoxyCodeLine{00180     \textcolor{comment}{// Reset the command list to prep for initialization commands.}}
\DoxyCodeLine{00181     ThrowIfFailed(mCommandList-\/>Reset(mDirectCmdListAlloc.Get(), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{00182 }
\DoxyCodeLine{00183     BuildRootSignature();}
\DoxyCodeLine{00184     BuildShadersAndInputLayout();}
\DoxyCodeLine{00185     BuildShapeGeometry();}
\DoxyCodeLine{00186     BuildRenderItems();}
\DoxyCodeLine{00187     BuildFrameResources();}
\DoxyCodeLine{00188     BuildDescriptorHeaps();}
\DoxyCodeLine{00189     BuildConstantBufferViews();}
\DoxyCodeLine{00190     BuildPSOs();}
\DoxyCodeLine{00191 }
\DoxyCodeLine{00192     \textcolor{comment}{// Execute the initialization commands.}}
\DoxyCodeLine{00193     ThrowIfFailed(mCommandList-\/>Close());}
\DoxyCodeLine{00194     ID3D12CommandList* cmdsLists[] = \{ mCommandList.Get() \};}
\DoxyCodeLine{00195     mCommandQueue-\/>ExecuteCommandLists(\_countof(cmdsLists), cmdsLists);}
\DoxyCodeLine{00196 }
\DoxyCodeLine{00197     \textcolor{comment}{// Wait until initialization is complete.}}
\DoxyCodeLine{00198     FlushCommandQueue();}
\DoxyCodeLine{00199 }
\DoxyCodeLine{00200     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00201 \}}
\DoxyCodeLine{00202 }
\DoxyCodeLine{00203 \textcolor{keywordtype}{void} ShapesApp::OnResize()}
\DoxyCodeLine{00204 \{}
\DoxyCodeLine{00205     D3DApp::OnResize();}
\DoxyCodeLine{00206 }
\DoxyCodeLine{00207     \textcolor{comment}{// The window resized, so update the aspect ratio and recompute the projection matrix.}}
\DoxyCodeLine{00208     XMMATRIX P = XMMatrixPerspectiveFovLH(0.25f * MathHelper::Pi, AspectRatio(), 1.0f, 1000.0f);}
\DoxyCodeLine{00209     XMStoreFloat4x4(\&mProj, P);}
\DoxyCodeLine{00210 \}}
\DoxyCodeLine{00211 }
\DoxyCodeLine{00212 \textcolor{comment}{//for CPU frame n, the algorithm}}
\DoxyCodeLine{00213 \textcolor{comment}{//1. Cycle through the circular frame resource array.}}
\DoxyCodeLine{00214 \textcolor{comment}{//2. Wait until the GPU has completed commands up to this fence point.}}
\DoxyCodeLine{00215 \textcolor{comment}{//3. Update resources in mCurrFrameResource (like cbuffers).}}
\DoxyCodeLine{00216 }
\DoxyCodeLine{00217 \textcolor{keywordtype}{void} ShapesApp::Update(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00218 \{}
\DoxyCodeLine{00219     OnKeyboardInput(gt);}
\DoxyCodeLine{00220     UpdateCamera(gt);}
\DoxyCodeLine{00221 }
\DoxyCodeLine{00222     \textcolor{comment}{// Cycle through the circular frame resource array.}}
\DoxyCodeLine{00223     mCurrFrameResourceIndex = (mCurrFrameResourceIndex + 1) \% gNumFrameResources;}
\DoxyCodeLine{00224     mCurrFrameResource = mFrameResources[mCurrFrameResourceIndex].get();}
\DoxyCodeLine{00225 }
\DoxyCodeLine{00226     \textcolor{comment}{//this section is really what D3DApp::FlushCommandQueue() used to do for us at the end of each draw() function!}}
\DoxyCodeLine{00227     \textcolor{keywordflow}{if} (mCurrFrameResource-\/>Fence != 0 \&\& mFence-\/>GetCompletedValue() < mCurrFrameResource-\/>Fence)}
\DoxyCodeLine{00228     \{}
\DoxyCodeLine{00229         HANDLE eventHandle = CreateEventEx(\textcolor{keyword}{nullptr}, \textcolor{keyword}{nullptr}, \textcolor{keyword}{false}, EVENT\_ALL\_ACCESS);}
\DoxyCodeLine{00230         ThrowIfFailed(mFence-\/>SetEventOnCompletion(mCurrFrameResource-\/>Fence, eventHandle));}
\DoxyCodeLine{00231         WaitForSingleObject(eventHandle, INFINITE);}
\DoxyCodeLine{00232         CloseHandle(eventHandle);}
\DoxyCodeLine{00233     \}}
\DoxyCodeLine{00234 }
\DoxyCodeLine{00235     \textcolor{comment}{//The idea of these changes is to group constants based on update frequency. The per}}
\DoxyCodeLine{00236     \textcolor{comment}{//pass constants only need to be updated once per rendering pass, and the object constants}}
\DoxyCodeLine{00237     \textcolor{comment}{//only need to change when an object’s world matrix changes.}}
\DoxyCodeLine{00238     UpdateObjectCBs(gt);}
\DoxyCodeLine{00239     UpdateMainPassCB(gt);}
\DoxyCodeLine{00240 \}}
\DoxyCodeLine{00241 }
\DoxyCodeLine{00242 \textcolor{keywordtype}{void} ShapesApp::Draw(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00243 \{}
\DoxyCodeLine{00244     \textcolor{keyword}{auto} cmdListAlloc = mCurrFrameResource-\/>CmdListAlloc;}
\DoxyCodeLine{00245 }
\DoxyCodeLine{00246     \textcolor{comment}{// Reuse the memory associated with command recording.}}
\DoxyCodeLine{00247     \textcolor{comment}{// We can only reset when the associated command lists have finished execution on the GPU.}}
\DoxyCodeLine{00248     ThrowIfFailed(cmdListAlloc-\/>Reset());}
\DoxyCodeLine{00249 }
\DoxyCodeLine{00250     \textcolor{comment}{// A command list can be reset after it has been added to the command queue via ExecuteCommandList.}}
\DoxyCodeLine{00251     \textcolor{comment}{// Reusing the command list reuses memory.}}
\DoxyCodeLine{00252     \textcolor{keywordflow}{if} (mIsWireframe)}
\DoxyCodeLine{00253     \{}
\DoxyCodeLine{00254         ThrowIfFailed(mCommandList-\/>Reset(cmdListAlloc.Get(), mPSOs[\textcolor{stringliteral}{"{}opaque\_wireframe"{}}].Get()));}
\DoxyCodeLine{00255     \}}
\DoxyCodeLine{00256     \textcolor{keywordflow}{else}}
\DoxyCodeLine{00257     \{}
\DoxyCodeLine{00258         ThrowIfFailed(mCommandList-\/>Reset(cmdListAlloc.Get(), mPSOs[\textcolor{stringliteral}{"{}opaque"{}}].Get()));}
\DoxyCodeLine{00259     \}}
\DoxyCodeLine{00260 }
\DoxyCodeLine{00261     mCommandList-\/>RSSetViewports(1, \&mScreenViewport);}
\DoxyCodeLine{00262     mCommandList-\/>RSSetScissorRects(1, \&mScissorRect);}
\DoxyCodeLine{00263 }
\DoxyCodeLine{00264     \textcolor{comment}{// Indicate a state transition on the resource usage.}}
\DoxyCodeLine{00265     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(CurrentBackBuffer(),}
\DoxyCodeLine{00266         D3D12\_RESOURCE\_STATE\_PRESENT, D3D12\_RESOURCE\_STATE\_RENDER\_TARGET));}
\DoxyCodeLine{00267 }
\DoxyCodeLine{00268     \textcolor{comment}{// Clear the back buffer and depth buffer.}}
\DoxyCodeLine{00269     mCommandList-\/>ClearRenderTargetView(CurrentBackBufferView(), Colors::LightSteelBlue, 0, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00270     mCommandList-\/>ClearDepthStencilView(DepthStencilView(), D3D12\_CLEAR\_FLAG\_DEPTH | D3D12\_CLEAR\_FLAG\_STENCIL, 1.0f, 0, 0, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00271 }
\DoxyCodeLine{00272     \textcolor{comment}{// Specify the buffers we are going to render to.}}
\DoxyCodeLine{00273     mCommandList-\/>OMSetRenderTargets(1, \&CurrentBackBufferView(), \textcolor{keyword}{true}, \&DepthStencilView());}
\DoxyCodeLine{00274 }
\DoxyCodeLine{00275     ID3D12DescriptorHeap* descriptorHeaps[] = \{ mCbvHeap.Get() \};}
\DoxyCodeLine{00276     mCommandList-\/>SetDescriptorHeaps(\_countof(descriptorHeaps), descriptorHeaps);}
\DoxyCodeLine{00277 }
\DoxyCodeLine{00278     mCommandList-\/>SetGraphicsRootSignature(mRootSignature.Get());}
\DoxyCodeLine{00279 }
\DoxyCodeLine{00280     \textcolor{keywordtype}{int} passCbvIndex = mPassCbvOffset + mCurrFrameResourceIndex;}
\DoxyCodeLine{00281     \textcolor{keyword}{auto} passCbvHandle = CD3DX12\_GPU\_DESCRIPTOR\_HANDLE(mCbvHeap-\/>GetGPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00282     passCbvHandle.Offset(passCbvIndex, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{00283     mCommandList-\/>SetGraphicsRootDescriptorTable(1, passCbvHandle);}
\DoxyCodeLine{00284 }
\DoxyCodeLine{00285     DrawRenderItems(mCommandList.Get(), mOpaqueRitems);}
\DoxyCodeLine{00286 }
\DoxyCodeLine{00287     \textcolor{comment}{// Indicate a state transition on the resource usage.}}
\DoxyCodeLine{00288     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(CurrentBackBuffer(),}
\DoxyCodeLine{00289         D3D12\_RESOURCE\_STATE\_RENDER\_TARGET, D3D12\_RESOURCE\_STATE\_PRESENT));}
\DoxyCodeLine{00290 }
\DoxyCodeLine{00291     \textcolor{comment}{// Done recording commands.}}
\DoxyCodeLine{00292     ThrowIfFailed(mCommandList-\/>Close());}
\DoxyCodeLine{00293 }
\DoxyCodeLine{00294     \textcolor{comment}{// Add the command list to the queue for execution.}}
\DoxyCodeLine{00295     ID3D12CommandList* cmdsLists[] = \{ mCommandList.Get() \};}
\DoxyCodeLine{00296     mCommandQueue-\/>ExecuteCommandLists(\_countof(cmdsLists), cmdsLists);}
\DoxyCodeLine{00297 }
\DoxyCodeLine{00298     \textcolor{comment}{// Swap the back and front buffers}}
\DoxyCodeLine{00299     ThrowIfFailed(mSwapChain-\/>Present(0, 0));}
\DoxyCodeLine{00300     mCurrBackBuffer = (mCurrBackBuffer + 1) \% SwapChainBufferCount;}
\DoxyCodeLine{00301 }
\DoxyCodeLine{00302 }
\DoxyCodeLine{00303     \textcolor{comment}{//we have been calling D3DApp::FlushCommandQueue at the end of every}}
\DoxyCodeLine{00304     \textcolor{comment}{//frame to ensure the GPU has finished executing all the commands for the frame.This solution works but is inefficient}}
\DoxyCodeLine{00305     \textcolor{comment}{//For every frame, the CPU and GPU are idling at some point.}}
\DoxyCodeLine{00306     \textcolor{comment}{//  FlushCommandQueue();}}
\DoxyCodeLine{00307 }
\DoxyCodeLine{00308     \textcolor{comment}{//Advance the fence value to mark commands up to this fence point.}}
\DoxyCodeLine{00309     mCurrFrameResource-\/>Fence = ++mCurrentFence;}
\DoxyCodeLine{00310 }
\DoxyCodeLine{00311     \textcolor{comment}{// Add an instruction to the command queue to set a new fence point. }}
\DoxyCodeLine{00312     \textcolor{comment}{// Because we are on the GPU timeline, the new fence point won't be }}
\DoxyCodeLine{00313     \textcolor{comment}{// set until the GPU finishes processing all the commands prior to this Signal().}}
\DoxyCodeLine{00314     mCommandQueue-\/>Signal(mFence.Get(), mCurrentFence);}
\DoxyCodeLine{00315 }
\DoxyCodeLine{00316     \textcolor{comment}{// Note that GPU could still be working on commands from previous}}
\DoxyCodeLine{00317         \textcolor{comment}{// frames, but that is okay, because we are not touching any frame}}
\DoxyCodeLine{00318         \textcolor{comment}{// resources associated with those frames.}}
\DoxyCodeLine{00319 }
\DoxyCodeLine{00320 \}}
\DoxyCodeLine{00321 }
\DoxyCodeLine{00322 \textcolor{keywordtype}{void} ShapesApp::OnMouseDown(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)}
\DoxyCodeLine{00323 \{}
\DoxyCodeLine{00324     mLastMousePos.x = x;}
\DoxyCodeLine{00325     mLastMousePos.y = y;}
\DoxyCodeLine{00326 }
\DoxyCodeLine{00327     SetCapture(mhMainWnd);}
\DoxyCodeLine{00328 \}}
\DoxyCodeLine{00329 }
\DoxyCodeLine{00330 \textcolor{keywordtype}{void} ShapesApp::OnMouseUp(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)}
\DoxyCodeLine{00331 \{}
\DoxyCodeLine{00332     ReleaseCapture();}
\DoxyCodeLine{00333 \}}
\DoxyCodeLine{00334 }
\DoxyCodeLine{00335 \textcolor{keywordtype}{void} ShapesApp::OnMouseMove(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)}
\DoxyCodeLine{00336 \{}
\DoxyCodeLine{00337     \textcolor{keywordflow}{if} ((btnState \& MK\_LBUTTON) != 0)}
\DoxyCodeLine{00338     \{}
\DoxyCodeLine{00339         \textcolor{comment}{// Make each pixel correspond to a quarter of a degree.}}
\DoxyCodeLine{00340         \textcolor{keywordtype}{float} dx = XMConvertToRadians(0.25f * \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x -\/ mLastMousePos.x));}
\DoxyCodeLine{00341         \textcolor{keywordtype}{float} dy = XMConvertToRadians(0.25f * \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(y -\/ mLastMousePos.y));}
\DoxyCodeLine{00342 }
\DoxyCodeLine{00343         \textcolor{comment}{// Update angles based on input to orbit camera around box.}}
\DoxyCodeLine{00344         mTheta += dx;}
\DoxyCodeLine{00345         mPhi += dy;}
\DoxyCodeLine{00346 }
\DoxyCodeLine{00347         \textcolor{comment}{// Restrict the angle mPhi.}}
\DoxyCodeLine{00348         mPhi = MathHelper::Clamp(mPhi, 0.1f, MathHelper::Pi -\/ 0.1f);}
\DoxyCodeLine{00349     \}}
\DoxyCodeLine{00350     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((btnState \& MK\_RBUTTON) != 0)}
\DoxyCodeLine{00351     \{}
\DoxyCodeLine{00352         \textcolor{comment}{// Make each pixel correspond to 0.2 unit in the scene.}}
\DoxyCodeLine{00353         \textcolor{keywordtype}{float} dx = 0.05f * \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x -\/ mLastMousePos.x);}
\DoxyCodeLine{00354         \textcolor{keywordtype}{float} dy = 0.05f * \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(y -\/ mLastMousePos.y);}
\DoxyCodeLine{00355 }
\DoxyCodeLine{00356         \textcolor{comment}{// Update the camera radius based on input.}}
\DoxyCodeLine{00357         mRadius += dx -\/ dy;}
\DoxyCodeLine{00358 }
\DoxyCodeLine{00359         \textcolor{comment}{// Restrict the radius.}}
\DoxyCodeLine{00360         mRadius = MathHelper::Clamp(mRadius, 5.0f, 150.0f);}
\DoxyCodeLine{00361     \}}
\DoxyCodeLine{00362 }
\DoxyCodeLine{00363     mLastMousePos.x = x;}
\DoxyCodeLine{00364     mLastMousePos.y = y;}
\DoxyCodeLine{00365 \}}
\DoxyCodeLine{00366 }
\DoxyCodeLine{00367 \textcolor{keywordtype}{void} ShapesApp::OnKeyboardInput(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00368 \{}
\DoxyCodeLine{00369     \textcolor{comment}{//Determines whether a key is up or down at the time the function is called, and whether the key was pressed after a previous call to GetAsyncKeyState.}}
\DoxyCodeLine{00370     \textcolor{comment}{//If the function succeeds, the return value specifies whether the key was pressed since the last call to GetAsyncKeyState, }}
\DoxyCodeLine{00371     \textcolor{comment}{//and whether the key is currently up or down. If the most significant bit is set, the key is down, and if the least significant bit is set, the key was pressed after the previous call to GetAsyncKeyState.}}
\DoxyCodeLine{00372     \textcolor{comment}{//if (GetAsyncKeyState('1') \& 0x8000)}}
\DoxyCodeLine{00373 }
\DoxyCodeLine{00374     \textcolor{keywordtype}{short} key = GetAsyncKeyState(\textcolor{charliteral}{'1'});}
\DoxyCodeLine{00375     \textcolor{keywordflow}{if} (key \& 0x8000)  \textcolor{comment}{//if one is pressed, 0x8000 = 32767 , key = -\/32767 = FFFFFFFFFFFF8001}}
\DoxyCodeLine{00376         mIsWireframe = \textcolor{keyword}{true};}
\DoxyCodeLine{00377     \textcolor{keywordflow}{else}}
\DoxyCodeLine{00378         mIsWireframe = \textcolor{keyword}{false};}
\DoxyCodeLine{00379 \}}
\DoxyCodeLine{00380 }
\DoxyCodeLine{00381 \textcolor{keywordtype}{void} ShapesApp::UpdateCamera(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00382 \{}
\DoxyCodeLine{00383     \textcolor{comment}{// Convert Spherical to Cartesian coordinates.}}
\DoxyCodeLine{00384     mEyePos.x = mRadius * sinf(mPhi) * cosf(mTheta);}
\DoxyCodeLine{00385     mEyePos.z = mRadius * sinf(mPhi) * sinf(mTheta);}
\DoxyCodeLine{00386     mEyePos.y = mRadius * cosf(mPhi);}
\DoxyCodeLine{00387 }
\DoxyCodeLine{00388     \textcolor{comment}{// Build the view matrix.}}
\DoxyCodeLine{00389     XMVECTOR pos = XMVectorSet(mEyePos.x, mEyePos.y, mEyePos.z, 1.0f);}
\DoxyCodeLine{00390     XMVECTOR target = XMVectorZero();}
\DoxyCodeLine{00391     XMVECTOR up = XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f);}
\DoxyCodeLine{00392 }
\DoxyCodeLine{00393     XMMATRIX view = XMMatrixLookAtLH(pos, target, up);}
\DoxyCodeLine{00394     XMStoreFloat4x4(\&mView, view);}
\DoxyCodeLine{00395 \}}
\DoxyCodeLine{00396 }
\DoxyCodeLine{00397 \textcolor{comment}{//Update resources (cbuffers) in mCurrFrameResource}}
\DoxyCodeLine{00398 \textcolor{keywordtype}{void} ShapesApp::UpdateObjectCBs(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00399 \{}
\DoxyCodeLine{00400     \textcolor{keyword}{auto} currObjectCB = mCurrFrameResource-\/>ObjectCB.get();}
\DoxyCodeLine{00401     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& e : mAllRitems)}
\DoxyCodeLine{00402     \{}
\DoxyCodeLine{00403         \textcolor{comment}{// Only update the cbuffer data if the constants have changed.  }}
\DoxyCodeLine{00404         \textcolor{comment}{// This needs to be tracked per frame resource.}}
\DoxyCodeLine{00405         \textcolor{keywordflow}{if} (e-\/>NumFramesDirty > 0)}
\DoxyCodeLine{00406         \{}
\DoxyCodeLine{00407             XMMATRIX world = XMLoadFloat4x4(\&e-\/>World);}
\DoxyCodeLine{00408 }
\DoxyCodeLine{00409             ObjectConstants objConstants;}
\DoxyCodeLine{00410             XMStoreFloat4x4(\&objConstants.World, XMMatrixTranspose(world));}
\DoxyCodeLine{00411 }
\DoxyCodeLine{00412             currObjectCB-\/>CopyData(e-\/>ObjCBIndex, objConstants);}
\DoxyCodeLine{00413 }
\DoxyCodeLine{00414             \textcolor{comment}{// Next FrameResource need to be updated too.}}
\DoxyCodeLine{00415             e-\/>NumFramesDirty-\/-\/;}
\DoxyCodeLine{00416         \}}
\DoxyCodeLine{00417     \}}
\DoxyCodeLine{00418 \}}
\DoxyCodeLine{00419 }
\DoxyCodeLine{00420 \textcolor{comment}{//CBVs will be set at different frequencies—the per pass CBV only needs to be set once per}}
\DoxyCodeLine{00421 \textcolor{comment}{//rendering pass while the per object CBV needs to be set per render item}}
\DoxyCodeLine{00422 \textcolor{keywordtype}{void} ShapesApp::UpdateMainPassCB(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00423 \{}
\DoxyCodeLine{00424     XMMATRIX view = XMLoadFloat4x4(\&mView);}
\DoxyCodeLine{00425     XMMATRIX proj = XMLoadFloat4x4(\&mProj);}
\DoxyCodeLine{00426 }
\DoxyCodeLine{00427     XMMATRIX viewProj = XMMatrixMultiply(view, proj);}
\DoxyCodeLine{00428     XMMATRIX invView = XMMatrixInverse(\&XMMatrixDeterminant(view), view);}
\DoxyCodeLine{00429     XMMATRIX invProj = XMMatrixInverse(\&XMMatrixDeterminant(proj), proj);}
\DoxyCodeLine{00430     XMMATRIX invViewProj = XMMatrixInverse(\&XMMatrixDeterminant(viewProj), viewProj);}
\DoxyCodeLine{00431 }
\DoxyCodeLine{00432     XMStoreFloat4x4(\&mMainPassCB.View, XMMatrixTranspose(view));}
\DoxyCodeLine{00433     XMStoreFloat4x4(\&mMainPassCB.InvView, XMMatrixTranspose(invView));}
\DoxyCodeLine{00434     XMStoreFloat4x4(\&mMainPassCB.Proj, XMMatrixTranspose(proj));}
\DoxyCodeLine{00435     XMStoreFloat4x4(\&mMainPassCB.InvProj, XMMatrixTranspose(invProj));}
\DoxyCodeLine{00436     XMStoreFloat4x4(\&mMainPassCB.ViewProj, XMMatrixTranspose(viewProj));}
\DoxyCodeLine{00437     XMStoreFloat4x4(\&mMainPassCB.InvViewProj, XMMatrixTranspose(invViewProj));}
\DoxyCodeLine{00438     mMainPassCB.EyePosW = mEyePos;}
\DoxyCodeLine{00439     mMainPassCB.RenderTargetSize = XMFLOAT2((\textcolor{keywordtype}{float})mClientWidth, (\textcolor{keywordtype}{float})mClientHeight);}
\DoxyCodeLine{00440     mMainPassCB.InvRenderTargetSize = XMFLOAT2(1.0f / mClientWidth, 1.0f / mClientHeight);}
\DoxyCodeLine{00441     mMainPassCB.NearZ = 1.0f;}
\DoxyCodeLine{00442     mMainPassCB.FarZ = 1000.0f;}
\DoxyCodeLine{00443     mMainPassCB.TotalTime = gt.TotalTime();}
\DoxyCodeLine{00444     mMainPassCB.DeltaTime = gt.DeltaTime();}
\DoxyCodeLine{00445 }
\DoxyCodeLine{00446     \textcolor{keyword}{auto} currPassCB = mCurrFrameResource-\/>PassCB.get();}
\DoxyCodeLine{00447     currPassCB-\/>CopyData(0, mMainPassCB);}
\DoxyCodeLine{00448 \}}
\DoxyCodeLine{00449 }
\DoxyCodeLine{00450 \textcolor{keywordtype}{void} ShapesApp::BuildDescriptorHeaps()}
\DoxyCodeLine{00451 \{}
\DoxyCodeLine{00452     UINT objCount = (UINT)mOpaqueRitems.size();}
\DoxyCodeLine{00453 }
\DoxyCodeLine{00454     \textcolor{comment}{// Need a CBV descriptor for each object for each frame resource,}}
\DoxyCodeLine{00455     \textcolor{comment}{// +1 for the perPass CBV for each frame resource.}}
\DoxyCodeLine{00456     UINT numDescriptors = (objCount + 1) * gNumFrameResources;}
\DoxyCodeLine{00457 }
\DoxyCodeLine{00458     \textcolor{comment}{// Save an offset to the start of the pass CBVs.  These are the last 3 descriptors.}}
\DoxyCodeLine{00459     mPassCbvOffset = objCount * gNumFrameResources;}
\DoxyCodeLine{00460 }
\DoxyCodeLine{00461     D3D12\_DESCRIPTOR\_HEAP\_DESC cbvHeapDesc;}
\DoxyCodeLine{00462     cbvHeapDesc.NumDescriptors = numDescriptors;}
\DoxyCodeLine{00463     cbvHeapDesc.Type = D3D12\_DESCRIPTOR\_HEAP\_TYPE\_CBV\_SRV\_UAV;}
\DoxyCodeLine{00464     cbvHeapDesc.Flags = D3D12\_DESCRIPTOR\_HEAP\_FLAG\_SHADER\_VISIBLE;}
\DoxyCodeLine{00465     cbvHeapDesc.NodeMask = 0;}
\DoxyCodeLine{00466     ThrowIfFailed(md3dDevice-\/>CreateDescriptorHeap(\&cbvHeapDesc,}
\DoxyCodeLine{00467         IID\_PPV\_ARGS(\&mCbvHeap)));}
\DoxyCodeLine{00468 \}}
\DoxyCodeLine{00469 }
\DoxyCodeLine{00470 \textcolor{keywordtype}{void} ShapesApp::BuildConstantBufferViews()}
\DoxyCodeLine{00471 \{}
\DoxyCodeLine{00472     UINT objCBByteSize = d3dUtil::CalcConstantBufferByteSize(\textcolor{keyword}{sizeof}(ObjectConstants));}
\DoxyCodeLine{00473 }
\DoxyCodeLine{00474     UINT objCount = (UINT)mOpaqueRitems.size();}
\DoxyCodeLine{00475 }
\DoxyCodeLine{00476     \textcolor{comment}{// Need a CBV descriptor for each object for each frame resource.}}
\DoxyCodeLine{00477     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} frameIndex = 0; frameIndex < gNumFrameResources; ++frameIndex)}
\DoxyCodeLine{00478     \{}
\DoxyCodeLine{00479         \textcolor{keyword}{auto} objectCB = mFrameResources[frameIndex]-\/>ObjectCB-\/>Resource();}
\DoxyCodeLine{00480         \textcolor{keywordflow}{for} (UINT i = 0; i < objCount; ++i)}
\DoxyCodeLine{00481         \{}
\DoxyCodeLine{00482             D3D12\_GPU\_VIRTUAL\_ADDRESS cbAddress = objectCB-\/>GetGPUVirtualAddress();}
\DoxyCodeLine{00483 }
\DoxyCodeLine{00484             \textcolor{comment}{// Offset to the ith object constant buffer in the buffer.}}
\DoxyCodeLine{00485             cbAddress += i * objCBByteSize;}
\DoxyCodeLine{00486 }
\DoxyCodeLine{00487             \textcolor{comment}{// Offset to the object cbv in the descriptor heap.}}
\DoxyCodeLine{00488             \textcolor{keywordtype}{int} heapIndex = frameIndex * objCount + i;}
\DoxyCodeLine{00489             \textcolor{keyword}{auto} handle = CD3DX12\_CPU\_DESCRIPTOR\_HANDLE(mCbvHeap-\/>GetCPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00490             handle.Offset(heapIndex, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{00491 }
\DoxyCodeLine{00492             D3D12\_CONSTANT\_BUFFER\_VIEW\_DESC cbvDesc;}
\DoxyCodeLine{00493             cbvDesc.BufferLocation = cbAddress;}
\DoxyCodeLine{00494             cbvDesc.SizeInBytes = objCBByteSize;}
\DoxyCodeLine{00495 }
\DoxyCodeLine{00496             md3dDevice-\/>CreateConstantBufferView(\&cbvDesc, handle);}
\DoxyCodeLine{00497         \}}
\DoxyCodeLine{00498     \}}
\DoxyCodeLine{00499 }
\DoxyCodeLine{00500     UINT passCBByteSize = d3dUtil::CalcConstantBufferByteSize(\textcolor{keyword}{sizeof}(PassConstants));}
\DoxyCodeLine{00501 }
\DoxyCodeLine{00502     \textcolor{comment}{// Last three descriptors are the pass CBVs for each frame resource.}}
\DoxyCodeLine{00503     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} frameIndex = 0; frameIndex < gNumFrameResources; ++frameIndex)}
\DoxyCodeLine{00504     \{}
\DoxyCodeLine{00505         \textcolor{keyword}{auto} passCB = mFrameResources[frameIndex]-\/>PassCB-\/>Resource();}
\DoxyCodeLine{00506         D3D12\_GPU\_VIRTUAL\_ADDRESS cbAddress = passCB-\/>GetGPUVirtualAddress();}
\DoxyCodeLine{00507 }
\DoxyCodeLine{00508         \textcolor{comment}{// Offset to the pass cbv in the descriptor heap.}}
\DoxyCodeLine{00509         \textcolor{keywordtype}{int} heapIndex = mPassCbvOffset + frameIndex;}
\DoxyCodeLine{00510         \textcolor{keyword}{auto} handle = CD3DX12\_CPU\_DESCRIPTOR\_HANDLE(mCbvHeap-\/>GetCPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00511         handle.Offset(heapIndex, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{00512 }
\DoxyCodeLine{00513         D3D12\_CONSTANT\_BUFFER\_VIEW\_DESC cbvDesc;}
\DoxyCodeLine{00514         cbvDesc.BufferLocation = cbAddress;}
\DoxyCodeLine{00515         cbvDesc.SizeInBytes = passCBByteSize;}
\DoxyCodeLine{00516 }
\DoxyCodeLine{00517         md3dDevice-\/>CreateConstantBufferView(\&cbvDesc, handle);}
\DoxyCodeLine{00518     \}}
\DoxyCodeLine{00519 \}}
\DoxyCodeLine{00520 }
\DoxyCodeLine{00521 \textcolor{keywordtype}{void} ShapesApp::BuildRootSignature()}
\DoxyCodeLine{00522 \{}
\DoxyCodeLine{00523     \textcolor{comment}{//The resources that our shaders expect have changed; therefore, we need to update the}}
\DoxyCodeLine{00524     \textcolor{comment}{//root signature accordingly to take two descriptor tables(we need two tables because the}}
\DoxyCodeLine{00525     \textcolor{comment}{//CBVs will be set at different frequencies—the per pass CBV only needs to be set once per}}
\DoxyCodeLine{00526     \textcolor{comment}{//rendering pass while the per object CBV needs to be set per render item) :}}
\DoxyCodeLine{00527 }
\DoxyCodeLine{00528     CD3DX12\_DESCRIPTOR\_RANGE cbvTable0;}
\DoxyCodeLine{00529     cbvTable0.Init(D3D12\_DESCRIPTOR\_RANGE\_TYPE\_CBV, 1, 0);}
\DoxyCodeLine{00530 }
\DoxyCodeLine{00531     CD3DX12\_DESCRIPTOR\_RANGE cbvTable1;}
\DoxyCodeLine{00532     cbvTable1.Init(D3D12\_DESCRIPTOR\_RANGE\_TYPE\_CBV, 1, 1);}
\DoxyCodeLine{00533 }
\DoxyCodeLine{00534     \textcolor{comment}{// Root parameter can be a table, root descriptor or root constants.}}
\DoxyCodeLine{00535     CD3DX12\_ROOT\_PARAMETER slotRootParameter[2];}
\DoxyCodeLine{00536 }
\DoxyCodeLine{00537     \textcolor{comment}{// Create root CBVs.}}
\DoxyCodeLine{00538     slotRootParameter[0].InitAsDescriptorTable(1, \&cbvTable0);}
\DoxyCodeLine{00539     slotRootParameter[1].InitAsDescriptorTable(1, \&cbvTable1);}
\DoxyCodeLine{00540 }
\DoxyCodeLine{00541     \textcolor{comment}{// A root signature is an array of root parameters.}}
\DoxyCodeLine{00542     CD3DX12\_ROOT\_SIGNATURE\_DESC rootSigDesc(2, slotRootParameter, 0, \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00543         D3D12\_ROOT\_SIGNATURE\_FLAG\_ALLOW\_INPUT\_ASSEMBLER\_INPUT\_LAYOUT);}
\DoxyCodeLine{00544 }
\DoxyCodeLine{00545     \textcolor{comment}{// create a root signature with a single slot which points to a descriptor range consisting of a single constant buffer}}
\DoxyCodeLine{00546     ComPtr<ID3DBlob> serializedRootSig = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00547     ComPtr<ID3DBlob> errorBlob = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00548     HRESULT hr = D3D12SerializeRootSignature(\&rootSigDesc, D3D\_ROOT\_SIGNATURE\_VERSION\_1,}
\DoxyCodeLine{00549         serializedRootSig.GetAddressOf(), errorBlob.GetAddressOf());}
\DoxyCodeLine{00550 }
\DoxyCodeLine{00551     \textcolor{keywordflow}{if} (errorBlob != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00552     \{}
\DoxyCodeLine{00553         ::OutputDebugStringA((\textcolor{keywordtype}{char}*)errorBlob-\/>GetBufferPointer());}
\DoxyCodeLine{00554     \}}
\DoxyCodeLine{00555     ThrowIfFailed(hr);}
\DoxyCodeLine{00556 }
\DoxyCodeLine{00557     ThrowIfFailed(md3dDevice-\/>CreateRootSignature(}
\DoxyCodeLine{00558         0,}
\DoxyCodeLine{00559         serializedRootSig-\/>GetBufferPointer(),}
\DoxyCodeLine{00560         serializedRootSig-\/>GetBufferSize(),}
\DoxyCodeLine{00561         IID\_PPV\_ARGS(mRootSignature.GetAddressOf())));}
\DoxyCodeLine{00562 \}}
\DoxyCodeLine{00563 }
\DoxyCodeLine{00564 \textcolor{keywordtype}{void} ShapesApp::BuildShadersAndInputLayout()}
\DoxyCodeLine{00565 \{}
\DoxyCodeLine{00566     mShaders[\textcolor{stringliteral}{"{}standardVS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)VS.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}VS"{}}, \textcolor{stringliteral}{"{}vs\_5\_1"{}});}
\DoxyCodeLine{00567     mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)PS.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}PS"{}}, \textcolor{stringliteral}{"{}ps\_5\_1"{}});}
\DoxyCodeLine{00568 }
\DoxyCodeLine{00569     mShaders[\textcolor{stringliteral}{"{}tessHS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)Tessellation.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}HS"{}}, \textcolor{stringliteral}{"{}hs\_5\_1"{}});}
\DoxyCodeLine{00570     mShaders[\textcolor{stringliteral}{"{}tessDS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)Tessellation.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}DS"{}}, \textcolor{stringliteral}{"{}ds\_5\_1"{}});}
\DoxyCodeLine{00571 }
\DoxyCodeLine{00572     mInputLayout =}
\DoxyCodeLine{00573     \{}
\DoxyCodeLine{00574         \{ \textcolor{stringliteral}{"{}POSITION"{}}, 0, DXGI\_FORMAT\_R32G32B32\_FLOAT, 0, 0, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{00575         \{ \textcolor{stringliteral}{"{}COLOR"{}}, 0, DXGI\_FORMAT\_R32G32B32A32\_FLOAT, 0, 12, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{00576     \};}
\DoxyCodeLine{00577 \}}
\DoxyCodeLine{00578 }
\DoxyCodeLine{00579 }
\DoxyCodeLine{00580 \textcolor{keywordtype}{void} ShapesApp::BuildShapeGeometry()}
\DoxyCodeLine{00581 \{}
\DoxyCodeLine{00582     std::array<Vertex, 4> vertices =}
\DoxyCodeLine{00583     \{}
\DoxyCodeLine{00584                 Vertex(\{ XMFLOAT3(-\/2.0f, -\/2.0f, 0.0f), XMFLOAT4(Colors::Red)\}),}
\DoxyCodeLine{00585                 Vertex(\{ XMFLOAT3(-\/2.0f, +2.0f, 0.0f) , XMFLOAT4(Colors::Green) \}),}
\DoxyCodeLine{00586                 Vertex(\{ XMFLOAT3(+2.0f, -\/2.0f, 0.0f) , XMFLOAT4(Colors::Cyan)\}),}
\DoxyCodeLine{00587                 Vertex(\{ XMFLOAT3(+2.0f, +2.0f, 0.0f) , XMFLOAT4(Colors::Yellow)\}),}
\DoxyCodeLine{00588 }
\DoxyCodeLine{00589     \};}
\DoxyCodeLine{00590 }
\DoxyCodeLine{00591 }
\DoxyCodeLine{00592     std::array<std::uint16\_t, 4> indices =}
\DoxyCodeLine{00593     \{}
\DoxyCodeLine{00594 }
\DoxyCodeLine{00595         0, 1, 2,3}
\DoxyCodeLine{00596     \};}
\DoxyCodeLine{00597 }
\DoxyCodeLine{00598 }
\DoxyCodeLine{00599 }
\DoxyCodeLine{00600     \textcolor{keyword}{const} UINT vbByteSize = (UINT)vertices.size() * \textcolor{keyword}{sizeof}(Vertex);}
\DoxyCodeLine{00601     \textcolor{keyword}{const} UINT ibByteSize = (UINT)indices.size() * \textcolor{keyword}{sizeof}(std::uint16\_t);}
\DoxyCodeLine{00602 }
\DoxyCodeLine{00603     \textcolor{keyword}{auto} mBoxGeo = std::make\_unique<MeshGeometry>();}
\DoxyCodeLine{00604     mBoxGeo-\/>Name = \textcolor{stringliteral}{"{}shapeGeo"{}};}
\DoxyCodeLine{00605 }
\DoxyCodeLine{00606     ThrowIfFailed(D3DCreateBlob(vbByteSize, \&mBoxGeo-\/>VertexBufferCPU));}
\DoxyCodeLine{00607     CopyMemory(mBoxGeo-\/>VertexBufferCPU-\/>GetBufferPointer(), vertices.data(), vbByteSize);}
\DoxyCodeLine{00608 }
\DoxyCodeLine{00609     ThrowIfFailed(D3DCreateBlob(ibByteSize, \&mBoxGeo-\/>IndexBufferCPU));}
\DoxyCodeLine{00610     CopyMemory(mBoxGeo-\/>IndexBufferCPU-\/>GetBufferPointer(), indices.data(), ibByteSize);}
\DoxyCodeLine{00611 }
\DoxyCodeLine{00612     mBoxGeo-\/>VertexBufferGPU = d3dUtil::CreateDefaultBuffer(md3dDevice.Get(),}
\DoxyCodeLine{00613         mCommandList.Get(), vertices.data(), vbByteSize, mBoxGeo-\/>VertexBufferUploader);}
\DoxyCodeLine{00614 }
\DoxyCodeLine{00615     mBoxGeo-\/>IndexBufferGPU = d3dUtil::CreateDefaultBuffer(md3dDevice.Get(),}
\DoxyCodeLine{00616         mCommandList.Get(), indices.data(), ibByteSize, mBoxGeo-\/>IndexBufferUploader);}
\DoxyCodeLine{00617 }
\DoxyCodeLine{00618     mBoxGeo-\/>VertexByteStride = \textcolor{keyword}{sizeof}(Vertex);}
\DoxyCodeLine{00619     mBoxGeo-\/>VertexBufferByteSize = vbByteSize;}
\DoxyCodeLine{00620     mBoxGeo-\/>IndexFormat = DXGI\_FORMAT\_R16\_UINT;}
\DoxyCodeLine{00621     mBoxGeo-\/>IndexBufferByteSize = ibByteSize;}
\DoxyCodeLine{00622 }
\DoxyCodeLine{00623     SubmeshGeometry submesh;}
\DoxyCodeLine{00624     submesh.IndexCount = (UINT)indices.size();}
\DoxyCodeLine{00625     submesh.StartIndexLocation = 0;}
\DoxyCodeLine{00626     submesh.BaseVertexLocation = 0;}
\DoxyCodeLine{00627 }
\DoxyCodeLine{00628     mBoxGeo-\/>DrawArgs[\textcolor{stringliteral}{"{}box"{}}] = submesh;}
\DoxyCodeLine{00629 }
\DoxyCodeLine{00630 }
\DoxyCodeLine{00631     mGeometries[mBoxGeo-\/>Name] = std::move(mBoxGeo);}
\DoxyCodeLine{00632 }
\DoxyCodeLine{00633 \}}
\DoxyCodeLine{00634 }
\DoxyCodeLine{00635 \textcolor{keywordtype}{void} ShapesApp::BuildPSOs()}
\DoxyCodeLine{00636 \{}
\DoxyCodeLine{00637     D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC opaquePsoDesc;}
\DoxyCodeLine{00638 }
\DoxyCodeLine{00639     \textcolor{comment}{//}}
\DoxyCodeLine{00640     \textcolor{comment}{// PSO for opaque objects.}}
\DoxyCodeLine{00641     \textcolor{comment}{//}}
\DoxyCodeLine{00642     ZeroMemory(\&opaquePsoDesc, \textcolor{keyword}{sizeof}(D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC));}
\DoxyCodeLine{00643     opaquePsoDesc.InputLayout = \{ mInputLayout.data(), (UINT)mInputLayout.size() \};}
\DoxyCodeLine{00644     opaquePsoDesc.pRootSignature = mRootSignature.Get();}
\DoxyCodeLine{00645     opaquePsoDesc.VS =}
\DoxyCodeLine{00646     \{}
\DoxyCodeLine{00647         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}standardVS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{00648         mShaders[\textcolor{stringliteral}{"{}standardVS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{00649     \};}
\DoxyCodeLine{00650     opaquePsoDesc.PS =}
\DoxyCodeLine{00651     \{}
\DoxyCodeLine{00652         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{00653         mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{00654     \};}
\DoxyCodeLine{00655 }
\DoxyCodeLine{00656     opaquePsoDesc.HS =}
\DoxyCodeLine{00657     \{}
\DoxyCodeLine{00658         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}tessHS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{00659         mShaders[\textcolor{stringliteral}{"{}tessHS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{00660     \};}
\DoxyCodeLine{00661     opaquePsoDesc.DS =}
\DoxyCodeLine{00662     \{}
\DoxyCodeLine{00663         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}tessDS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{00664         mShaders[\textcolor{stringliteral}{"{}tessDS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{00665     \};}
\DoxyCodeLine{00666 }
\DoxyCodeLine{00667     opaquePsoDesc.RasterizerState = CD3DX12\_RASTERIZER\_DESC(D3D12\_DEFAULT);}
\DoxyCodeLine{00668     opaquePsoDesc.RasterizerState.FillMode = D3D12\_FILL\_MODE\_WIREFRAME;}
\DoxyCodeLine{00669     opaquePsoDesc.BlendState = CD3DX12\_BLEND\_DESC(D3D12\_DEFAULT);}
\DoxyCodeLine{00670     opaquePsoDesc.DepthStencilState = CD3DX12\_DEPTH\_STENCIL\_DESC(D3D12\_DEFAULT);}
\DoxyCodeLine{00671     opaquePsoDesc.SampleMask = UINT\_MAX;}
\DoxyCodeLine{00672     opaquePsoDesc.PrimitiveTopologyType = D3D12\_PRIMITIVE\_TOPOLOGY\_TYPE\_PATCH;}
\DoxyCodeLine{00673     opaquePsoDesc.NumRenderTargets = 1;}
\DoxyCodeLine{00674     opaquePsoDesc.RTVFormats[0] = mBackBufferFormat;}
\DoxyCodeLine{00675     opaquePsoDesc.SampleDesc.Count = m4xMsaaState ? 4 : 1;}
\DoxyCodeLine{00676     opaquePsoDesc.SampleDesc.Quality = m4xMsaaState ? (m4xMsaaQuality -\/ 1) : 0;}
\DoxyCodeLine{00677     opaquePsoDesc.DSVFormat = mDepthStencilFormat;}
\DoxyCodeLine{00678     ThrowIfFailed(md3dDevice-\/>CreateGraphicsPipelineState(\&opaquePsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}opaque"{}}])));}
\DoxyCodeLine{00679 }
\DoxyCodeLine{00680 }
\DoxyCodeLine{00681     \textcolor{comment}{//}}
\DoxyCodeLine{00682     \textcolor{comment}{// PSO for opaque wireframe objects.}}
\DoxyCodeLine{00683     \textcolor{comment}{//}}
\DoxyCodeLine{00684 }
\DoxyCodeLine{00685     D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC opaqueWireframePsoDesc = opaquePsoDesc;}
\DoxyCodeLine{00686     opaqueWireframePsoDesc.RasterizerState.FillMode = D3D12\_FILL\_MODE\_SOLID;}
\DoxyCodeLine{00687     ThrowIfFailed(md3dDevice-\/>CreateGraphicsPipelineState(\&opaqueWireframePsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}opaque\_wireframe"{}}])));}
\DoxyCodeLine{00688 \}}
\DoxyCodeLine{00689 }
\DoxyCodeLine{00690 \textcolor{comment}{//build three frame resources}}
\DoxyCodeLine{00691 \textcolor{comment}{//FrameResource constructor:     FrameResource(ID3D12Device* device, UINT passCount, UINT objectCount);}}
\DoxyCodeLine{00692 }
\DoxyCodeLine{00693 \textcolor{keywordtype}{void} ShapesApp::BuildFrameResources()}
\DoxyCodeLine{00694 \{}
\DoxyCodeLine{00695     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < gNumFrameResources; ++i)}
\DoxyCodeLine{00696     \{}
\DoxyCodeLine{00697         mFrameResources.push\_back(std::make\_unique<FrameResource>(md3dDevice.Get(),}
\DoxyCodeLine{00698             1, (UINT)mAllRitems.size()));}
\DoxyCodeLine{00699     \}}
\DoxyCodeLine{00700 \}}
\DoxyCodeLine{00701 }
\DoxyCodeLine{00702 \textcolor{keywordtype}{void} ShapesApp::BuildRenderItems()}
\DoxyCodeLine{00703 \{}
\DoxyCodeLine{00704     \textcolor{keyword}{auto} boxRitem = std::make\_unique<RenderItem>();}
\DoxyCodeLine{00705     XMStoreFloat4x4(\&boxRitem-\/>World, XMMatrixScaling(2.0f, 2.0f, 2.0f) * XMMatrixTranslation(0.0f, 0.5f, 0.0f));}
\DoxyCodeLine{00706     boxRitem-\/>ObjCBIndex = 0;}
\DoxyCodeLine{00707     boxRitem-\/>Geo = mGeometries[\textcolor{stringliteral}{"{}shapeGeo"{}}].get();}
\DoxyCodeLine{00708     boxRitem-\/>PrimitiveType = D3D\_PRIMITIVE\_TOPOLOGY\_4\_CONTROL\_POINT\_PATCHLIST;}
\DoxyCodeLine{00709     boxRitem-\/>IndexCount = boxRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}box"{}}].IndexCount;  \textcolor{comment}{//36}}
\DoxyCodeLine{00710     boxRitem-\/>StartIndexLocation = boxRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}box"{}}].StartIndexLocation; \textcolor{comment}{//0}}
\DoxyCodeLine{00711     boxRitem-\/>BaseVertexLocation = boxRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}box"{}}].BaseVertexLocation; \textcolor{comment}{//0}}
\DoxyCodeLine{00712     mAllRitems.push\_back(std::move(boxRitem));}
\DoxyCodeLine{00713 }
\DoxyCodeLine{00714 }
\DoxyCodeLine{00715     \textcolor{comment}{// All the render items are opaque.}}
\DoxyCodeLine{00716     \textcolor{comment}{//Our application will maintain lists of render items based on how they need to be}}
\DoxyCodeLine{00717     \textcolor{comment}{//drawn; that is, render items that need different PSOs will be kept in different lists.}}
\DoxyCodeLine{00718     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& e : mAllRitems)}
\DoxyCodeLine{00719         mOpaqueRitems.push\_back(e.get());}
\DoxyCodeLine{00720 \}}
\DoxyCodeLine{00721 }
\DoxyCodeLine{00722 \textcolor{keywordtype}{void} ShapesApp::DrawRenderItems(ID3D12GraphicsCommandList* cmdList, \textcolor{keyword}{const} std::vector<RenderItem*>\& ritems)}
\DoxyCodeLine{00723 \{}
\DoxyCodeLine{00724     UINT objCBByteSize = d3dUtil::CalcConstantBufferByteSize(\textcolor{keyword}{sizeof}(ObjectConstants));}
\DoxyCodeLine{00725 }
\DoxyCodeLine{00726     \textcolor{keyword}{auto} objectCB = mCurrFrameResource-\/>ObjectCB-\/>Resource();}
\DoxyCodeLine{00727 }
\DoxyCodeLine{00728     \textcolor{comment}{// For each render item...}}
\DoxyCodeLine{00729     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < ritems.size(); ++i)}
\DoxyCodeLine{00730     \{}
\DoxyCodeLine{00731         \textcolor{keyword}{auto} ri = ritems[i];}
\DoxyCodeLine{00732 }
\DoxyCodeLine{00733         cmdList-\/>IASetVertexBuffers(0, 1, \&ri-\/>Geo-\/>VertexBufferView());}
\DoxyCodeLine{00734         cmdList-\/>IASetIndexBuffer(\&ri-\/>Geo-\/>IndexBufferView());}
\DoxyCodeLine{00735         cmdList-\/>IASetPrimitiveTopology(ri-\/>PrimitiveType);}
\DoxyCodeLine{00736 }
\DoxyCodeLine{00737         \textcolor{comment}{// Offset to the CBV in the descriptor heap for this object and for this frame resource.}}
\DoxyCodeLine{00738         UINT cbvIndex = mCurrFrameResourceIndex * (UINT)mOpaqueRitems.size() + ri-\/>ObjCBIndex;}
\DoxyCodeLine{00739         \textcolor{keyword}{auto} cbvHandle = CD3DX12\_GPU\_DESCRIPTOR\_HANDLE(mCbvHeap-\/>GetGPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00740         cbvHandle.Offset(cbvIndex, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{00741 }
\DoxyCodeLine{00742         cmdList-\/>SetGraphicsRootDescriptorTable(0, cbvHandle);}
\DoxyCodeLine{00743 }
\DoxyCodeLine{00744         cmdList-\/>DrawIndexedInstanced(ri-\/>IndexCount, 1, ri-\/>StartIndexLocation, ri-\/>BaseVertexLocation, 0);}
\DoxyCodeLine{00745     \}}
\DoxyCodeLine{00746 \}}
\DoxyCodeLine{00747 }
\DoxyCodeLine{00748 }

\end{DoxyCode}
