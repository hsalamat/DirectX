\doxysection{Week9-\/1-\/\+Triangle\+Tessellation.cpp}
\label{_week9-1-_triangle_tessellation_8cpp_source}\index{Week9/TrinagleTessellation/Week9-\/1-\/TriangleTessellation.cpp@{Week9/TrinagleTessellation/Week9-\/1-\/TriangleTessellation.cpp}}
\textbf{ Go to the documentation of this file.}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001 \textcolor{comment}{//***************************************************************************************}}
\DoxyCodeLine{00002 \textcolor{comment}{// Triangle Tesselation}}
\DoxyCodeLine{00003 \textcolor{comment}{//}}
\DoxyCodeLine{00004 \textcolor{comment}{// Hold down '1' key to view scene in wireframe mode.}}
\DoxyCodeLine{00005 \textcolor{comment}{//***************************************************************************************}}
\DoxyCodeLine{00006 }
\DoxyCodeLine{00007 \textcolor{preprocessor}{\#include "{}../../Common/d3dApp.h"{}}}
\DoxyCodeLine{00008 \textcolor{preprocessor}{\#include "{}../../Common/MathHelper.h"{}}}
\DoxyCodeLine{00009 \textcolor{preprocessor}{\#include "{}../../Common/UploadBuffer.h"{}}}
\DoxyCodeLine{00010 \textcolor{preprocessor}{\#include "{}../../Common/GeometryGenerator.h"{}}}
\DoxyCodeLine{00011 \textcolor{preprocessor}{\#include "{}FrameResource.h"{}}}
\DoxyCodeLine{00012 }
\DoxyCodeLine{00013 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{00014 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{00015 }
\DoxyCodeLine{00016 \textcolor{keyword}{using} Microsoft::WRL::ComPtr;}
\DoxyCodeLine{00017 \textcolor{keyword}{using namespace }DirectX;}
\DoxyCodeLine{00018 \textcolor{keyword}{using namespace }DirectX::PackedVector;}
\DoxyCodeLine{00019 }
\DoxyCodeLine{00020 \textcolor{comment}{//Our application class will then instantiate a vector of three frame resources, }}
\DoxyCodeLine{00021 \textcolor{keyword}{const} \textcolor{keywordtype}{int} gNumFrameResources = 3;}
\DoxyCodeLine{00022 }
\DoxyCodeLine{00023 \textcolor{comment}{//Lightweight structure stores parameters to draw a shape.  This will vary from app-\/to-\/app.}}
\DoxyCodeLine{00024 \textcolor{keyword}{struct }RenderItem}
\DoxyCodeLine{00025 \{}
\DoxyCodeLine{00026     RenderItem() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{00027 }
\DoxyCodeLine{00028     \textcolor{comment}{// World matrix of the shape that describes the object's local space}}
\DoxyCodeLine{00029     \textcolor{comment}{// relative to the world space, which defines the position, orientation,}}
\DoxyCodeLine{00030     \textcolor{comment}{// and scale of the object in the world.}}
\DoxyCodeLine{00031     XMFLOAT4X4 World = MathHelper::Identity4x4();}
\DoxyCodeLine{00032 }
\DoxyCodeLine{00033     \textcolor{comment}{// Dirty flag indicating the object data has changed and we need to update the constant buffer.}}
\DoxyCodeLine{00034     \textcolor{comment}{// Because we have an object cbuffer for each FrameResource, we have to apply the}}
\DoxyCodeLine{00035     \textcolor{comment}{// update to each FrameResource.  Thus, when we modify object data, we should set }}
\DoxyCodeLine{00036     \textcolor{comment}{// NumFramesDirty = gNumFrameResources so that each frame resource gets the update.}}
\DoxyCodeLine{00037     \textcolor{keywordtype}{int} NumFramesDirty = gNumFrameResources;}
\DoxyCodeLine{00038 }
\DoxyCodeLine{00039     \textcolor{comment}{// Index into GPU constant buffer corresponding to the ObjectCB for this render item.}}
\DoxyCodeLine{00040     UINT ObjCBIndex = -\/1;}
\DoxyCodeLine{00041 }
\DoxyCodeLine{00042     \textcolor{comment}{// Geometry associated with this render-\/item. Note that multiple}}
\DoxyCodeLine{00043     \textcolor{comment}{// render-\/items can share the same geometry.}}
\DoxyCodeLine{00044     MeshGeometry* Geo = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00045 }
\DoxyCodeLine{00046     \textcolor{comment}{// Primitive topology.}}
\DoxyCodeLine{00047     D3D12\_PRIMITIVE\_TOPOLOGY PrimitiveType = D3D\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST;}
\DoxyCodeLine{00048 }
\DoxyCodeLine{00049     \textcolor{comment}{// DrawIndexedInstanced parameters.}}
\DoxyCodeLine{00050     UINT IndexCount = 0; \textcolor{comment}{//Number of indices read from the index buffer for each instance.}}
\DoxyCodeLine{00051     UINT StartIndexLocation = 0; \textcolor{comment}{//The location of the first index read by the GPU from the index buffer.}}
\DoxyCodeLine{00052     \textcolor{keywordtype}{int} BaseVertexLocation = 0; \textcolor{comment}{//A value added to each index before reading a vertex from the vertex buffer.}}
\DoxyCodeLine{00053 \};}
\DoxyCodeLine{00054 }
\DoxyCodeLine{00055 \textcolor{keyword}{class }TriangleTessellationApp : \textcolor{keyword}{public} D3DApp}
\DoxyCodeLine{00056 \{}
\DoxyCodeLine{00057 \textcolor{keyword}{public}:}
\DoxyCodeLine{00058     TriangleTessellationApp(HINSTANCE hInstance);}
\DoxyCodeLine{00059     TriangleTessellationApp(\textcolor{keyword}{const} TriangleTessellationApp\& rhs) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00060     TriangleTessellationApp\& operator=(\textcolor{keyword}{const} TriangleTessellationApp\& rhs) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00061     \string~TriangleTessellationApp();}
\DoxyCodeLine{00062 }
\DoxyCodeLine{00063     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} Initialize()\textcolor{keyword}{override};}
\DoxyCodeLine{00064 }
\DoxyCodeLine{00065 \textcolor{keyword}{private}:}
\DoxyCodeLine{00066     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnResize()\textcolor{keyword}{override};}
\DoxyCodeLine{00067     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Update(\textcolor{keyword}{const} GameTimer\& gt)\textcolor{keyword}{override};}
\DoxyCodeLine{00068     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Draw(\textcolor{keyword}{const} GameTimer\& gt)\textcolor{keyword}{override};}
\DoxyCodeLine{00069 }
\DoxyCodeLine{00070     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnMouseDown(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)\textcolor{keyword}{override};}
\DoxyCodeLine{00071     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnMouseUp(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)\textcolor{keyword}{override};}
\DoxyCodeLine{00072     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnMouseMove(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)\textcolor{keyword}{override};}
\DoxyCodeLine{00073 }
\DoxyCodeLine{00074     \textcolor{keywordtype}{void} OnKeyboardInput(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00075     \textcolor{keywordtype}{void} UpdateCamera(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00076     \textcolor{keywordtype}{void} UpdateObjectCBs(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00077     \textcolor{keywordtype}{void} UpdateMainPassCB(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00078 }
\DoxyCodeLine{00079     \textcolor{keywordtype}{void} BuildDescriptorHeaps();}
\DoxyCodeLine{00080     \textcolor{keywordtype}{void} BuildConstantBufferViews();}
\DoxyCodeLine{00081     \textcolor{keywordtype}{void} BuildRootSignature();}
\DoxyCodeLine{00082     \textcolor{keywordtype}{void} BuildShadersAndInputLayout();}
\DoxyCodeLine{00083     \textcolor{keywordtype}{void} BuildShapeGeometry();}
\DoxyCodeLine{00084     \textcolor{keywordtype}{void} BuildPSOs();}
\DoxyCodeLine{00085     \textcolor{keywordtype}{void} BuildFrameResources();}
\DoxyCodeLine{00086     \textcolor{keywordtype}{void} BuildRenderItems();}
\DoxyCodeLine{00087     \textcolor{keywordtype}{void} DrawRenderItems(ID3D12GraphicsCommandList* cmdList, \textcolor{keyword}{const} std::vector<RenderItem*>\& ritems);}
\DoxyCodeLine{00088 }
\DoxyCodeLine{00089 \textcolor{keyword}{private}:}
\DoxyCodeLine{00090 }
\DoxyCodeLine{00091     \textcolor{comment}{//keep member variables to track the current frame resource :}}
\DoxyCodeLine{00092     std::vector<std::unique\_ptr<FrameResource>> mFrameResources;}
\DoxyCodeLine{00093     FrameResource* mCurrFrameResource = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00094     \textcolor{keywordtype}{int} mCurrFrameResourceIndex = 0;}
\DoxyCodeLine{00095 }
\DoxyCodeLine{00096     ComPtr<ID3D12RootSignature> mRootSignature = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00097     ComPtr<ID3D12DescriptorHeap> mCbvHeap = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00098 }
\DoxyCodeLine{00099     ComPtr<ID3D12DescriptorHeap> mSrvDescriptorHeap = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00100 }
\DoxyCodeLine{00101     std::unordered\_map<std::string, std::unique\_ptr<MeshGeometry>> mGeometries;}
\DoxyCodeLine{00102     std::unordered\_map<std::string, ComPtr<ID3DBlob>> mShaders;}
\DoxyCodeLine{00103     std::unordered\_map<std::string, ComPtr<ID3D12PipelineState>> mPSOs;}
\DoxyCodeLine{00104 }
\DoxyCodeLine{00105     std::vector<D3D12\_INPUT\_ELEMENT\_DESC> mInputLayout;}
\DoxyCodeLine{00106 }
\DoxyCodeLine{00107     \textcolor{comment}{// List of all the render items.}}
\DoxyCodeLine{00108     std::vector<std::unique\_ptr<RenderItem>> mAllRitems;}
\DoxyCodeLine{00109 }
\DoxyCodeLine{00110     \textcolor{comment}{//Our application will maintain lists of render items based on how they need to be}}
\DoxyCodeLine{00111     \textcolor{comment}{//drawn; that is, render items that need different PSOs will be kept in different lists.}}
\DoxyCodeLine{00112 }
\DoxyCodeLine{00113     \textcolor{comment}{// Render items divided by PSO.}}
\DoxyCodeLine{00114     std::vector<RenderItem*> mOpaqueRitems;}
\DoxyCodeLine{00115 }
\DoxyCodeLine{00116     \textcolor{comment}{//std::vector<RenderItem*> mTransparentRitems;  //we could have render items for transparant items}}
\DoxyCodeLine{00117 }
\DoxyCodeLine{00118 }
\DoxyCodeLine{00119 }
\DoxyCodeLine{00120     \textcolor{comment}{//this mMainPassCB stores constant data that is fixed over a given}}
\DoxyCodeLine{00121     \textcolor{comment}{//rendering pass such as the eye position, the view and projection matrices, and information}}
\DoxyCodeLine{00122     \textcolor{comment}{//about the screen(render target) dimensions; it also includes game timing information,}}
\DoxyCodeLine{00123     \textcolor{comment}{//which is useful data to have access to in shader programs.}}
\DoxyCodeLine{00124 }
\DoxyCodeLine{00125     PassConstants mMainPassCB;}
\DoxyCodeLine{00126 }
\DoxyCodeLine{00127     UINT mPassCbvOffset = 0;}
\DoxyCodeLine{00128 }
\DoxyCodeLine{00129     \textcolor{keywordtype}{bool} mIsWireframe = \textcolor{keyword}{false};}
\DoxyCodeLine{00130 }
\DoxyCodeLine{00131     XMFLOAT3 mEyePos = \{ 0.0f, 0.0f, 0.0f \};}
\DoxyCodeLine{00132     XMFLOAT4X4 mView = MathHelper::Identity4x4();}
\DoxyCodeLine{00133     XMFLOAT4X4 mProj = MathHelper::Identity4x4();}
\DoxyCodeLine{00134 }
\DoxyCodeLine{00135     \textcolor{keywordtype}{float} mTheta = 1.5f * XM\_PI;}
\DoxyCodeLine{00136     \textcolor{keywordtype}{float} mPhi = 0.2f * XM\_PI;}
\DoxyCodeLine{00137     \textcolor{keywordtype}{float} mRadius = 15.0f;}
\DoxyCodeLine{00138 }
\DoxyCodeLine{00139     POINT mLastMousePos;}
\DoxyCodeLine{00140 \};}
\DoxyCodeLine{00141 }
\DoxyCodeLine{00142 \textcolor{keywordtype}{int} WINAPI WinMain(HINSTANCE hInstance, HINSTANCE prevInstance,}
\DoxyCodeLine{00143     PSTR cmdLine, \textcolor{keywordtype}{int} showCmd)}
\DoxyCodeLine{00144 \{}
\DoxyCodeLine{00145     \textcolor{comment}{// Enable run-\/time memory check for debug builds.}}
\DoxyCodeLine{00146 \textcolor{preprocessor}{\#if defined(DEBUG) | defined(\_DEBUG)}}
\DoxyCodeLine{00147     \_CrtSetDbgFlag(\_CRTDBG\_ALLOC\_MEM\_DF | \_CRTDBG\_LEAK\_CHECK\_DF);}
\DoxyCodeLine{00148 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00149 }
\DoxyCodeLine{00150     \textcolor{keywordflow}{try}}
\DoxyCodeLine{00151     \{}
\DoxyCodeLine{00152         TriangleTessellationApp theApp(hInstance);}
\DoxyCodeLine{00153         \textcolor{keywordflow}{if} (!theApp.Initialize())}
\DoxyCodeLine{00154             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00155 }
\DoxyCodeLine{00156         \textcolor{keywordflow}{return} theApp.Run();}
\DoxyCodeLine{00157     \}}
\DoxyCodeLine{00158     \textcolor{keywordflow}{catch} (DxException\& e)}
\DoxyCodeLine{00159     \{}
\DoxyCodeLine{00160         MessageBox(\textcolor{keyword}{nullptr}, e.ToString().c\_str(), L\textcolor{stringliteral}{"{}HR Failed"{}}, MB\_OK);}
\DoxyCodeLine{00161         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00162     \}}
\DoxyCodeLine{00163 \}}
\DoxyCodeLine{00164 }
\DoxyCodeLine{00165 TriangleTessellationApp::TriangleTessellationApp(HINSTANCE hInstance)}
\DoxyCodeLine{00166     : D3DApp(hInstance)}
\DoxyCodeLine{00167 \{}
\DoxyCodeLine{00168 \}}
\DoxyCodeLine{00169 }
\DoxyCodeLine{00170 TriangleTessellationApp::\string~TriangleTessellationApp()}
\DoxyCodeLine{00171 \{}
\DoxyCodeLine{00172     \textcolor{keywordflow}{if} (md3dDevice != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00173         FlushCommandQueue();}
\DoxyCodeLine{00174 \}}
\DoxyCodeLine{00175 }
\DoxyCodeLine{00176 \textcolor{keywordtype}{bool} TriangleTessellationApp::Initialize()}
\DoxyCodeLine{00177 \{}
\DoxyCodeLine{00178     \textcolor{keywordflow}{if} (!D3DApp::Initialize())}
\DoxyCodeLine{00179         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{00180 }
\DoxyCodeLine{00181     \textcolor{comment}{// Reset the command list to prep for initialization commands.}}
\DoxyCodeLine{00182     ThrowIfFailed(mCommandList-\/>Reset(mDirectCmdListAlloc.Get(), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{00183 }
\DoxyCodeLine{00184     BuildRootSignature();}
\DoxyCodeLine{00185     BuildShadersAndInputLayout();}
\DoxyCodeLine{00186     BuildShapeGeometry();}
\DoxyCodeLine{00187     BuildRenderItems();}
\DoxyCodeLine{00188     BuildFrameResources();}
\DoxyCodeLine{00189     BuildDescriptorHeaps();}
\DoxyCodeLine{00190     BuildConstantBufferViews();}
\DoxyCodeLine{00191     BuildPSOs();}
\DoxyCodeLine{00192 }
\DoxyCodeLine{00193     \textcolor{comment}{// Execute the initialization commands.}}
\DoxyCodeLine{00194     ThrowIfFailed(mCommandList-\/>Close());}
\DoxyCodeLine{00195     ID3D12CommandList* cmdsLists[] = \{ mCommandList.Get() \};}
\DoxyCodeLine{00196     mCommandQueue-\/>ExecuteCommandLists(\_countof(cmdsLists), cmdsLists);}
\DoxyCodeLine{00197 }
\DoxyCodeLine{00198     \textcolor{comment}{// Wait until initialization is complete.}}
\DoxyCodeLine{00199     FlushCommandQueue();}
\DoxyCodeLine{00200 }
\DoxyCodeLine{00201     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00202 \}}
\DoxyCodeLine{00203 }
\DoxyCodeLine{00204 \textcolor{keywordtype}{void} TriangleTessellationApp::OnResize()}
\DoxyCodeLine{00205 \{}
\DoxyCodeLine{00206     D3DApp::OnResize();}
\DoxyCodeLine{00207 }
\DoxyCodeLine{00208     \textcolor{comment}{// The window resized, so update the aspect ratio and recompute the projection matrix.}}
\DoxyCodeLine{00209     XMMATRIX P = XMMatrixPerspectiveFovLH(0.25f * MathHelper::Pi, AspectRatio(), 1.0f, 1000.0f);}
\DoxyCodeLine{00210     XMStoreFloat4x4(\&mProj, P);}
\DoxyCodeLine{00211 \}}
\DoxyCodeLine{00212 }
\DoxyCodeLine{00213 \textcolor{comment}{//for CPU frame n, the algorithm}}
\DoxyCodeLine{00214 \textcolor{comment}{//1. Cycle through the circular frame resource array.}}
\DoxyCodeLine{00215 \textcolor{comment}{//2. Wait until the GPU has completed commands up to this fence point.}}
\DoxyCodeLine{00216 \textcolor{comment}{//3. Update resources in mCurrFrameResource (like cbuffers).}}
\DoxyCodeLine{00217 }
\DoxyCodeLine{00218 \textcolor{keywordtype}{void} TriangleTessellationApp::Update(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00219 \{}
\DoxyCodeLine{00220     OnKeyboardInput(gt);}
\DoxyCodeLine{00221     UpdateCamera(gt);}
\DoxyCodeLine{00222 }
\DoxyCodeLine{00223     \textcolor{comment}{// Cycle through the circular frame resource array.}}
\DoxyCodeLine{00224     mCurrFrameResourceIndex = (mCurrFrameResourceIndex + 1) \% gNumFrameResources;}
\DoxyCodeLine{00225     mCurrFrameResource = mFrameResources[mCurrFrameResourceIndex].get();}
\DoxyCodeLine{00226 }
\DoxyCodeLine{00227     \textcolor{comment}{//this section is really what D3DApp::FlushCommandQueue() used to do for us at the end of each draw() function!}}
\DoxyCodeLine{00228     \textcolor{keywordflow}{if} (mCurrFrameResource-\/>Fence != 0 \&\& mFence-\/>GetCompletedValue() < mCurrFrameResource-\/>Fence)}
\DoxyCodeLine{00229     \{}
\DoxyCodeLine{00230         HANDLE eventHandle = CreateEventEx(\textcolor{keyword}{nullptr}, \textcolor{keyword}{nullptr}, \textcolor{keyword}{false}, EVENT\_ALL\_ACCESS);}
\DoxyCodeLine{00231         ThrowIfFailed(mFence-\/>SetEventOnCompletion(mCurrFrameResource-\/>Fence, eventHandle));}
\DoxyCodeLine{00232         WaitForSingleObject(eventHandle, INFINITE);}
\DoxyCodeLine{00233         CloseHandle(eventHandle);}
\DoxyCodeLine{00234     \}}
\DoxyCodeLine{00235 }
\DoxyCodeLine{00236     \textcolor{comment}{//The idea of these changes is to group constants based on update frequency. The per}}
\DoxyCodeLine{00237     \textcolor{comment}{//pass constants only need to be updated once per rendering pass, and the object constants}}
\DoxyCodeLine{00238     \textcolor{comment}{//only need to change when an object’s world matrix changes.}}
\DoxyCodeLine{00239     UpdateObjectCBs(gt);}
\DoxyCodeLine{00240     UpdateMainPassCB(gt);}
\DoxyCodeLine{00241 \}}
\DoxyCodeLine{00242 }
\DoxyCodeLine{00243 \textcolor{keywordtype}{void} TriangleTessellationApp::Draw(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00244 \{}
\DoxyCodeLine{00245     \textcolor{keyword}{auto} cmdListAlloc = mCurrFrameResource-\/>CmdListAlloc;}
\DoxyCodeLine{00246 }
\DoxyCodeLine{00247     \textcolor{comment}{// Reuse the memory associated with command recording.}}
\DoxyCodeLine{00248     \textcolor{comment}{// We can only reset when the associated command lists have finished execution on the GPU.}}
\DoxyCodeLine{00249     ThrowIfFailed(cmdListAlloc-\/>Reset());}
\DoxyCodeLine{00250 }
\DoxyCodeLine{00251     \textcolor{comment}{// A command list can be reset after it has been added to the command queue via ExecuteCommandList.}}
\DoxyCodeLine{00252     \textcolor{comment}{// Reusing the command list reuses memory.}}
\DoxyCodeLine{00253     \textcolor{keywordflow}{if} (mIsWireframe)}
\DoxyCodeLine{00254     \{}
\DoxyCodeLine{00255         ThrowIfFailed(mCommandList-\/>Reset(cmdListAlloc.Get(), mPSOs[\textcolor{stringliteral}{"{}opaque\_wireframe"{}}].Get()));}
\DoxyCodeLine{00256     \}}
\DoxyCodeLine{00257     \textcolor{keywordflow}{else}}
\DoxyCodeLine{00258     \{}
\DoxyCodeLine{00259         ThrowIfFailed(mCommandList-\/>Reset(cmdListAlloc.Get(), mPSOs[\textcolor{stringliteral}{"{}opaque"{}}].Get()));}
\DoxyCodeLine{00260     \}}
\DoxyCodeLine{00261 }
\DoxyCodeLine{00262     mCommandList-\/>RSSetViewports(1, \&mScreenViewport);}
\DoxyCodeLine{00263     mCommandList-\/>RSSetScissorRects(1, \&mScissorRect);}
\DoxyCodeLine{00264 }
\DoxyCodeLine{00265     \textcolor{comment}{// Indicate a state transition on the resource usage.}}
\DoxyCodeLine{00266     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(CurrentBackBuffer(),}
\DoxyCodeLine{00267         D3D12\_RESOURCE\_STATE\_PRESENT, D3D12\_RESOURCE\_STATE\_RENDER\_TARGET));}
\DoxyCodeLine{00268 }
\DoxyCodeLine{00269     \textcolor{comment}{// Clear the back buffer and depth buffer.}}
\DoxyCodeLine{00270     mCommandList-\/>ClearRenderTargetView(CurrentBackBufferView(), Colors::LightSteelBlue, 0, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00271     mCommandList-\/>ClearDepthStencilView(DepthStencilView(), D3D12\_CLEAR\_FLAG\_DEPTH | D3D12\_CLEAR\_FLAG\_STENCIL, 1.0f, 0, 0, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00272 }
\DoxyCodeLine{00273     \textcolor{comment}{// Specify the buffers we are going to render to.}}
\DoxyCodeLine{00274     mCommandList-\/>OMSetRenderTargets(1, \&CurrentBackBufferView(), \textcolor{keyword}{true}, \&DepthStencilView());}
\DoxyCodeLine{00275 }
\DoxyCodeLine{00276     ID3D12DescriptorHeap* descriptorHeaps[] = \{ mCbvHeap.Get() \};}
\DoxyCodeLine{00277     mCommandList-\/>SetDescriptorHeaps(\_countof(descriptorHeaps), descriptorHeaps);}
\DoxyCodeLine{00278 }
\DoxyCodeLine{00279     mCommandList-\/>SetGraphicsRootSignature(mRootSignature.Get());}
\DoxyCodeLine{00280 }
\DoxyCodeLine{00281     \textcolor{keywordtype}{int} passCbvIndex = mPassCbvOffset + mCurrFrameResourceIndex;}
\DoxyCodeLine{00282     \textcolor{keyword}{auto} passCbvHandle = CD3DX12\_GPU\_DESCRIPTOR\_HANDLE(mCbvHeap-\/>GetGPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00283     passCbvHandle.Offset(passCbvIndex, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{00284     mCommandList-\/>SetGraphicsRootDescriptorTable(1, passCbvHandle);}
\DoxyCodeLine{00285 }
\DoxyCodeLine{00286     DrawRenderItems(mCommandList.Get(), mOpaqueRitems);}
\DoxyCodeLine{00287 }
\DoxyCodeLine{00288     \textcolor{comment}{// Indicate a state transition on the resource usage.}}
\DoxyCodeLine{00289     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(CurrentBackBuffer(),}
\DoxyCodeLine{00290         D3D12\_RESOURCE\_STATE\_RENDER\_TARGET, D3D12\_RESOURCE\_STATE\_PRESENT));}
\DoxyCodeLine{00291 }
\DoxyCodeLine{00292     \textcolor{comment}{// Done recording commands.}}
\DoxyCodeLine{00293     ThrowIfFailed(mCommandList-\/>Close());}
\DoxyCodeLine{00294 }
\DoxyCodeLine{00295     \textcolor{comment}{// Add the command list to the queue for execution.}}
\DoxyCodeLine{00296     ID3D12CommandList* cmdsLists[] = \{ mCommandList.Get() \};}
\DoxyCodeLine{00297     mCommandQueue-\/>ExecuteCommandLists(\_countof(cmdsLists), cmdsLists);}
\DoxyCodeLine{00298 }
\DoxyCodeLine{00299     \textcolor{comment}{// Swap the back and front buffers}}
\DoxyCodeLine{00300     ThrowIfFailed(mSwapChain-\/>Present(0, 0));}
\DoxyCodeLine{00301     mCurrBackBuffer = (mCurrBackBuffer + 1) \% SwapChainBufferCount;}
\DoxyCodeLine{00302 }
\DoxyCodeLine{00303 }
\DoxyCodeLine{00304     \textcolor{comment}{//we have been calling D3DApp::FlushCommandQueue at the end of every}}
\DoxyCodeLine{00305     \textcolor{comment}{//frame to ensure the GPU has finished executing all the commands for the frame.This solution works but is inefficient}}
\DoxyCodeLine{00306     \textcolor{comment}{//For every frame, the CPU and GPU are idling at some point.}}
\DoxyCodeLine{00307     \textcolor{comment}{//  FlushCommandQueue();}}
\DoxyCodeLine{00308 }
\DoxyCodeLine{00309     \textcolor{comment}{//Advance the fence value to mark commands up to this fence point.}}
\DoxyCodeLine{00310     mCurrFrameResource-\/>Fence = ++mCurrentFence;}
\DoxyCodeLine{00311 }
\DoxyCodeLine{00312     \textcolor{comment}{// Add an instruction to the command queue to set a new fence point. }}
\DoxyCodeLine{00313     \textcolor{comment}{// Because we are on the GPU timeline, the new fence point won't be }}
\DoxyCodeLine{00314     \textcolor{comment}{// set until the GPU finishes processing all the commands prior to this Signal().}}
\DoxyCodeLine{00315     mCommandQueue-\/>Signal(mFence.Get(), mCurrentFence);}
\DoxyCodeLine{00316 }
\DoxyCodeLine{00317     \textcolor{comment}{// Note that GPU could still be working on commands from previous}}
\DoxyCodeLine{00318         \textcolor{comment}{// frames, but that is okay, because we are not touching any frame}}
\DoxyCodeLine{00319         \textcolor{comment}{// resources associated with those frames.}}
\DoxyCodeLine{00320 }
\DoxyCodeLine{00321 \}}
\DoxyCodeLine{00322 }
\DoxyCodeLine{00323 \textcolor{keywordtype}{void} TriangleTessellationApp::OnMouseDown(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)}
\DoxyCodeLine{00324 \{}
\DoxyCodeLine{00325     mLastMousePos.x = x;}
\DoxyCodeLine{00326     mLastMousePos.y = y;}
\DoxyCodeLine{00327 }
\DoxyCodeLine{00328     SetCapture(mhMainWnd);}
\DoxyCodeLine{00329 \}}
\DoxyCodeLine{00330 }
\DoxyCodeLine{00331 \textcolor{keywordtype}{void} TriangleTessellationApp::OnMouseUp(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)}
\DoxyCodeLine{00332 \{}
\DoxyCodeLine{00333     ReleaseCapture();}
\DoxyCodeLine{00334 \}}
\DoxyCodeLine{00335 }
\DoxyCodeLine{00336 \textcolor{keywordtype}{void} TriangleTessellationApp::OnMouseMove(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)}
\DoxyCodeLine{00337 \{}
\DoxyCodeLine{00338     \textcolor{keywordflow}{if} ((btnState \& MK\_LBUTTON) != 0)}
\DoxyCodeLine{00339     \{}
\DoxyCodeLine{00340         \textcolor{comment}{// Make each pixel correspond to a quarter of a degree.}}
\DoxyCodeLine{00341         \textcolor{keywordtype}{float} dx = XMConvertToRadians(0.25f * \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x -\/ mLastMousePos.x));}
\DoxyCodeLine{00342         \textcolor{keywordtype}{float} dy = XMConvertToRadians(0.25f * \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(y -\/ mLastMousePos.y));}
\DoxyCodeLine{00343 }
\DoxyCodeLine{00344         \textcolor{comment}{// Update angles based on input to orbit camera around box.}}
\DoxyCodeLine{00345         mTheta += dx;}
\DoxyCodeLine{00346         mPhi += dy;}
\DoxyCodeLine{00347 }
\DoxyCodeLine{00348         \textcolor{comment}{// Restrict the angle mPhi.}}
\DoxyCodeLine{00349         mPhi = MathHelper::Clamp(mPhi, 0.1f, MathHelper::Pi -\/ 0.1f);}
\DoxyCodeLine{00350     \}}
\DoxyCodeLine{00351     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((btnState \& MK\_RBUTTON) != 0)}
\DoxyCodeLine{00352     \{}
\DoxyCodeLine{00353         \textcolor{comment}{// Make each pixel correspond to 0.2 unit in the scene.}}
\DoxyCodeLine{00354         \textcolor{keywordtype}{float} dx = 0.05f * \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x -\/ mLastMousePos.x);}
\DoxyCodeLine{00355         \textcolor{keywordtype}{float} dy = 0.05f * \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(y -\/ mLastMousePos.y);}
\DoxyCodeLine{00356 }
\DoxyCodeLine{00357         \textcolor{comment}{// Update the camera radius based on input.}}
\DoxyCodeLine{00358         mRadius += dx -\/ dy;}
\DoxyCodeLine{00359 }
\DoxyCodeLine{00360         \textcolor{comment}{// Restrict the radius.}}
\DoxyCodeLine{00361         mRadius = MathHelper::Clamp(mRadius, 5.0f, 150.0f);}
\DoxyCodeLine{00362     \}}
\DoxyCodeLine{00363 }
\DoxyCodeLine{00364     mLastMousePos.x = x;}
\DoxyCodeLine{00365     mLastMousePos.y = y;}
\DoxyCodeLine{00366 \}}
\DoxyCodeLine{00367 }
\DoxyCodeLine{00368 \textcolor{keywordtype}{void} TriangleTessellationApp::OnKeyboardInput(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00369 \{}
\DoxyCodeLine{00370     \textcolor{comment}{//Determines whether a key is up or down at the time the function is called, and whether the key was pressed after a previous call to GetAsyncKeyState.}}
\DoxyCodeLine{00371     \textcolor{comment}{//If the function succeeds, the return value specifies whether the key was pressed since the last call to GetAsyncKeyState, }}
\DoxyCodeLine{00372     \textcolor{comment}{//and whether the key is currently up or down. If the most significant bit is set, the key is down, and if the least significant bit is set, the key was pressed after the previous call to GetAsyncKeyState.}}
\DoxyCodeLine{00373     \textcolor{comment}{//if (GetAsyncKeyState('1') \& 0x8000)}}
\DoxyCodeLine{00374 }
\DoxyCodeLine{00375     \textcolor{keywordtype}{short} key = GetAsyncKeyState(\textcolor{charliteral}{'1'});}
\DoxyCodeLine{00376     \textcolor{keywordflow}{if} (key \& 0x8000)  \textcolor{comment}{//if one is pressed, 0x8000 = 32767 , key = -\/32767 = FFFFFFFFFFFF8001}}
\DoxyCodeLine{00377         mIsWireframe = \textcolor{keyword}{true};}
\DoxyCodeLine{00378     \textcolor{keywordflow}{else}}
\DoxyCodeLine{00379         mIsWireframe = \textcolor{keyword}{false};}
\DoxyCodeLine{00380 \}}
\DoxyCodeLine{00381 }
\DoxyCodeLine{00382 \textcolor{keywordtype}{void} TriangleTessellationApp::UpdateCamera(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00383 \{}
\DoxyCodeLine{00384     \textcolor{comment}{// Convert Spherical to Cartesian coordinates.}}
\DoxyCodeLine{00385     mEyePos.x = mRadius * sinf(mPhi) * cosf(mTheta);}
\DoxyCodeLine{00386     mEyePos.z = mRadius * sinf(mPhi) * sinf(mTheta);}
\DoxyCodeLine{00387     mEyePos.y = mRadius * cosf(mPhi);}
\DoxyCodeLine{00388 }
\DoxyCodeLine{00389     \textcolor{comment}{// Build the view matrix.}}
\DoxyCodeLine{00390     XMVECTOR pos = XMVectorSet(mEyePos.x, mEyePos.y, mEyePos.z, 1.0f);}
\DoxyCodeLine{00391     XMVECTOR target = XMVectorZero();}
\DoxyCodeLine{00392     XMVECTOR up = XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f);}
\DoxyCodeLine{00393 }
\DoxyCodeLine{00394     XMMATRIX view = XMMatrixLookAtLH(pos, target, up);}
\DoxyCodeLine{00395     XMStoreFloat4x4(\&mView, view);}
\DoxyCodeLine{00396 \}}
\DoxyCodeLine{00397 }
\DoxyCodeLine{00398 \textcolor{comment}{//Update resources (cbuffers) in mCurrFrameResource}}
\DoxyCodeLine{00399 \textcolor{keywordtype}{void} TriangleTessellationApp::UpdateObjectCBs(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00400 \{}
\DoxyCodeLine{00401     \textcolor{keyword}{auto} currObjectCB = mCurrFrameResource-\/>ObjectCB.get();}
\DoxyCodeLine{00402     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& e : mAllRitems)}
\DoxyCodeLine{00403     \{}
\DoxyCodeLine{00404         \textcolor{comment}{// Only update the cbuffer data if the constants have changed.  }}
\DoxyCodeLine{00405         \textcolor{comment}{// This needs to be tracked per frame resource.}}
\DoxyCodeLine{00406         \textcolor{keywordflow}{if} (e-\/>NumFramesDirty > 0)}
\DoxyCodeLine{00407         \{}
\DoxyCodeLine{00408             XMMATRIX world = XMLoadFloat4x4(\&e-\/>World);}
\DoxyCodeLine{00409 }
\DoxyCodeLine{00410             ObjectConstants objConstants;}
\DoxyCodeLine{00411             XMStoreFloat4x4(\&objConstants.World, XMMatrixTranspose(world));}
\DoxyCodeLine{00412 }
\DoxyCodeLine{00413             currObjectCB-\/>CopyData(e-\/>ObjCBIndex, objConstants);}
\DoxyCodeLine{00414 }
\DoxyCodeLine{00415             \textcolor{comment}{// Next FrameResource need to be updated too.}}
\DoxyCodeLine{00416             e-\/>NumFramesDirty-\/-\/;}
\DoxyCodeLine{00417         \}}
\DoxyCodeLine{00418     \}}
\DoxyCodeLine{00419 \}}
\DoxyCodeLine{00420 }
\DoxyCodeLine{00421 \textcolor{comment}{//CBVs will be set at different frequencies—the per pass CBV only needs to be set once per}}
\DoxyCodeLine{00422 \textcolor{comment}{//rendering pass while the per object CBV needs to be set per render item}}
\DoxyCodeLine{00423 \textcolor{keywordtype}{void} TriangleTessellationApp::UpdateMainPassCB(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00424 \{}
\DoxyCodeLine{00425     XMMATRIX view = XMLoadFloat4x4(\&mView);}
\DoxyCodeLine{00426     XMMATRIX proj = XMLoadFloat4x4(\&mProj);}
\DoxyCodeLine{00427 }
\DoxyCodeLine{00428     XMMATRIX viewProj = XMMatrixMultiply(view, proj);}
\DoxyCodeLine{00429     XMMATRIX invView = XMMatrixInverse(\&XMMatrixDeterminant(view), view);}
\DoxyCodeLine{00430     XMMATRIX invProj = XMMatrixInverse(\&XMMatrixDeterminant(proj), proj);}
\DoxyCodeLine{00431     XMMATRIX invViewProj = XMMatrixInverse(\&XMMatrixDeterminant(viewProj), viewProj);}
\DoxyCodeLine{00432 }
\DoxyCodeLine{00433     XMStoreFloat4x4(\&mMainPassCB.View, XMMatrixTranspose(view));}
\DoxyCodeLine{00434     XMStoreFloat4x4(\&mMainPassCB.InvView, XMMatrixTranspose(invView));}
\DoxyCodeLine{00435     XMStoreFloat4x4(\&mMainPassCB.Proj, XMMatrixTranspose(proj));}
\DoxyCodeLine{00436     XMStoreFloat4x4(\&mMainPassCB.InvProj, XMMatrixTranspose(invProj));}
\DoxyCodeLine{00437     XMStoreFloat4x4(\&mMainPassCB.ViewProj, XMMatrixTranspose(viewProj));}
\DoxyCodeLine{00438     XMStoreFloat4x4(\&mMainPassCB.InvViewProj, XMMatrixTranspose(invViewProj));}
\DoxyCodeLine{00439     mMainPassCB.EyePosW = mEyePos;}
\DoxyCodeLine{00440     mMainPassCB.RenderTargetSize = XMFLOAT2((\textcolor{keywordtype}{float})mClientWidth, (\textcolor{keywordtype}{float})mClientHeight);}
\DoxyCodeLine{00441     mMainPassCB.InvRenderTargetSize = XMFLOAT2(1.0f / mClientWidth, 1.0f / mClientHeight);}
\DoxyCodeLine{00442     mMainPassCB.NearZ = 1.0f;}
\DoxyCodeLine{00443     mMainPassCB.FarZ = 1000.0f;}
\DoxyCodeLine{00444     mMainPassCB.TotalTime = gt.TotalTime();}
\DoxyCodeLine{00445     mMainPassCB.DeltaTime = gt.DeltaTime();}
\DoxyCodeLine{00446 }
\DoxyCodeLine{00447     \textcolor{keyword}{auto} currPassCB = mCurrFrameResource-\/>PassCB.get();}
\DoxyCodeLine{00448     currPassCB-\/>CopyData(0, mMainPassCB);}
\DoxyCodeLine{00449 \}}
\DoxyCodeLine{00450 }
\DoxyCodeLine{00451 \textcolor{keywordtype}{void} TriangleTessellationApp::BuildDescriptorHeaps()}
\DoxyCodeLine{00452 \{}
\DoxyCodeLine{00453     UINT objCount = (UINT)mOpaqueRitems.size();}
\DoxyCodeLine{00454 }
\DoxyCodeLine{00455     \textcolor{comment}{// Need a CBV descriptor for each object for each frame resource,}}
\DoxyCodeLine{00456     \textcolor{comment}{// +1 for the perPass CBV for each frame resource.}}
\DoxyCodeLine{00457     UINT numDescriptors = (objCount + 1) * gNumFrameResources;}
\DoxyCodeLine{00458 }
\DoxyCodeLine{00459     \textcolor{comment}{// Save an offset to the start of the pass CBVs.  These are the last 3 descriptors.}}
\DoxyCodeLine{00460     mPassCbvOffset = objCount * gNumFrameResources;}
\DoxyCodeLine{00461 }
\DoxyCodeLine{00462     D3D12\_DESCRIPTOR\_HEAP\_DESC cbvHeapDesc;}
\DoxyCodeLine{00463     cbvHeapDesc.NumDescriptors = numDescriptors;}
\DoxyCodeLine{00464     cbvHeapDesc.Type = D3D12\_DESCRIPTOR\_HEAP\_TYPE\_CBV\_SRV\_UAV;}
\DoxyCodeLine{00465     cbvHeapDesc.Flags = D3D12\_DESCRIPTOR\_HEAP\_FLAG\_SHADER\_VISIBLE;}
\DoxyCodeLine{00466     cbvHeapDesc.NodeMask = 0;}
\DoxyCodeLine{00467     ThrowIfFailed(md3dDevice-\/>CreateDescriptorHeap(\&cbvHeapDesc,}
\DoxyCodeLine{00468         IID\_PPV\_ARGS(\&mCbvHeap)));}
\DoxyCodeLine{00469 \}}
\DoxyCodeLine{00470 }
\DoxyCodeLine{00471 \textcolor{keywordtype}{void} TriangleTessellationApp::BuildConstantBufferViews()}
\DoxyCodeLine{00472 \{}
\DoxyCodeLine{00473     UINT objCBByteSize = d3dUtil::CalcConstantBufferByteSize(\textcolor{keyword}{sizeof}(ObjectConstants));}
\DoxyCodeLine{00474 }
\DoxyCodeLine{00475     UINT objCount = (UINT)mOpaqueRitems.size();}
\DoxyCodeLine{00476 }
\DoxyCodeLine{00477     \textcolor{comment}{// Need a CBV descriptor for each object for each frame resource.}}
\DoxyCodeLine{00478     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} frameIndex = 0; frameIndex < gNumFrameResources; ++frameIndex)}
\DoxyCodeLine{00479     \{}
\DoxyCodeLine{00480         \textcolor{keyword}{auto} objectCB = mFrameResources[frameIndex]-\/>ObjectCB-\/>Resource();}
\DoxyCodeLine{00481         \textcolor{keywordflow}{for} (UINT i = 0; i < objCount; ++i)}
\DoxyCodeLine{00482         \{}
\DoxyCodeLine{00483             D3D12\_GPU\_VIRTUAL\_ADDRESS cbAddress = objectCB-\/>GetGPUVirtualAddress();}
\DoxyCodeLine{00484 }
\DoxyCodeLine{00485             \textcolor{comment}{// Offset to the ith object constant buffer in the buffer.}}
\DoxyCodeLine{00486             cbAddress += i * objCBByteSize;}
\DoxyCodeLine{00487 }
\DoxyCodeLine{00488             \textcolor{comment}{// Offset to the object cbv in the descriptor heap.}}
\DoxyCodeLine{00489             \textcolor{keywordtype}{int} heapIndex = frameIndex * objCount + i;}
\DoxyCodeLine{00490             \textcolor{keyword}{auto} handle = CD3DX12\_CPU\_DESCRIPTOR\_HANDLE(mCbvHeap-\/>GetCPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00491             handle.Offset(heapIndex, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{00492 }
\DoxyCodeLine{00493             D3D12\_CONSTANT\_BUFFER\_VIEW\_DESC cbvDesc;}
\DoxyCodeLine{00494             cbvDesc.BufferLocation = cbAddress;}
\DoxyCodeLine{00495             cbvDesc.SizeInBytes = objCBByteSize;}
\DoxyCodeLine{00496 }
\DoxyCodeLine{00497             md3dDevice-\/>CreateConstantBufferView(\&cbvDesc, handle);}
\DoxyCodeLine{00498         \}}
\DoxyCodeLine{00499     \}}
\DoxyCodeLine{00500 }
\DoxyCodeLine{00501     UINT passCBByteSize = d3dUtil::CalcConstantBufferByteSize(\textcolor{keyword}{sizeof}(PassConstants));}
\DoxyCodeLine{00502 }
\DoxyCodeLine{00503     \textcolor{comment}{// Last three descriptors are the pass CBVs for each frame resource.}}
\DoxyCodeLine{00504     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} frameIndex = 0; frameIndex < gNumFrameResources; ++frameIndex)}
\DoxyCodeLine{00505     \{}
\DoxyCodeLine{00506         \textcolor{keyword}{auto} passCB = mFrameResources[frameIndex]-\/>PassCB-\/>Resource();}
\DoxyCodeLine{00507         D3D12\_GPU\_VIRTUAL\_ADDRESS cbAddress = passCB-\/>GetGPUVirtualAddress();}
\DoxyCodeLine{00508 }
\DoxyCodeLine{00509         \textcolor{comment}{// Offset to the pass cbv in the descriptor heap.}}
\DoxyCodeLine{00510         \textcolor{keywordtype}{int} heapIndex = mPassCbvOffset + frameIndex;}
\DoxyCodeLine{00511         \textcolor{keyword}{auto} handle = CD3DX12\_CPU\_DESCRIPTOR\_HANDLE(mCbvHeap-\/>GetCPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00512         handle.Offset(heapIndex, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{00513 }
\DoxyCodeLine{00514         D3D12\_CONSTANT\_BUFFER\_VIEW\_DESC cbvDesc;}
\DoxyCodeLine{00515         cbvDesc.BufferLocation = cbAddress;}
\DoxyCodeLine{00516         cbvDesc.SizeInBytes = passCBByteSize;}
\DoxyCodeLine{00517 }
\DoxyCodeLine{00518         md3dDevice-\/>CreateConstantBufferView(\&cbvDesc, handle);}
\DoxyCodeLine{00519     \}}
\DoxyCodeLine{00520 \}}
\DoxyCodeLine{00521 }
\DoxyCodeLine{00522 \textcolor{keywordtype}{void} TriangleTessellationApp::BuildRootSignature()}
\DoxyCodeLine{00523 \{}
\DoxyCodeLine{00524     \textcolor{comment}{//The resources that our shaders expect have changed; therefore, we need to update the}}
\DoxyCodeLine{00525     \textcolor{comment}{//root signature accordingly to take two descriptor tables(we need two tables because the}}
\DoxyCodeLine{00526     \textcolor{comment}{//CBVs will be set at different frequencies—the per pass CBV only needs to be set once per}}
\DoxyCodeLine{00527     \textcolor{comment}{//rendering pass while the per object CBV needs to be set per render item) :}}
\DoxyCodeLine{00528 }
\DoxyCodeLine{00529     CD3DX12\_DESCRIPTOR\_RANGE cbvTable0;}
\DoxyCodeLine{00530     cbvTable0.Init(D3D12\_DESCRIPTOR\_RANGE\_TYPE\_CBV, 1, 0);}
\DoxyCodeLine{00531 }
\DoxyCodeLine{00532     CD3DX12\_DESCRIPTOR\_RANGE cbvTable1;}
\DoxyCodeLine{00533     cbvTable1.Init(D3D12\_DESCRIPTOR\_RANGE\_TYPE\_CBV, 1, 1);}
\DoxyCodeLine{00534 }
\DoxyCodeLine{00535     \textcolor{comment}{// Root parameter can be a table, root descriptor or root constants.}}
\DoxyCodeLine{00536     CD3DX12\_ROOT\_PARAMETER slotRootParameter[2];}
\DoxyCodeLine{00537 }
\DoxyCodeLine{00538     \textcolor{comment}{// Create root CBVs.}}
\DoxyCodeLine{00539     slotRootParameter[0].InitAsDescriptorTable(1, \&cbvTable0);}
\DoxyCodeLine{00540     slotRootParameter[1].InitAsDescriptorTable(1, \&cbvTable1);}
\DoxyCodeLine{00541 }
\DoxyCodeLine{00542     \textcolor{comment}{// A root signature is an array of root parameters.}}
\DoxyCodeLine{00543     CD3DX12\_ROOT\_SIGNATURE\_DESC rootSigDesc(2, slotRootParameter, 0, \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00544         D3D12\_ROOT\_SIGNATURE\_FLAG\_ALLOW\_INPUT\_ASSEMBLER\_INPUT\_LAYOUT);}
\DoxyCodeLine{00545 }
\DoxyCodeLine{00546     \textcolor{comment}{// create a root signature with a single slot which points to a descriptor range consisting of a single constant buffer}}
\DoxyCodeLine{00547     ComPtr<ID3DBlob> serializedRootSig = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00548     ComPtr<ID3DBlob> errorBlob = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00549     HRESULT hr = D3D12SerializeRootSignature(\&rootSigDesc, D3D\_ROOT\_SIGNATURE\_VERSION\_1,}
\DoxyCodeLine{00550         serializedRootSig.GetAddressOf(), errorBlob.GetAddressOf());}
\DoxyCodeLine{00551 }
\DoxyCodeLine{00552     \textcolor{keywordflow}{if} (errorBlob != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00553     \{}
\DoxyCodeLine{00554         ::OutputDebugStringA((\textcolor{keywordtype}{char}*)errorBlob-\/>GetBufferPointer());}
\DoxyCodeLine{00555     \}}
\DoxyCodeLine{00556     ThrowIfFailed(hr);}
\DoxyCodeLine{00557 }
\DoxyCodeLine{00558     ThrowIfFailed(md3dDevice-\/>CreateRootSignature(}
\DoxyCodeLine{00559         0,}
\DoxyCodeLine{00560         serializedRootSig-\/>GetBufferPointer(),}
\DoxyCodeLine{00561         serializedRootSig-\/>GetBufferSize(),}
\DoxyCodeLine{00562         IID\_PPV\_ARGS(mRootSignature.GetAddressOf())));}
\DoxyCodeLine{00563 \}}
\DoxyCodeLine{00564 }
\DoxyCodeLine{00565 \textcolor{keywordtype}{void} TriangleTessellationApp::BuildShadersAndInputLayout()}
\DoxyCodeLine{00566 \{}
\DoxyCodeLine{00567     mShaders[\textcolor{stringliteral}{"{}standardVS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)VS.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}VS"{}}, \textcolor{stringliteral}{"{}vs\_5\_1"{}});}
\DoxyCodeLine{00568     mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)PS.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}PS"{}}, \textcolor{stringliteral}{"{}ps\_5\_1"{}});}
\DoxyCodeLine{00569 }
\DoxyCodeLine{00570     mShaders[\textcolor{stringliteral}{"{}tessHS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)Tessellation.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}HS"{}}, \textcolor{stringliteral}{"{}hs\_5\_1"{}});}
\DoxyCodeLine{00571     mShaders[\textcolor{stringliteral}{"{}tessDS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)Tessellation.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}DS"{}}, \textcolor{stringliteral}{"{}ds\_5\_1"{}});}
\DoxyCodeLine{00572 }
\DoxyCodeLine{00573     mInputLayout =}
\DoxyCodeLine{00574     \{}
\DoxyCodeLine{00575         \{ \textcolor{stringliteral}{"{}POSITION"{}}, 0, DXGI\_FORMAT\_R32G32B32\_FLOAT, 0, 0, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{00576         \{ \textcolor{stringliteral}{"{}COLOR"{}}, 0, DXGI\_FORMAT\_R32G32B32A32\_FLOAT, 0, 12, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{00577     \};}
\DoxyCodeLine{00578 \}}
\DoxyCodeLine{00579 }
\DoxyCodeLine{00580 \textcolor{keywordtype}{void} TriangleTessellationApp::BuildShapeGeometry()}
\DoxyCodeLine{00581 \{}
\DoxyCodeLine{00582     std::array<Vertex, 3> vertices =}
\DoxyCodeLine{00583     \{}
\DoxyCodeLine{00584                 Vertex(\{ XMFLOAT3(-\/1.5f, -\/1.5f, 0.0f), XMFLOAT4(Colors::Red)\}),}
\DoxyCodeLine{00585                 Vertex(\{ XMFLOAT3(+1.5f, +1.5f, 0.0f) , XMFLOAT4(Colors::Green) \}),}
\DoxyCodeLine{00586                 Vertex(\{ XMFLOAT3(+1.5f, -\/1.5f, 0.0f) , XMFLOAT4(Colors::Blue)\}),}
\DoxyCodeLine{00587 }
\DoxyCodeLine{00588     \};}
\DoxyCodeLine{00589 }
\DoxyCodeLine{00590 }
\DoxyCodeLine{00591     std::array<std::uint16\_t, 3> indices =}
\DoxyCodeLine{00592     \{}
\DoxyCodeLine{00593 }
\DoxyCodeLine{00594         0, 1, 2}
\DoxyCodeLine{00595     \};}
\DoxyCodeLine{00596 }
\DoxyCodeLine{00597 }
\DoxyCodeLine{00598 }
\DoxyCodeLine{00599     \textcolor{keyword}{const} UINT vbByteSize = (UINT)vertices.size() * \textcolor{keyword}{sizeof}(Vertex);}
\DoxyCodeLine{00600     \textcolor{keyword}{const} UINT ibByteSize = (UINT)indices.size() * \textcolor{keyword}{sizeof}(std::uint16\_t);}
\DoxyCodeLine{00601 }
\DoxyCodeLine{00602     \textcolor{keyword}{auto} mBoxGeo = std::make\_unique<MeshGeometry>();}
\DoxyCodeLine{00603     mBoxGeo-\/>Name = \textcolor{stringliteral}{"{}shapeGeo"{}};}
\DoxyCodeLine{00604 }
\DoxyCodeLine{00605     ThrowIfFailed(D3DCreateBlob(vbByteSize, \&mBoxGeo-\/>VertexBufferCPU));}
\DoxyCodeLine{00606     CopyMemory(mBoxGeo-\/>VertexBufferCPU-\/>GetBufferPointer(), vertices.data(), vbByteSize);}
\DoxyCodeLine{00607 }
\DoxyCodeLine{00608     ThrowIfFailed(D3DCreateBlob(ibByteSize, \&mBoxGeo-\/>IndexBufferCPU));}
\DoxyCodeLine{00609     CopyMemory(mBoxGeo-\/>IndexBufferCPU-\/>GetBufferPointer(), indices.data(), ibByteSize);}
\DoxyCodeLine{00610 }
\DoxyCodeLine{00611     mBoxGeo-\/>VertexBufferGPU = d3dUtil::CreateDefaultBuffer(md3dDevice.Get(),}
\DoxyCodeLine{00612         mCommandList.Get(), vertices.data(), vbByteSize, mBoxGeo-\/>VertexBufferUploader);}
\DoxyCodeLine{00613 }
\DoxyCodeLine{00614     mBoxGeo-\/>IndexBufferGPU = d3dUtil::CreateDefaultBuffer(md3dDevice.Get(),}
\DoxyCodeLine{00615         mCommandList.Get(), indices.data(), ibByteSize, mBoxGeo-\/>IndexBufferUploader);}
\DoxyCodeLine{00616 }
\DoxyCodeLine{00617     mBoxGeo-\/>VertexByteStride = \textcolor{keyword}{sizeof}(Vertex);}
\DoxyCodeLine{00618     mBoxGeo-\/>VertexBufferByteSize = vbByteSize;}
\DoxyCodeLine{00619     mBoxGeo-\/>IndexFormat = DXGI\_FORMAT\_R16\_UINT;}
\DoxyCodeLine{00620     mBoxGeo-\/>IndexBufferByteSize = ibByteSize;}
\DoxyCodeLine{00621 }
\DoxyCodeLine{00622     SubmeshGeometry submesh;}
\DoxyCodeLine{00623     submesh.IndexCount = (UINT)indices.size();}
\DoxyCodeLine{00624     submesh.StartIndexLocation = 0;}
\DoxyCodeLine{00625     submesh.BaseVertexLocation = 0;}
\DoxyCodeLine{00626 }
\DoxyCodeLine{00627     mBoxGeo-\/>DrawArgs[\textcolor{stringliteral}{"{}box"{}}] = submesh;}
\DoxyCodeLine{00628 }
\DoxyCodeLine{00629 }
\DoxyCodeLine{00630     mGeometries[mBoxGeo-\/>Name] = std::move(mBoxGeo);}
\DoxyCodeLine{00631 }
\DoxyCodeLine{00632 \}}
\DoxyCodeLine{00633 }
\DoxyCodeLine{00634 \textcolor{keywordtype}{void} TriangleTessellationApp::BuildPSOs()}
\DoxyCodeLine{00635 \{}
\DoxyCodeLine{00636     D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC opaquePsoDesc;}
\DoxyCodeLine{00637 }
\DoxyCodeLine{00638     \textcolor{comment}{//}}
\DoxyCodeLine{00639     \textcolor{comment}{// PSO for opaque objects.}}
\DoxyCodeLine{00640     \textcolor{comment}{//}}
\DoxyCodeLine{00641     ZeroMemory(\&opaquePsoDesc, \textcolor{keyword}{sizeof}(D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC));}
\DoxyCodeLine{00642     opaquePsoDesc.InputLayout = \{ mInputLayout.data(), (UINT)mInputLayout.size() \};}
\DoxyCodeLine{00643     opaquePsoDesc.pRootSignature = mRootSignature.Get();}
\DoxyCodeLine{00644     opaquePsoDesc.VS =}
\DoxyCodeLine{00645     \{}
\DoxyCodeLine{00646         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}standardVS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{00647         mShaders[\textcolor{stringliteral}{"{}standardVS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{00648     \};}
\DoxyCodeLine{00649     opaquePsoDesc.PS =}
\DoxyCodeLine{00650     \{}
\DoxyCodeLine{00651         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{00652         mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{00653     \};}
\DoxyCodeLine{00654 }
\DoxyCodeLine{00655     opaquePsoDesc.HS =}
\DoxyCodeLine{00656     \{}
\DoxyCodeLine{00657         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}tessHS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{00658         mShaders[\textcolor{stringliteral}{"{}tessHS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{00659     \};}
\DoxyCodeLine{00660     opaquePsoDesc.DS =}
\DoxyCodeLine{00661     \{}
\DoxyCodeLine{00662         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}tessDS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{00663         mShaders[\textcolor{stringliteral}{"{}tessDS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{00664     \};}
\DoxyCodeLine{00665 }
\DoxyCodeLine{00666     opaquePsoDesc.RasterizerState = CD3DX12\_RASTERIZER\_DESC(D3D12\_DEFAULT);}
\DoxyCodeLine{00667     opaquePsoDesc.RasterizerState.FillMode = D3D12\_FILL\_MODE\_WIREFRAME;}
\DoxyCodeLine{00668     opaquePsoDesc.BlendState = CD3DX12\_BLEND\_DESC(D3D12\_DEFAULT);}
\DoxyCodeLine{00669     opaquePsoDesc.DepthStencilState = CD3DX12\_DEPTH\_STENCIL\_DESC(D3D12\_DEFAULT);}
\DoxyCodeLine{00670     opaquePsoDesc.SampleMask = UINT\_MAX;}
\DoxyCodeLine{00671     opaquePsoDesc.PrimitiveTopologyType = D3D12\_PRIMITIVE\_TOPOLOGY\_TYPE\_PATCH;}
\DoxyCodeLine{00672     opaquePsoDesc.NumRenderTargets = 1;}
\DoxyCodeLine{00673     opaquePsoDesc.RTVFormats[0] = mBackBufferFormat;}
\DoxyCodeLine{00674     opaquePsoDesc.SampleDesc.Count = m4xMsaaState ? 4 : 1;}
\DoxyCodeLine{00675     opaquePsoDesc.SampleDesc.Quality = m4xMsaaState ? (m4xMsaaQuality -\/ 1) : 0;}
\DoxyCodeLine{00676     opaquePsoDesc.DSVFormat = mDepthStencilFormat;}
\DoxyCodeLine{00677     ThrowIfFailed(md3dDevice-\/>CreateGraphicsPipelineState(\&opaquePsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}opaque"{}}])));}
\DoxyCodeLine{00678 }
\DoxyCodeLine{00679 }
\DoxyCodeLine{00680     \textcolor{comment}{//}}
\DoxyCodeLine{00681     \textcolor{comment}{// PSO for opaque wireframe objects.}}
\DoxyCodeLine{00682     \textcolor{comment}{//}}
\DoxyCodeLine{00683 }
\DoxyCodeLine{00684     D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC opaqueWireframePsoDesc = opaquePsoDesc;}
\DoxyCodeLine{00685     opaqueWireframePsoDesc.RasterizerState.FillMode = D3D12\_FILL\_MODE\_SOLID;}
\DoxyCodeLine{00686     ThrowIfFailed(md3dDevice-\/>CreateGraphicsPipelineState(\&opaqueWireframePsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}opaque\_wireframe"{}}])));}
\DoxyCodeLine{00687 \}}
\DoxyCodeLine{00688 }
\DoxyCodeLine{00689 }
\DoxyCodeLine{00690 \textcolor{keywordtype}{void} TriangleTessellationApp::BuildFrameResources()}
\DoxyCodeLine{00691 \{}
\DoxyCodeLine{00692     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < gNumFrameResources; ++i)}
\DoxyCodeLine{00693     \{}
\DoxyCodeLine{00694         mFrameResources.push\_back(std::make\_unique<FrameResource>(md3dDevice.Get(),}
\DoxyCodeLine{00695             1, (UINT)mAllRitems.size()));}
\DoxyCodeLine{00696     \}}
\DoxyCodeLine{00697 \}}
\DoxyCodeLine{00698 }
\DoxyCodeLine{00699 \textcolor{keywordtype}{void} TriangleTessellationApp::BuildRenderItems()}
\DoxyCodeLine{00700 \{}
\DoxyCodeLine{00701     \textcolor{keyword}{auto} boxRitem = std::make\_unique<RenderItem>();}
\DoxyCodeLine{00702     XMStoreFloat4x4(\&boxRitem-\/>World, XMMatrixScaling(2.0f, 2.0f, 2.0f) * XMMatrixTranslation(0.0f, 0.5f, 0.0f));}
\DoxyCodeLine{00703     boxRitem-\/>ObjCBIndex = 0;}
\DoxyCodeLine{00704     boxRitem-\/>Geo = mGeometries[\textcolor{stringliteral}{"{}shapeGeo"{}}].get();}
\DoxyCodeLine{00705     boxRitem-\/>PrimitiveType = D3D\_PRIMITIVE\_TOPOLOGY\_3\_CONTROL\_POINT\_PATCHLIST;}
\DoxyCodeLine{00706     boxRitem-\/>IndexCount = boxRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}box"{}}].IndexCount;  \textcolor{comment}{//36}}
\DoxyCodeLine{00707     boxRitem-\/>StartIndexLocation = boxRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}box"{}}].StartIndexLocation; \textcolor{comment}{//0}}
\DoxyCodeLine{00708     boxRitem-\/>BaseVertexLocation = boxRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}box"{}}].BaseVertexLocation; \textcolor{comment}{//0}}
\DoxyCodeLine{00709     mAllRitems.push\_back(std::move(boxRitem));}
\DoxyCodeLine{00710 }
\DoxyCodeLine{00711 }
\DoxyCodeLine{00712     \textcolor{comment}{// All the render items are opaque.}}
\DoxyCodeLine{00713     \textcolor{comment}{//Our application will maintain lists of render items based on how they need to be}}
\DoxyCodeLine{00714     \textcolor{comment}{//drawn; that is, render items that need different PSOs will be kept in different lists.}}
\DoxyCodeLine{00715     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& e : mAllRitems)}
\DoxyCodeLine{00716         mOpaqueRitems.push\_back(e.get());}
\DoxyCodeLine{00717 \}}
\DoxyCodeLine{00718 }
\DoxyCodeLine{00719 \textcolor{keywordtype}{void} TriangleTessellationApp::DrawRenderItems(ID3D12GraphicsCommandList* cmdList, \textcolor{keyword}{const} std::vector<RenderItem*>\& ritems)}
\DoxyCodeLine{00720 \{}
\DoxyCodeLine{00721     UINT objCBByteSize = d3dUtil::CalcConstantBufferByteSize(\textcolor{keyword}{sizeof}(ObjectConstants));}
\DoxyCodeLine{00722 }
\DoxyCodeLine{00723     \textcolor{keyword}{auto} objectCB = mCurrFrameResource-\/>ObjectCB-\/>Resource();}
\DoxyCodeLine{00724 }
\DoxyCodeLine{00725     \textcolor{comment}{// For each render item...}}
\DoxyCodeLine{00726     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < ritems.size(); ++i)}
\DoxyCodeLine{00727     \{}
\DoxyCodeLine{00728         \textcolor{keyword}{auto} ri = ritems[i];}
\DoxyCodeLine{00729 }
\DoxyCodeLine{00730         cmdList-\/>IASetVertexBuffers(0, 1, \&ri-\/>Geo-\/>VertexBufferView());}
\DoxyCodeLine{00731         cmdList-\/>IASetIndexBuffer(\&ri-\/>Geo-\/>IndexBufferView());}
\DoxyCodeLine{00732         cmdList-\/>IASetPrimitiveTopology(ri-\/>PrimitiveType);}
\DoxyCodeLine{00733 }
\DoxyCodeLine{00734         \textcolor{comment}{// Offset to the CBV in the descriptor heap for this object and for this frame resource.}}
\DoxyCodeLine{00735         UINT cbvIndex = mCurrFrameResourceIndex * (UINT)mOpaqueRitems.size() + ri-\/>ObjCBIndex;}
\DoxyCodeLine{00736         \textcolor{keyword}{auto} cbvHandle = CD3DX12\_GPU\_DESCRIPTOR\_HANDLE(mCbvHeap-\/>GetGPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00737         cbvHandle.Offset(cbvIndex, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{00738 }
\DoxyCodeLine{00739         cmdList-\/>SetGraphicsRootDescriptorTable(0, cbvHandle);}
\DoxyCodeLine{00740 }
\DoxyCodeLine{00741         cmdList-\/>DrawIndexedInstanced(ri-\/>IndexCount, 1, ri-\/>StartIndexLocation, ri-\/>BaseVertexLocation, 0);}
\DoxyCodeLine{00742     \}}
\DoxyCodeLine{00743 \}}
\DoxyCodeLine{00744 }
\DoxyCodeLine{00745 }

\end{DoxyCode}
