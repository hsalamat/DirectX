\doxysection{Week4-\/7-\/\+Land\+App.cpp}
\label{_week4-7-_land_app_8cpp_source}\index{Week4/BoxUsingFrameResource/Week4-\/7-\/LandApp.cpp@{Week4/BoxUsingFrameResource/Week4-\/7-\/LandApp.cpp}}
\textbf{ Go to the documentation of this file.}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001 \textcolor{comment}{//***************************************************************************************}}
\DoxyCodeLine{00002 \textcolor{comment}{// Land }}
\DoxyCodeLine{00003 \textcolor{comment}{//}}
\DoxyCodeLine{00004 \textcolor{comment}{// Hold down '1' key to view scene in wireframe mode.}}
\DoxyCodeLine{00005 \textcolor{comment}{//***************************************************************************************}}
\DoxyCodeLine{00006 }
\DoxyCodeLine{00007 \textcolor{preprocessor}{\#include "{}../../Common/d3dApp.h"{}}}
\DoxyCodeLine{00008 \textcolor{preprocessor}{\#include "{}../../Common/MathHelper.h"{}}}
\DoxyCodeLine{00009 \textcolor{preprocessor}{\#include "{}../../Common/UploadBuffer.h"{}}}
\DoxyCodeLine{00010 \textcolor{preprocessor}{\#include "{}../../Common/GeometryGenerator.h"{}}}
\DoxyCodeLine{00011 \textcolor{preprocessor}{\#include "{}FrameResource.h"{}}}
\DoxyCodeLine{00012 }
\DoxyCodeLine{00013 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{00014 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{00015 }
\DoxyCodeLine{00016 \textcolor{keyword}{using} Microsoft::WRL::ComPtr;}
\DoxyCodeLine{00017 \textcolor{keyword}{using namespace }DirectX;}
\DoxyCodeLine{00018 \textcolor{keyword}{using namespace }DirectX::PackedVector;}
\DoxyCodeLine{00019 }
\DoxyCodeLine{00020 \textcolor{comment}{//step3: Our application class will then instantiate a vector of three frame resources, }}
\DoxyCodeLine{00021 \textcolor{keyword}{const} \textcolor{keywordtype}{int} gNumFrameResources = 3;}
\DoxyCodeLine{00022 }
\DoxyCodeLine{00023 \textcolor{comment}{// Step10: Lightweight structure stores parameters to draw a shape.  This will vary from app-\/to-\/app.}}
\DoxyCodeLine{00024 \textcolor{keyword}{struct }RenderItem}
\DoxyCodeLine{00025 \{}
\DoxyCodeLine{00026     RenderItem() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{00027 }
\DoxyCodeLine{00028     \textcolor{comment}{// World matrix of the shape that describes the object's local space}}
\DoxyCodeLine{00029     \textcolor{comment}{// relative to the world space, which defines the position, orientation,}}
\DoxyCodeLine{00030     \textcolor{comment}{// and scale of the object in the world.}}
\DoxyCodeLine{00031     XMFLOAT4X4 World = MathHelper::Identity4x4();}
\DoxyCodeLine{00032 }
\DoxyCodeLine{00033     \textcolor{comment}{// Dirty flag indicating the object data has changed and we need to update the constant buffer.}}
\DoxyCodeLine{00034     \textcolor{comment}{// Because we have an object cbuffer for each FrameResource, we have to apply the}}
\DoxyCodeLine{00035     \textcolor{comment}{// update to each FrameResource.  Thus, when we modify object data, we should set }}
\DoxyCodeLine{00036     \textcolor{comment}{// NumFramesDirty = gNumFrameResources so that each frame resource gets the update.}}
\DoxyCodeLine{00037     \textcolor{keywordtype}{int} NumFramesDirty = gNumFrameResources;}
\DoxyCodeLine{00038 }
\DoxyCodeLine{00039     \textcolor{comment}{// Index into GPU constant buffer corresponding to the ObjectCB for this render item.}}
\DoxyCodeLine{00040     UINT ObjCBIndex = -\/1;}
\DoxyCodeLine{00041 }
\DoxyCodeLine{00042     \textcolor{comment}{// Geometry associated with this render-\/item. Note that multiple}}
\DoxyCodeLine{00043     \textcolor{comment}{// render-\/items can share the same geometry.}}
\DoxyCodeLine{00044     MeshGeometry* Geo = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00045 }
\DoxyCodeLine{00046     \textcolor{comment}{// Primitive topology.}}
\DoxyCodeLine{00047     D3D12\_PRIMITIVE\_TOPOLOGY PrimitiveType = D3D\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST;}
\DoxyCodeLine{00048 }
\DoxyCodeLine{00049     \textcolor{comment}{// DrawIndexedInstanced parameters.}}
\DoxyCodeLine{00050     UINT IndexCount = 0; \textcolor{comment}{//Number of indices read from the index buffer for each instance.}}
\DoxyCodeLine{00051     UINT StartIndexLocation = 0; \textcolor{comment}{//The location of the first index read by the GPU from the index buffer.}}
\DoxyCodeLine{00052     \textcolor{keywordtype}{int} BaseVertexLocation = 0; \textcolor{comment}{//A value added to each index before reading a vertex from the vertex buffer.}}
\DoxyCodeLine{00053 \};}
\DoxyCodeLine{00054 }
\DoxyCodeLine{00055 \textcolor{keyword}{class }LandApp : \textcolor{keyword}{public} D3DApp}
\DoxyCodeLine{00056 \{}
\DoxyCodeLine{00057 \textcolor{keyword}{public}:}
\DoxyCodeLine{00058     LandApp(HINSTANCE hInstance);}
\DoxyCodeLine{00059     LandApp(\textcolor{keyword}{const} LandApp\& rhs) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00060     LandApp\& operator=(\textcolor{keyword}{const} LandApp\& rhs) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00061     \string~LandApp();}
\DoxyCodeLine{00062 }
\DoxyCodeLine{00063     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} Initialize()\textcolor{keyword}{override};}
\DoxyCodeLine{00064 }
\DoxyCodeLine{00065 \textcolor{keyword}{private}:}
\DoxyCodeLine{00066     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnResize()\textcolor{keyword}{override};}
\DoxyCodeLine{00067     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Update(\textcolor{keyword}{const} GameTimer\& gt)\textcolor{keyword}{override};}
\DoxyCodeLine{00068     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Draw(\textcolor{keyword}{const} GameTimer\& gt)\textcolor{keyword}{override};}
\DoxyCodeLine{00069 }
\DoxyCodeLine{00070     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnMouseDown(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)\textcolor{keyword}{override};}
\DoxyCodeLine{00071     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnMouseUp(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)\textcolor{keyword}{override};}
\DoxyCodeLine{00072     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnMouseMove(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)\textcolor{keyword}{override};}
\DoxyCodeLine{00073 }
\DoxyCodeLine{00074     \textcolor{keywordtype}{void} OnKeyboardInput(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00075     \textcolor{keywordtype}{void} UpdateCamera(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00076     \textcolor{keywordtype}{void} UpdateObjectCBs(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00077     \textcolor{keywordtype}{void} UpdateMainPassCB(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00078 }
\DoxyCodeLine{00079     \textcolor{keywordtype}{void} BuildDescriptorHeaps();}
\DoxyCodeLine{00080     \textcolor{keywordtype}{void} BuildConstantBufferViews();}
\DoxyCodeLine{00081     \textcolor{keywordtype}{void} BuildRootSignature();}
\DoxyCodeLine{00082     \textcolor{keywordtype}{void} BuildShadersAndInputLayout();}
\DoxyCodeLine{00083     \textcolor{keywordtype}{void} BuildLandGeometry();}
\DoxyCodeLine{00084     \textcolor{keywordtype}{void} BuildPSOs();}
\DoxyCodeLine{00085 }
\DoxyCodeLine{00086 }
\DoxyCodeLine{00087     \textcolor{keywordtype}{void} BuildFrameResources();}
\DoxyCodeLine{00088 }
\DoxyCodeLine{00089     \textcolor{keywordtype}{void} BuildRenderItems();}
\DoxyCodeLine{00090     \textcolor{keywordtype}{void} DrawRenderItems(ID3D12GraphicsCommandList* cmdList, \textcolor{keyword}{const} std::vector<RenderItem*>\& ritems);}
\DoxyCodeLine{00091     \textcolor{comment}{//step5}}
\DoxyCodeLine{00092     \textcolor{keywordtype}{float} GetHillsHeight(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} z)\textcolor{keyword}{const};}
\DoxyCodeLine{00093 }
\DoxyCodeLine{00094 \textcolor{keyword}{private}:}
\DoxyCodeLine{00095 }
\DoxyCodeLine{00096     \textcolor{comment}{//step4: keep member variables to track the current frame resource :}}
\DoxyCodeLine{00097     std::vector<std::unique\_ptr<FrameResource>> mFrameResources;}
\DoxyCodeLine{00098     FrameResource* mCurrFrameResource = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00099     \textcolor{keywordtype}{int} mCurrFrameResourceIndex = 0;}
\DoxyCodeLine{00100 }
\DoxyCodeLine{00101     ComPtr<ID3D12RootSignature> mRootSignature = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00102     ComPtr<ID3D12DescriptorHeap> mCbvHeap = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00103 }
\DoxyCodeLine{00104     ComPtr<ID3D12DescriptorHeap> mSrvDescriptorHeap = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00105 }
\DoxyCodeLine{00106     std::unordered\_map<std::string, std::unique\_ptr<MeshGeometry>> mGeometries;}
\DoxyCodeLine{00107     std::unordered\_map<std::string, ComPtr<ID3DBlob>> mShaders;}
\DoxyCodeLine{00108     std::unordered\_map<std::string, ComPtr<ID3D12PipelineState>> mPSOs;}
\DoxyCodeLine{00109 }
\DoxyCodeLine{00110     std::vector<D3D12\_INPUT\_ELEMENT\_DESC> mInputLayout;}
\DoxyCodeLine{00111 }
\DoxyCodeLine{00112     \textcolor{comment}{// List of all the render items.}}
\DoxyCodeLine{00113     std::vector<std::unique\_ptr<RenderItem>> mAllRitems;}
\DoxyCodeLine{00114 }
\DoxyCodeLine{00115     \textcolor{comment}{//step11: Our application will maintain lists of render items based on how they need to be}}
\DoxyCodeLine{00116     \textcolor{comment}{//drawn; that is, render items that need different PSOs will be kept in different lists.}}
\DoxyCodeLine{00117 }
\DoxyCodeLine{00118     \textcolor{comment}{// Render items divided by PSO.}}
\DoxyCodeLine{00119     std::vector<RenderItem*> mOpaqueRitems;}
\DoxyCodeLine{00120 }
\DoxyCodeLine{00121     \textcolor{comment}{//std::vector<RenderItem*> mTransparentRitems;  //we could have render items for transparant items}}
\DoxyCodeLine{00122 }
\DoxyCodeLine{00123 }
\DoxyCodeLine{00124 }
\DoxyCodeLine{00125     \textcolor{comment}{//step12: this mMainPassCB stores constant data that is fixed over a given}}
\DoxyCodeLine{00126     \textcolor{comment}{//rendering pass such as the eye position, the view and projection matrices, and information}}
\DoxyCodeLine{00127     \textcolor{comment}{//about the screen(render target) dimensions; it also includes game timing information,}}
\DoxyCodeLine{00128     \textcolor{comment}{//which is useful data to have access to in shader programs.}}
\DoxyCodeLine{00129 }
\DoxyCodeLine{00130     PassConstants mMainPassCB;}
\DoxyCodeLine{00131 }
\DoxyCodeLine{00132     UINT mPassCbvOffset = 0;}
\DoxyCodeLine{00133 }
\DoxyCodeLine{00134     \textcolor{keywordtype}{bool} mIsWireframe = \textcolor{keyword}{false};}
\DoxyCodeLine{00135 }
\DoxyCodeLine{00136     XMFLOAT3 mEyePos = \{ 0.0f, 0.0f, 0.0f \};}
\DoxyCodeLine{00137     XMFLOAT4X4 mView = MathHelper::Identity4x4();}
\DoxyCodeLine{00138     XMFLOAT4X4 mProj = MathHelper::Identity4x4();}
\DoxyCodeLine{00139 }
\DoxyCodeLine{00140     \textcolor{comment}{//step 2}}
\DoxyCodeLine{00141     \textcolor{comment}{//float mTheta = 1.5f * XM\_PI;}}
\DoxyCodeLine{00142     \textcolor{comment}{//float mPhi = 0.2f * XM\_PI;}}
\DoxyCodeLine{00143     \textcolor{comment}{//float mRadius = 15.0f;}}
\DoxyCodeLine{00144 }
\DoxyCodeLine{00145     \textcolor{keywordtype}{float} mTheta = 1.5f * XM\_PI;}
\DoxyCodeLine{00146     \textcolor{keywordtype}{float} mPhi = XM\_PIDIV2 -\/ 0.1f;}
\DoxyCodeLine{00147     \textcolor{keywordtype}{float} mRadius = 50.0f;}
\DoxyCodeLine{00148 }
\DoxyCodeLine{00149     POINT mLastMousePos;}
\DoxyCodeLine{00150 \};}
\DoxyCodeLine{00151 }
\DoxyCodeLine{00152 \textcolor{keywordtype}{int} WINAPI WinMain(HINSTANCE hInstance, HINSTANCE prevInstance,}
\DoxyCodeLine{00153     PSTR cmdLine, \textcolor{keywordtype}{int} showCmd)}
\DoxyCodeLine{00154 \{}
\DoxyCodeLine{00155     \textcolor{comment}{// Enable run-\/time memory check for debug builds.}}
\DoxyCodeLine{00156 \textcolor{preprocessor}{\#if defined(DEBUG) | defined(\_DEBUG)}}
\DoxyCodeLine{00157     \_CrtSetDbgFlag(\_CRTDBG\_ALLOC\_MEM\_DF | \_CRTDBG\_LEAK\_CHECK\_DF);}
\DoxyCodeLine{00158 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00159 }
\DoxyCodeLine{00160     \textcolor{keywordflow}{try}}
\DoxyCodeLine{00161     \{}
\DoxyCodeLine{00162         LandApp theApp(hInstance);}
\DoxyCodeLine{00163         \textcolor{keywordflow}{if} (!theApp.Initialize())}
\DoxyCodeLine{00164             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00165 }
\DoxyCodeLine{00166         \textcolor{keywordflow}{return} theApp.Run();}
\DoxyCodeLine{00167     \}}
\DoxyCodeLine{00168     \textcolor{keywordflow}{catch} (DxException\& e)}
\DoxyCodeLine{00169     \{}
\DoxyCodeLine{00170         MessageBox(\textcolor{keyword}{nullptr}, e.ToString().c\_str(), L\textcolor{stringliteral}{"{}HR Failed"{}}, MB\_OK);}
\DoxyCodeLine{00171         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00172     \}}
\DoxyCodeLine{00173 \}}
\DoxyCodeLine{00174 }
\DoxyCodeLine{00175 LandApp::LandApp(HINSTANCE hInstance)}
\DoxyCodeLine{00176     : D3DApp(hInstance)}
\DoxyCodeLine{00177 \{}
\DoxyCodeLine{00178 \}}
\DoxyCodeLine{00179 }
\DoxyCodeLine{00180 LandApp::\string~LandApp()}
\DoxyCodeLine{00181 \{}
\DoxyCodeLine{00182     \textcolor{keywordflow}{if} (md3dDevice != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00183         FlushCommandQueue();}
\DoxyCodeLine{00184 \}}
\DoxyCodeLine{00185 }
\DoxyCodeLine{00186 \textcolor{keywordtype}{bool} LandApp::Initialize()}
\DoxyCodeLine{00187 \{}
\DoxyCodeLine{00188     \textcolor{keywordflow}{if} (!D3DApp::Initialize())}
\DoxyCodeLine{00189         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{00190 }
\DoxyCodeLine{00191     \textcolor{comment}{// Reset the command list to prep for initialization commands.}}
\DoxyCodeLine{00192     ThrowIfFailed(mCommandList-\/>Reset(mDirectCmdListAlloc.Get(), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{00193 }
\DoxyCodeLine{00194     BuildRootSignature();}
\DoxyCodeLine{00195     BuildShadersAndInputLayout();}
\DoxyCodeLine{00196     BuildLandGeometry();}
\DoxyCodeLine{00197     BuildRenderItems();}
\DoxyCodeLine{00198     BuildFrameResources();}
\DoxyCodeLine{00199     BuildDescriptorHeaps();}
\DoxyCodeLine{00200     BuildConstantBufferViews();}
\DoxyCodeLine{00201     BuildPSOs();}
\DoxyCodeLine{00202 }
\DoxyCodeLine{00203     \textcolor{comment}{// Execute the initialization commands.}}
\DoxyCodeLine{00204     ThrowIfFailed(mCommandList-\/>Close());}
\DoxyCodeLine{00205     ID3D12CommandList* cmdsLists[] = \{ mCommandList.Get() \};}
\DoxyCodeLine{00206     mCommandQueue-\/>ExecuteCommandLists(\_countof(cmdsLists), cmdsLists);}
\DoxyCodeLine{00207 }
\DoxyCodeLine{00208     \textcolor{comment}{// Wait until initialization is complete.}}
\DoxyCodeLine{00209     FlushCommandQueue();}
\DoxyCodeLine{00210 }
\DoxyCodeLine{00211     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00212 \}}
\DoxyCodeLine{00213 }
\DoxyCodeLine{00214 \textcolor{keywordtype}{void} LandApp::OnResize()}
\DoxyCodeLine{00215 \{}
\DoxyCodeLine{00216     D3DApp::OnResize();}
\DoxyCodeLine{00217 }
\DoxyCodeLine{00218     \textcolor{comment}{// The window resized, so update the aspect ratio and recompute the projection matrix.}}
\DoxyCodeLine{00219     XMMATRIX P = XMMatrixPerspectiveFovLH(0.25f * MathHelper::Pi, AspectRatio(), 1.0f, 1000.0f);}
\DoxyCodeLine{00220     XMStoreFloat4x4(\&mProj, P);}
\DoxyCodeLine{00221 \}}
\DoxyCodeLine{00222 }
\DoxyCodeLine{00223 \textcolor{comment}{//step7: for CPU frame n, the algorithm}}
\DoxyCodeLine{00224 \textcolor{comment}{//1. Cycle through the circular frame resource array.}}
\DoxyCodeLine{00225 \textcolor{comment}{//2. Wait until the GPU has completed commands up to this fence point.}}
\DoxyCodeLine{00226 \textcolor{comment}{//3. Update resources in mCurrFrameResource (like cbuffers).}}
\DoxyCodeLine{00227 }
\DoxyCodeLine{00228 \textcolor{keywordtype}{void} LandApp::Update(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00229 \{}
\DoxyCodeLine{00230     OnKeyboardInput(gt);}
\DoxyCodeLine{00231     UpdateCamera(gt);}
\DoxyCodeLine{00232 }
\DoxyCodeLine{00233     \textcolor{comment}{// Cycle through the circular frame resource array.}}
\DoxyCodeLine{00234     mCurrFrameResourceIndex = (mCurrFrameResourceIndex + 1) \% gNumFrameResources;}
\DoxyCodeLine{00235     mCurrFrameResource = mFrameResources[mCurrFrameResourceIndex].get();}
\DoxyCodeLine{00236 }
\DoxyCodeLine{00237     \textcolor{comment}{//this section is really what D3DApp::FlushCommandQueue() used to do for us at the end of each draw() function!}}
\DoxyCodeLine{00238     \textcolor{keywordflow}{if} (mCurrFrameResource-\/>Fence != 0 \&\& mFence-\/>GetCompletedValue() < mCurrFrameResource-\/>Fence)}
\DoxyCodeLine{00239     \{}
\DoxyCodeLine{00240         HANDLE eventHandle = CreateEventEx(\textcolor{keyword}{nullptr}, \textcolor{keyword}{nullptr}, \textcolor{keyword}{false}, EVENT\_ALL\_ACCESS);}
\DoxyCodeLine{00241         ThrowIfFailed(mFence-\/>SetEventOnCompletion(mCurrFrameResource-\/>Fence, eventHandle));}
\DoxyCodeLine{00242         WaitForSingleObject(eventHandle, INFINITE);}
\DoxyCodeLine{00243         CloseHandle(eventHandle);}
\DoxyCodeLine{00244     \}}
\DoxyCodeLine{00245 }
\DoxyCodeLine{00246     \textcolor{comment}{//The idea of these changes is to group constants based on update frequency. The per}}
\DoxyCodeLine{00247     \textcolor{comment}{//pass constants only need to be updated once per rendering pass, and the object constants}}
\DoxyCodeLine{00248     \textcolor{comment}{//only need to change when an object’s world matrix changes.}}
\DoxyCodeLine{00249     UpdateObjectCBs(gt);}
\DoxyCodeLine{00250     UpdateMainPassCB(gt);}
\DoxyCodeLine{00251 \}}
\DoxyCodeLine{00252 }
\DoxyCodeLine{00253 \textcolor{keywordtype}{void} LandApp::Draw(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00254 \{}
\DoxyCodeLine{00255     \textcolor{keyword}{auto} cmdListAlloc = mCurrFrameResource-\/>CmdListAlloc;}
\DoxyCodeLine{00256 }
\DoxyCodeLine{00257     \textcolor{comment}{// Reuse the memory associated with command recording.}}
\DoxyCodeLine{00258     \textcolor{comment}{// We can only reset when the associated command lists have finished execution on the GPU.}}
\DoxyCodeLine{00259     ThrowIfFailed(cmdListAlloc-\/>Reset());}
\DoxyCodeLine{00260 }
\DoxyCodeLine{00261     \textcolor{comment}{// A command list can be reset after it has been added to the command queue via ExecuteCommandList.}}
\DoxyCodeLine{00262     \textcolor{comment}{// Reusing the command list reuses memory.}}
\DoxyCodeLine{00263     \textcolor{keywordflow}{if} (mIsWireframe)}
\DoxyCodeLine{00264     \{}
\DoxyCodeLine{00265         ThrowIfFailed(mCommandList-\/>Reset(cmdListAlloc.Get(), mPSOs[\textcolor{stringliteral}{"{}opaque\_wireframe"{}}].Get()));}
\DoxyCodeLine{00266     \}}
\DoxyCodeLine{00267     \textcolor{keywordflow}{else}}
\DoxyCodeLine{00268     \{}
\DoxyCodeLine{00269         ThrowIfFailed(mCommandList-\/>Reset(cmdListAlloc.Get(), mPSOs[\textcolor{stringliteral}{"{}opaque"{}}].Get()));}
\DoxyCodeLine{00270     \}}
\DoxyCodeLine{00271 }
\DoxyCodeLine{00272     mCommandList-\/>RSSetViewports(1, \&mScreenViewport);}
\DoxyCodeLine{00273     mCommandList-\/>RSSetScissorRects(1, \&mScissorRect);}
\DoxyCodeLine{00274 }
\DoxyCodeLine{00275     \textcolor{comment}{// Indicate a state transition on the resource usage.}}
\DoxyCodeLine{00276     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(CurrentBackBuffer(),}
\DoxyCodeLine{00277         D3D12\_RESOURCE\_STATE\_PRESENT, D3D12\_RESOURCE\_STATE\_RENDER\_TARGET));}
\DoxyCodeLine{00278 }
\DoxyCodeLine{00279     \textcolor{comment}{// Clear the back buffer and depth buffer.}}
\DoxyCodeLine{00280     mCommandList-\/>ClearRenderTargetView(CurrentBackBufferView(), Colors::LightSteelBlue, 0, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00281     mCommandList-\/>ClearDepthStencilView(DepthStencilView(), D3D12\_CLEAR\_FLAG\_DEPTH | D3D12\_CLEAR\_FLAG\_STENCIL, 1.0f, 0, 0, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00282 }
\DoxyCodeLine{00283     \textcolor{comment}{// Specify the buffers we are going to render to.}}
\DoxyCodeLine{00284     mCommandList-\/>OMSetRenderTargets(1, \&CurrentBackBufferView(), \textcolor{keyword}{true}, \&DepthStencilView());}
\DoxyCodeLine{00285 }
\DoxyCodeLine{00286     ID3D12DescriptorHeap* descriptorHeaps[] = \{ mCbvHeap.Get() \};}
\DoxyCodeLine{00287     mCommandList-\/>SetDescriptorHeaps(\_countof(descriptorHeaps), descriptorHeaps);}
\DoxyCodeLine{00288 }
\DoxyCodeLine{00289     mCommandList-\/>SetGraphicsRootSignature(mRootSignature.Get());}
\DoxyCodeLine{00290 }
\DoxyCodeLine{00291     \textcolor{keywordtype}{int} passCbvIndex = mPassCbvOffset + mCurrFrameResourceIndex;}
\DoxyCodeLine{00292     \textcolor{keyword}{auto} passCbvHandle = CD3DX12\_GPU\_DESCRIPTOR\_HANDLE(mCbvHeap-\/>GetGPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00293     passCbvHandle.Offset(passCbvIndex, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{00294     mCommandList-\/>SetGraphicsRootDescriptorTable(1, passCbvHandle);}
\DoxyCodeLine{00295 }
\DoxyCodeLine{00296     DrawRenderItems(mCommandList.Get(), mOpaqueRitems);}
\DoxyCodeLine{00297 }
\DoxyCodeLine{00298     \textcolor{comment}{// Indicate a state transition on the resource usage.}}
\DoxyCodeLine{00299     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(CurrentBackBuffer(),}
\DoxyCodeLine{00300         D3D12\_RESOURCE\_STATE\_RENDER\_TARGET, D3D12\_RESOURCE\_STATE\_PRESENT));}
\DoxyCodeLine{00301 }
\DoxyCodeLine{00302     \textcolor{comment}{// Done recording commands.}}
\DoxyCodeLine{00303     ThrowIfFailed(mCommandList-\/>Close());}
\DoxyCodeLine{00304 }
\DoxyCodeLine{00305     \textcolor{comment}{// Add the command list to the queue for execution.}}
\DoxyCodeLine{00306     ID3D12CommandList* cmdsLists[] = \{ mCommandList.Get() \};}
\DoxyCodeLine{00307     mCommandQueue-\/>ExecuteCommandLists(\_countof(cmdsLists), cmdsLists);}
\DoxyCodeLine{00308 }
\DoxyCodeLine{00309     \textcolor{comment}{// Swap the back and front buffers}}
\DoxyCodeLine{00310     ThrowIfFailed(mSwapChain-\/>Present(0, 0));}
\DoxyCodeLine{00311     mCurrBackBuffer = (mCurrBackBuffer + 1) \% SwapChainBufferCount;}
\DoxyCodeLine{00312 }
\DoxyCodeLine{00313 }
\DoxyCodeLine{00314     \textcolor{comment}{//Step1:  we have been calling D3DApp::FlushCommandQueue at the end of every}}
\DoxyCodeLine{00315     \textcolor{comment}{//frame to ensure the GPU has finished executing all the commands for the frame.This solution works but is inefficient}}
\DoxyCodeLine{00316     \textcolor{comment}{//For every frame, the CPU and GPU are idling at some point.}}
\DoxyCodeLine{00317     \textcolor{comment}{//  FlushCommandQueue();}}
\DoxyCodeLine{00318 }
\DoxyCodeLine{00319     \textcolor{comment}{//step9:  Advance the fence value to mark commands up to this fence point.}}
\DoxyCodeLine{00320     mCurrFrameResource-\/>Fence = ++mCurrentFence;}
\DoxyCodeLine{00321 }
\DoxyCodeLine{00322     \textcolor{comment}{// Add an instruction to the command queue to set a new fence point. }}
\DoxyCodeLine{00323     \textcolor{comment}{// Because we are on the GPU timeline, the new fence point won't be }}
\DoxyCodeLine{00324     \textcolor{comment}{// set until the GPU finishes processing all the commands prior to this Signal().}}
\DoxyCodeLine{00325     mCommandQueue-\/>Signal(mFence.Get(), mCurrentFence);}
\DoxyCodeLine{00326 }
\DoxyCodeLine{00327     \textcolor{comment}{// Note that GPU could still be working on commands from previous}}
\DoxyCodeLine{00328         \textcolor{comment}{// frames, but that is okay, because we are not touching any frame}}
\DoxyCodeLine{00329         \textcolor{comment}{// resources associated with those frames.}}
\DoxyCodeLine{00330 }
\DoxyCodeLine{00331 \}}
\DoxyCodeLine{00332 }
\DoxyCodeLine{00333 \textcolor{keywordtype}{void} LandApp::OnMouseDown(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)}
\DoxyCodeLine{00334 \{}
\DoxyCodeLine{00335     mLastMousePos.x = x;}
\DoxyCodeLine{00336     mLastMousePos.y = y;}
\DoxyCodeLine{00337 }
\DoxyCodeLine{00338     SetCapture(mhMainWnd);}
\DoxyCodeLine{00339 \}}
\DoxyCodeLine{00340 }
\DoxyCodeLine{00341 \textcolor{keywordtype}{void} LandApp::OnMouseUp(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)}
\DoxyCodeLine{00342 \{}
\DoxyCodeLine{00343     ReleaseCapture();}
\DoxyCodeLine{00344 \}}
\DoxyCodeLine{00345 }
\DoxyCodeLine{00346 \textcolor{keywordtype}{void} LandApp::OnMouseMove(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)}
\DoxyCodeLine{00347 \{}
\DoxyCodeLine{00348     \textcolor{keywordflow}{if} ((btnState \& MK\_LBUTTON) != 0)}
\DoxyCodeLine{00349     \{}
\DoxyCodeLine{00350         \textcolor{comment}{// Make each pixel correspond to a quarter of a degree.}}
\DoxyCodeLine{00351         \textcolor{keywordtype}{float} dx = XMConvertToRadians(0.25f * \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x -\/ mLastMousePos.x));}
\DoxyCodeLine{00352         \textcolor{keywordtype}{float} dy = XMConvertToRadians(0.25f * \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(y -\/ mLastMousePos.y));}
\DoxyCodeLine{00353 }
\DoxyCodeLine{00354         \textcolor{comment}{// Update angles based on input to orbit camera around box.}}
\DoxyCodeLine{00355         mTheta += dx;}
\DoxyCodeLine{00356         mPhi += dy;}
\DoxyCodeLine{00357 }
\DoxyCodeLine{00358         \textcolor{comment}{// Restrict the angle mPhi.}}
\DoxyCodeLine{00359         mPhi = MathHelper::Clamp(mPhi, 0.1f, MathHelper::Pi -\/ 0.1f);}
\DoxyCodeLine{00360     \}}
\DoxyCodeLine{00361     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((btnState \& MK\_RBUTTON) != 0)}
\DoxyCodeLine{00362     \{}
\DoxyCodeLine{00363         \textcolor{comment}{// Make each pixel correspond to 0.2 unit in the scene.}}
\DoxyCodeLine{00364         \textcolor{keywordtype}{float} dx = 0.05f * \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x -\/ mLastMousePos.x);}
\DoxyCodeLine{00365         \textcolor{keywordtype}{float} dy = 0.05f * \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(y -\/ mLastMousePos.y);}
\DoxyCodeLine{00366 }
\DoxyCodeLine{00367         \textcolor{comment}{// Update the camera radius based on input.}}
\DoxyCodeLine{00368         mRadius += dx -\/ dy;}
\DoxyCodeLine{00369 }
\DoxyCodeLine{00370         \textcolor{comment}{// Restrict the radius.}}
\DoxyCodeLine{00371         mRadius = MathHelper::Clamp(mRadius, 5.0f, 150.0f);}
\DoxyCodeLine{00372     \}}
\DoxyCodeLine{00373 }
\DoxyCodeLine{00374     mLastMousePos.x = x;}
\DoxyCodeLine{00375     mLastMousePos.y = y;}
\DoxyCodeLine{00376 \}}
\DoxyCodeLine{00377 }
\DoxyCodeLine{00378 \textcolor{keywordtype}{void} LandApp::OnKeyboardInput(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00379 \{}
\DoxyCodeLine{00380     \textcolor{comment}{//Determines whether a key is up or down at the time the function is called, and whether the key was pressed after a previous call to GetAsyncKeyState.}}
\DoxyCodeLine{00381     \textcolor{comment}{//If the function succeeds, the return value specifies whether the key was pressed since the last call to GetAsyncKeyState, }}
\DoxyCodeLine{00382     \textcolor{comment}{//and whether the key is currently up or down. If the most significant bit is set, the key is down, and if the least significant bit is set, the key was pressed after the previous call to GetAsyncKeyState.}}
\DoxyCodeLine{00383     \textcolor{comment}{//if (GetAsyncKeyState('1') \& 0x8000)}}
\DoxyCodeLine{00384 }
\DoxyCodeLine{00385     \textcolor{keywordtype}{short} key = GetAsyncKeyState(\textcolor{charliteral}{'1'});}
\DoxyCodeLine{00386     \textcolor{keywordflow}{if} (key \& 0x8000)  \textcolor{comment}{//if one is pressed, 0x8000 = 32767 , key = -\/32767 = FFFFFFFFFFFF8001}}
\DoxyCodeLine{00387         mIsWireframe = \textcolor{keyword}{true};}
\DoxyCodeLine{00388     \textcolor{keywordflow}{else}}
\DoxyCodeLine{00389         mIsWireframe = \textcolor{keyword}{false};}
\DoxyCodeLine{00390 \}}
\DoxyCodeLine{00391 }
\DoxyCodeLine{00392 \textcolor{keywordtype}{void} LandApp::UpdateCamera(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00393 \{}
\DoxyCodeLine{00394     \textcolor{comment}{// Convert Spherical to Cartesian coordinates.}}
\DoxyCodeLine{00395     mEyePos.x = mRadius * sinf(mPhi) * cosf(mTheta);}
\DoxyCodeLine{00396     mEyePos.z = mRadius * sinf(mPhi) * sinf(mTheta);}
\DoxyCodeLine{00397     mEyePos.y = mRadius * cosf(mPhi);}
\DoxyCodeLine{00398 }
\DoxyCodeLine{00399     \textcolor{comment}{// Build the view matrix.}}
\DoxyCodeLine{00400     XMVECTOR pos = XMVectorSet(mEyePos.x, mEyePos.y, mEyePos.z, 1.0f);}
\DoxyCodeLine{00401     XMVECTOR target = XMVectorZero();}
\DoxyCodeLine{00402     XMVECTOR up = XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f);}
\DoxyCodeLine{00403 }
\DoxyCodeLine{00404     XMMATRIX view = XMMatrixLookAtLH(pos, target, up);}
\DoxyCodeLine{00405     XMStoreFloat4x4(\&mView, view);}
\DoxyCodeLine{00406 \}}
\DoxyCodeLine{00407 }
\DoxyCodeLine{00408 \textcolor{comment}{//step8: Update resources (cbuffers) in mCurrFrameResource}}
\DoxyCodeLine{00409 \textcolor{keywordtype}{void} LandApp::UpdateObjectCBs(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00410 \{}
\DoxyCodeLine{00411     \textcolor{keyword}{auto} currObjectCB = mCurrFrameResource-\/>ObjectCB.get();}
\DoxyCodeLine{00412     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& e : mAllRitems)}
\DoxyCodeLine{00413     \{}
\DoxyCodeLine{00414         \textcolor{comment}{// Only update the cbuffer data if the constants have changed.  }}
\DoxyCodeLine{00415         \textcolor{comment}{// This needs to be tracked per frame resource.}}
\DoxyCodeLine{00416         \textcolor{keywordflow}{if} (e-\/>NumFramesDirty > 0)}
\DoxyCodeLine{00417         \{}
\DoxyCodeLine{00418             XMMATRIX world = XMLoadFloat4x4(\&e-\/>World);}
\DoxyCodeLine{00419 }
\DoxyCodeLine{00420             ObjectConstants objConstants;}
\DoxyCodeLine{00421             XMStoreFloat4x4(\&objConstants.World, XMMatrixTranspose(world));}
\DoxyCodeLine{00422 }
\DoxyCodeLine{00423             currObjectCB-\/>CopyData(e-\/>ObjCBIndex, objConstants);}
\DoxyCodeLine{00424 }
\DoxyCodeLine{00425             \textcolor{comment}{// Next FrameResource need to be updated too.}}
\DoxyCodeLine{00426             e-\/>NumFramesDirty-\/-\/;}
\DoxyCodeLine{00427         \}}
\DoxyCodeLine{00428     \}}
\DoxyCodeLine{00429 \}}
\DoxyCodeLine{00430 }
\DoxyCodeLine{00431 \textcolor{comment}{//CBVs will be set at different frequencies—the per pass CBV only needs to be set once per}}
\DoxyCodeLine{00432 \textcolor{comment}{//rendering pass while the per object CBV needs to be set per render item}}
\DoxyCodeLine{00433 \textcolor{keywordtype}{void} LandApp::UpdateMainPassCB(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00434 \{}
\DoxyCodeLine{00435     XMMATRIX view = XMLoadFloat4x4(\&mView);}
\DoxyCodeLine{00436     XMMATRIX proj = XMLoadFloat4x4(\&mProj);}
\DoxyCodeLine{00437 }
\DoxyCodeLine{00438     XMMATRIX viewProj = XMMatrixMultiply(view, proj);}
\DoxyCodeLine{00439     XMMATRIX invView = XMMatrixInverse(\&XMMatrixDeterminant(view), view);}
\DoxyCodeLine{00440     XMMATRIX invProj = XMMatrixInverse(\&XMMatrixDeterminant(proj), proj);}
\DoxyCodeLine{00441     XMMATRIX invViewProj = XMMatrixInverse(\&XMMatrixDeterminant(viewProj), viewProj);}
\DoxyCodeLine{00442 }
\DoxyCodeLine{00443     XMStoreFloat4x4(\&mMainPassCB.View, XMMatrixTranspose(view));}
\DoxyCodeLine{00444     XMStoreFloat4x4(\&mMainPassCB.InvView, XMMatrixTranspose(invView));}
\DoxyCodeLine{00445     XMStoreFloat4x4(\&mMainPassCB.Proj, XMMatrixTranspose(proj));}
\DoxyCodeLine{00446     XMStoreFloat4x4(\&mMainPassCB.InvProj, XMMatrixTranspose(invProj));}
\DoxyCodeLine{00447     XMStoreFloat4x4(\&mMainPassCB.ViewProj, XMMatrixTranspose(viewProj));}
\DoxyCodeLine{00448     XMStoreFloat4x4(\&mMainPassCB.InvViewProj, XMMatrixTranspose(invViewProj));}
\DoxyCodeLine{00449     mMainPassCB.EyePosW = mEyePos;}
\DoxyCodeLine{00450     mMainPassCB.RenderTargetSize = XMFLOAT2((\textcolor{keywordtype}{float})mClientWidth, (\textcolor{keywordtype}{float})mClientHeight);}
\DoxyCodeLine{00451     mMainPassCB.InvRenderTargetSize = XMFLOAT2(1.0f / mClientWidth, 1.0f / mClientHeight);}
\DoxyCodeLine{00452     mMainPassCB.NearZ = 1.0f;}
\DoxyCodeLine{00453     mMainPassCB.FarZ = 1000.0f;}
\DoxyCodeLine{00454     mMainPassCB.TotalTime = gt.TotalTime();}
\DoxyCodeLine{00455     mMainPassCB.DeltaTime = gt.DeltaTime();}
\DoxyCodeLine{00456 }
\DoxyCodeLine{00457     \textcolor{keyword}{auto} currPassCB = mCurrFrameResource-\/>PassCB.get();}
\DoxyCodeLine{00458     currPassCB-\/>CopyData(0, mMainPassCB);}
\DoxyCodeLine{00459 \}}
\DoxyCodeLine{00460 }
\DoxyCodeLine{00461 \textcolor{keywordtype}{void} LandApp::BuildDescriptorHeaps()}
\DoxyCodeLine{00462 \{}
\DoxyCodeLine{00463     UINT objCount = (UINT)mOpaqueRitems.size();}
\DoxyCodeLine{00464 }
\DoxyCodeLine{00465     \textcolor{comment}{// Need a CBV descriptor for each object for each frame resource,}}
\DoxyCodeLine{00466     \textcolor{comment}{// +1 for the perPass CBV for each frame resource.}}
\DoxyCodeLine{00467     UINT numDescriptors = (objCount + 1) * gNumFrameResources;}
\DoxyCodeLine{00468 }
\DoxyCodeLine{00469     \textcolor{comment}{// Save an offset to the start of the pass CBVs.  These are the last 3 descriptors.}}
\DoxyCodeLine{00470     mPassCbvOffset = objCount * gNumFrameResources;}
\DoxyCodeLine{00471 }
\DoxyCodeLine{00472     D3D12\_DESCRIPTOR\_HEAP\_DESC cbvHeapDesc;}
\DoxyCodeLine{00473     cbvHeapDesc.NumDescriptors = numDescriptors;}
\DoxyCodeLine{00474     cbvHeapDesc.Type = D3D12\_DESCRIPTOR\_HEAP\_TYPE\_CBV\_SRV\_UAV;}
\DoxyCodeLine{00475     cbvHeapDesc.Flags = D3D12\_DESCRIPTOR\_HEAP\_FLAG\_SHADER\_VISIBLE;}
\DoxyCodeLine{00476     cbvHeapDesc.NodeMask = 0;}
\DoxyCodeLine{00477     ThrowIfFailed(md3dDevice-\/>CreateDescriptorHeap(\&cbvHeapDesc,}
\DoxyCodeLine{00478         IID\_PPV\_ARGS(\&mCbvHeap)));}
\DoxyCodeLine{00479 \}}
\DoxyCodeLine{00480 }
\DoxyCodeLine{00481 \textcolor{keywordtype}{void} LandApp::BuildConstantBufferViews()}
\DoxyCodeLine{00482 \{}
\DoxyCodeLine{00483     UINT objCBByteSize = d3dUtil::CalcConstantBufferByteSize(\textcolor{keyword}{sizeof}(ObjectConstants));}
\DoxyCodeLine{00484 }
\DoxyCodeLine{00485     UINT objCount = (UINT)mOpaqueRitems.size();}
\DoxyCodeLine{00486 }
\DoxyCodeLine{00487     \textcolor{comment}{// Need a CBV descriptor for each object for each frame resource.}}
\DoxyCodeLine{00488     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} frameIndex = 0; frameIndex < gNumFrameResources; ++frameIndex)}
\DoxyCodeLine{00489     \{}
\DoxyCodeLine{00490         \textcolor{keyword}{auto} objectCB = mFrameResources[frameIndex]-\/>ObjectCB-\/>Resource();}
\DoxyCodeLine{00491         \textcolor{keywordflow}{for} (UINT i = 0; i < objCount; ++i)}
\DoxyCodeLine{00492         \{}
\DoxyCodeLine{00493             D3D12\_GPU\_VIRTUAL\_ADDRESS cbAddress = objectCB-\/>GetGPUVirtualAddress();}
\DoxyCodeLine{00494 }
\DoxyCodeLine{00495             \textcolor{comment}{// Offset to the ith object constant buffer in the buffer.}}
\DoxyCodeLine{00496             cbAddress += i * objCBByteSize;}
\DoxyCodeLine{00497 }
\DoxyCodeLine{00498             \textcolor{comment}{// Offset to the object cbv in the descriptor heap.}}
\DoxyCodeLine{00499             \textcolor{keywordtype}{int} heapIndex = frameIndex * objCount + i;}
\DoxyCodeLine{00500             \textcolor{keyword}{auto} handle = CD3DX12\_CPU\_DESCRIPTOR\_HANDLE(mCbvHeap-\/>GetCPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00501             handle.Offset(heapIndex, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{00502 }
\DoxyCodeLine{00503             D3D12\_CONSTANT\_BUFFER\_VIEW\_DESC cbvDesc;}
\DoxyCodeLine{00504             cbvDesc.BufferLocation = cbAddress;}
\DoxyCodeLine{00505             cbvDesc.SizeInBytes = objCBByteSize;}
\DoxyCodeLine{00506 }
\DoxyCodeLine{00507             md3dDevice-\/>CreateConstantBufferView(\&cbvDesc, handle);}
\DoxyCodeLine{00508         \}}
\DoxyCodeLine{00509     \}}
\DoxyCodeLine{00510 }
\DoxyCodeLine{00511     UINT passCBByteSize = d3dUtil::CalcConstantBufferByteSize(\textcolor{keyword}{sizeof}(PassConstants));}
\DoxyCodeLine{00512 }
\DoxyCodeLine{00513     \textcolor{comment}{// Last three descriptors are the pass CBVs for each frame resource.}}
\DoxyCodeLine{00514     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} frameIndex = 0; frameIndex < gNumFrameResources; ++frameIndex)}
\DoxyCodeLine{00515     \{}
\DoxyCodeLine{00516         \textcolor{keyword}{auto} passCB = mFrameResources[frameIndex]-\/>PassCB-\/>Resource();}
\DoxyCodeLine{00517         D3D12\_GPU\_VIRTUAL\_ADDRESS cbAddress = passCB-\/>GetGPUVirtualAddress();}
\DoxyCodeLine{00518 }
\DoxyCodeLine{00519         \textcolor{comment}{// Offset to the pass cbv in the descriptor heap.}}
\DoxyCodeLine{00520         \textcolor{keywordtype}{int} heapIndex = mPassCbvOffset + frameIndex;}
\DoxyCodeLine{00521         \textcolor{keyword}{auto} handle = CD3DX12\_CPU\_DESCRIPTOR\_HANDLE(mCbvHeap-\/>GetCPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00522         handle.Offset(heapIndex, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{00523 }
\DoxyCodeLine{00524         D3D12\_CONSTANT\_BUFFER\_VIEW\_DESC cbvDesc;}
\DoxyCodeLine{00525         cbvDesc.BufferLocation = cbAddress;}
\DoxyCodeLine{00526         cbvDesc.SizeInBytes = passCBByteSize;}
\DoxyCodeLine{00527 }
\DoxyCodeLine{00528         md3dDevice-\/>CreateConstantBufferView(\&cbvDesc, handle);}
\DoxyCodeLine{00529     \}}
\DoxyCodeLine{00530 \}}
\DoxyCodeLine{00531 }
\DoxyCodeLine{00532 \textcolor{keywordtype}{void} LandApp::BuildRootSignature()}
\DoxyCodeLine{00533 \{}
\DoxyCodeLine{00534     \textcolor{comment}{//step 15}}
\DoxyCodeLine{00535     \textcolor{comment}{//The resources that our shaders expect have changed; therefore, we need to update the}}
\DoxyCodeLine{00536     \textcolor{comment}{//root signature accordingly to take two descriptor tables(we need two tables because the}}
\DoxyCodeLine{00537     \textcolor{comment}{//CBVs will be set at different frequencies—the per pass CBV only needs to be set once per}}
\DoxyCodeLine{00538     \textcolor{comment}{//rendering pass while the per object CBV needs to be set per render item) :}}
\DoxyCodeLine{00539 }
\DoxyCodeLine{00540     CD3DX12\_DESCRIPTOR\_RANGE cbvTable0;}
\DoxyCodeLine{00541     cbvTable0.Init(D3D12\_DESCRIPTOR\_RANGE\_TYPE\_CBV, 1, 0);}
\DoxyCodeLine{00542 }
\DoxyCodeLine{00543     CD3DX12\_DESCRIPTOR\_RANGE cbvTable1;}
\DoxyCodeLine{00544     cbvTable1.Init(D3D12\_DESCRIPTOR\_RANGE\_TYPE\_CBV, 1, 1);}
\DoxyCodeLine{00545 }
\DoxyCodeLine{00546     \textcolor{comment}{// Root parameter can be a table, root descriptor or root constants.}}
\DoxyCodeLine{00547     CD3DX12\_ROOT\_PARAMETER slotRootParameter[2];}
\DoxyCodeLine{00548 }
\DoxyCodeLine{00549     \textcolor{comment}{// Create root CBVs.}}
\DoxyCodeLine{00550     slotRootParameter[0].InitAsDescriptorTable(1, \&cbvTable0);}
\DoxyCodeLine{00551     slotRootParameter[1].InitAsDescriptorTable(1, \&cbvTable1);}
\DoxyCodeLine{00552 }
\DoxyCodeLine{00553     \textcolor{comment}{// A root signature is an array of root parameters.}}
\DoxyCodeLine{00554     CD3DX12\_ROOT\_SIGNATURE\_DESC rootSigDesc(2, slotRootParameter, 0, \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00555         D3D12\_ROOT\_SIGNATURE\_FLAG\_ALLOW\_INPUT\_ASSEMBLER\_INPUT\_LAYOUT);}
\DoxyCodeLine{00556 }
\DoxyCodeLine{00557     \textcolor{comment}{// create a root signature with a single slot which points to a descriptor range consisting of a single constant buffer}}
\DoxyCodeLine{00558     ComPtr<ID3DBlob> serializedRootSig = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00559     ComPtr<ID3DBlob> errorBlob = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00560     HRESULT hr = D3D12SerializeRootSignature(\&rootSigDesc, D3D\_ROOT\_SIGNATURE\_VERSION\_1,}
\DoxyCodeLine{00561         serializedRootSig.GetAddressOf(), errorBlob.GetAddressOf());}
\DoxyCodeLine{00562 }
\DoxyCodeLine{00563     \textcolor{keywordflow}{if} (errorBlob != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00564     \{}
\DoxyCodeLine{00565         ::OutputDebugStringA((\textcolor{keywordtype}{char}*)errorBlob-\/>GetBufferPointer());}
\DoxyCodeLine{00566     \}}
\DoxyCodeLine{00567     ThrowIfFailed(hr);}
\DoxyCodeLine{00568 }
\DoxyCodeLine{00569     ThrowIfFailed(md3dDevice-\/>CreateRootSignature(}
\DoxyCodeLine{00570         0,}
\DoxyCodeLine{00571         serializedRootSig-\/>GetBufferPointer(),}
\DoxyCodeLine{00572         serializedRootSig-\/>GetBufferSize(),}
\DoxyCodeLine{00573         IID\_PPV\_ARGS(mRootSignature.GetAddressOf())));}
\DoxyCodeLine{00574 \}}
\DoxyCodeLine{00575 }
\DoxyCodeLine{00576 \textcolor{keywordtype}{void} LandApp::BuildShadersAndInputLayout()}
\DoxyCodeLine{00577 \{}
\DoxyCodeLine{00578     mShaders[\textcolor{stringliteral}{"{}standardVS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)VS.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}VS"{}}, \textcolor{stringliteral}{"{}vs\_5\_1"{}});}
\DoxyCodeLine{00579     mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)PS.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}PS"{}}, \textcolor{stringliteral}{"{}ps\_5\_1"{}});}
\DoxyCodeLine{00580 }
\DoxyCodeLine{00581     mInputLayout =}
\DoxyCodeLine{00582     \{}
\DoxyCodeLine{00583         \{ \textcolor{stringliteral}{"{}POSITION"{}}, 0, DXGI\_FORMAT\_R32G32B32\_FLOAT, 0, 0, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{00584         \{ \textcolor{stringliteral}{"{}COLOR"{}}, 0, DXGI\_FORMAT\_R32G32B32A32\_FLOAT, 0, 12, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{00585     \};}
\DoxyCodeLine{00586 \}}
\DoxyCodeLine{00587 }
\DoxyCodeLine{00588 \textcolor{comment}{//step16}}
\DoxyCodeLine{00589 \textcolor{keywordtype}{void} LandApp::BuildLandGeometry()}
\DoxyCodeLine{00590 \{}
\DoxyCodeLine{00591     \textcolor{comment}{//GeometryGenerator is a utility class for generating simple geometric shapes like grids, grid, grids, and boxes}}
\DoxyCodeLine{00592     GeometryGenerator geoGen;}
\DoxyCodeLine{00593     \textcolor{comment}{//The MeshData structure is a simple structure nested inside GeometryGenerator that stores a vertexand index list}}
\DoxyCodeLine{00594 }
\DoxyCodeLine{00595     \textcolor{comment}{//GeometryGenerator::CreateGrid(float width, float depth, uint32 m, uint32 n)}}
\DoxyCodeLine{00596     GeometryGenerator::MeshData grid = geoGen.CreateGrid(160.0f, 160.0f, 50, 50);}
\DoxyCodeLine{00597 }
\DoxyCodeLine{00598     \textcolor{comment}{//}}
\DoxyCodeLine{00599 \textcolor{comment}{// Extract the vertex elements we are interested and apply the height function to}}
\DoxyCodeLine{00600 \textcolor{comment}{// each vertex.  In addition, color the vertices based on their height so we have}}
\DoxyCodeLine{00601 \textcolor{comment}{// sandy looking beaches, grassy low hills, and snow mountain peaks.}}
\DoxyCodeLine{00602 \textcolor{comment}{//}}
\DoxyCodeLine{00603 }
\DoxyCodeLine{00604     std::vector<Vertex> vertices(grid.Vertices.size());}
\DoxyCodeLine{00605     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < grid.Vertices.size(); ++i)}
\DoxyCodeLine{00606     \{}
\DoxyCodeLine{00607         \textcolor{keyword}{auto}\& p = grid.Vertices[i].Position;}
\DoxyCodeLine{00608         vertices[i].Pos = p;}
\DoxyCodeLine{00609         vertices[i].Pos.y = GetHillsHeight(p.x, p.z);}
\DoxyCodeLine{00610 }
\DoxyCodeLine{00611         \textcolor{comment}{// Color the vertex based on its height.}}
\DoxyCodeLine{00612         \textcolor{keywordflow}{if} (vertices[i].Pos.y < -\/10.0f)}
\DoxyCodeLine{00613         \{}
\DoxyCodeLine{00614             \textcolor{comment}{// Sandy beach color.}}
\DoxyCodeLine{00615             vertices[i].Color = XMFLOAT4(1.0f, 0.96f, 0.62f, 1.0f);}
\DoxyCodeLine{00616         \}}
\DoxyCodeLine{00617         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (vertices[i].Pos.y < 5.0f)}
\DoxyCodeLine{00618         \{}
\DoxyCodeLine{00619             \textcolor{comment}{// Light yellow-\/green.}}
\DoxyCodeLine{00620             vertices[i].Color = XMFLOAT4(0.48f, 0.77f, 0.46f, 1.0f);}
\DoxyCodeLine{00621         \}}
\DoxyCodeLine{00622         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (vertices[i].Pos.y < 12.0f)}
\DoxyCodeLine{00623         \{}
\DoxyCodeLine{00624             \textcolor{comment}{// Dark yellow-\/green.}}
\DoxyCodeLine{00625             vertices[i].Color = XMFLOAT4(0.1f, 0.48f, 0.19f, 1.0f);}
\DoxyCodeLine{00626         \}}
\DoxyCodeLine{00627         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (vertices[i].Pos.y < 20.0f)}
\DoxyCodeLine{00628         \{}
\DoxyCodeLine{00629             \textcolor{comment}{// Dark brown.}}
\DoxyCodeLine{00630             vertices[i].Color = XMFLOAT4(0.45f, 0.39f, 0.34f, 1.0f);}
\DoxyCodeLine{00631         \}}
\DoxyCodeLine{00632         \textcolor{keywordflow}{else}}
\DoxyCodeLine{00633         \{}
\DoxyCodeLine{00634             \textcolor{comment}{// White snow.}}
\DoxyCodeLine{00635             vertices[i].Color = XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f);}
\DoxyCodeLine{00636         \}}
\DoxyCodeLine{00637     \}}
\DoxyCodeLine{00638 }
\DoxyCodeLine{00639 }
\DoxyCodeLine{00640 }
\DoxyCodeLine{00641     \textcolor{comment}{//}}
\DoxyCodeLine{00642     \textcolor{comment}{// We are concatenating all the geometry into one big vertex/index buffer.  So}}
\DoxyCodeLine{00643     \textcolor{comment}{// define the regions in the buffer each submesh covers.}}
\DoxyCodeLine{00644     \textcolor{comment}{//}}
\DoxyCodeLine{00645 }
\DoxyCodeLine{00646     \textcolor{comment}{// Cache the vertex offsets to each object in the concatenated vertex buffer.}}
\DoxyCodeLine{00647     UINT gridVertexOffset = 0;}
\DoxyCodeLine{00648 }
\DoxyCodeLine{00649 }
\DoxyCodeLine{00650     \textcolor{comment}{// Cache the starting index for each object in the concatenated index buffer.}}
\DoxyCodeLine{00651     UINT gridIndexOffset = 0;}
\DoxyCodeLine{00652 }
\DoxyCodeLine{00653 }
\DoxyCodeLine{00654     \textcolor{comment}{// Define the SubmeshGeometry that cover different }}
\DoxyCodeLine{00655     \textcolor{comment}{// regions of the vertex/index buffers.}}
\DoxyCodeLine{00656 }
\DoxyCodeLine{00657     SubmeshGeometry gridSubmesh;}
\DoxyCodeLine{00658     gridSubmesh.IndexCount = (UINT)grid.Indices32.size();}
\DoxyCodeLine{00659     gridSubmesh.StartIndexLocation = gridIndexOffset;}
\DoxyCodeLine{00660     gridSubmesh.BaseVertexLocation = gridVertexOffset;}
\DoxyCodeLine{00661 }
\DoxyCodeLine{00662 }
\DoxyCodeLine{00663     \textcolor{comment}{//}}
\DoxyCodeLine{00664     \textcolor{comment}{// Extract the vertex elements we are interested in and pack the}}
\DoxyCodeLine{00665     \textcolor{comment}{// vertices of all the meshes into one vertex buffer.}}
\DoxyCodeLine{00666     \textcolor{comment}{//}}
\DoxyCodeLine{00667 }
\DoxyCodeLine{00668     \textcolor{comment}{//auto totalVertexCount = grid.Vertices.size();}}
\DoxyCodeLine{00669 }
\DoxyCodeLine{00670 }
\DoxyCodeLine{00671     \textcolor{comment}{//std::vector<Vertex> vertices(totalVertexCount);}}
\DoxyCodeLine{00672 }
\DoxyCodeLine{00673     \textcolor{comment}{//UINT k = 0;}}
\DoxyCodeLine{00674     \textcolor{comment}{//for (size\_t i = 0; i < grid.Vertices.size(); ++i, ++k)}}
\DoxyCodeLine{00675     \textcolor{comment}{//\{}}
\DoxyCodeLine{00676     \textcolor{comment}{//  vertices[k].Pos = grid.Vertices[i].Position;}}
\DoxyCodeLine{00677     \textcolor{comment}{//  vertices[k].Color = XMFLOAT4(DirectX::Colors::DarkOrange);}}
\DoxyCodeLine{00678     \textcolor{comment}{//\}}}
\DoxyCodeLine{00679 }
\DoxyCodeLine{00680 }
\DoxyCodeLine{00681     std::vector<std::uint16\_t> indices;}
\DoxyCodeLine{00682     indices.insert(indices.end(), std::begin(grid.GetIndices16()), std::end(grid.GetIndices16()));}
\DoxyCodeLine{00683 }
\DoxyCodeLine{00684 }
\DoxyCodeLine{00685     \textcolor{keyword}{const} UINT vbByteSize = (UINT)vertices.size() * \textcolor{keyword}{sizeof}(Vertex);}
\DoxyCodeLine{00686     \textcolor{keyword}{const} UINT ibByteSize = (UINT)indices.size() * \textcolor{keyword}{sizeof}(std::uint16\_t);}
\DoxyCodeLine{00687 }
\DoxyCodeLine{00688     \textcolor{keyword}{auto} geo = std::make\_unique<MeshGeometry>();}
\DoxyCodeLine{00689     geo-\/>Name = \textcolor{stringliteral}{"{}landGeo"{}};}
\DoxyCodeLine{00690 }
\DoxyCodeLine{00691     ThrowIfFailed(D3DCreateBlob(vbByteSize, \&geo-\/>VertexBufferCPU));}
\DoxyCodeLine{00692     CopyMemory(geo-\/>VertexBufferCPU-\/>GetBufferPointer(), vertices.data(), vbByteSize);}
\DoxyCodeLine{00693 }
\DoxyCodeLine{00694     ThrowIfFailed(D3DCreateBlob(ibByteSize, \&geo-\/>IndexBufferCPU));}
\DoxyCodeLine{00695     CopyMemory(geo-\/>IndexBufferCPU-\/>GetBufferPointer(), indices.data(), ibByteSize);}
\DoxyCodeLine{00696 }
\DoxyCodeLine{00697     geo-\/>VertexBufferGPU = d3dUtil::CreateDefaultBuffer(md3dDevice.Get(),}
\DoxyCodeLine{00698         mCommandList.Get(), vertices.data(), vbByteSize, geo-\/>VertexBufferUploader);}
\DoxyCodeLine{00699 }
\DoxyCodeLine{00700     geo-\/>IndexBufferGPU = d3dUtil::CreateDefaultBuffer(md3dDevice.Get(),}
\DoxyCodeLine{00701         mCommandList.Get(), indices.data(), ibByteSize, geo-\/>IndexBufferUploader);}
\DoxyCodeLine{00702 }
\DoxyCodeLine{00703     geo-\/>VertexByteStride = \textcolor{keyword}{sizeof}(Vertex);}
\DoxyCodeLine{00704     geo-\/>VertexBufferByteSize = vbByteSize;}
\DoxyCodeLine{00705     geo-\/>IndexFormat = DXGI\_FORMAT\_R16\_UINT;}
\DoxyCodeLine{00706     geo-\/>IndexBufferByteSize = ibByteSize;}
\DoxyCodeLine{00707 }
\DoxyCodeLine{00708     geo-\/>DrawArgs[\textcolor{stringliteral}{"{}grid"{}}] = gridSubmesh;}
\DoxyCodeLine{00709 }
\DoxyCodeLine{00710 }
\DoxyCodeLine{00711     mGeometries[geo-\/>Name] = std::move(geo);}
\DoxyCodeLine{00712 \}}
\DoxyCodeLine{00713 }
\DoxyCodeLine{00714 \textcolor{keywordtype}{void} LandApp::BuildPSOs()}
\DoxyCodeLine{00715 \{}
\DoxyCodeLine{00716     D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC opaquePsoDesc;}
\DoxyCodeLine{00717 }
\DoxyCodeLine{00718     \textcolor{comment}{//}}
\DoxyCodeLine{00719     \textcolor{comment}{// PSO for opaque objects.}}
\DoxyCodeLine{00720     \textcolor{comment}{//}}
\DoxyCodeLine{00721     ZeroMemory(\&opaquePsoDesc, \textcolor{keyword}{sizeof}(D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC));}
\DoxyCodeLine{00722     opaquePsoDesc.InputLayout = \{ mInputLayout.data(), (UINT)mInputLayout.size() \};}
\DoxyCodeLine{00723     opaquePsoDesc.pRootSignature = mRootSignature.Get();}
\DoxyCodeLine{00724     opaquePsoDesc.VS =}
\DoxyCodeLine{00725     \{}
\DoxyCodeLine{00726         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}standardVS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{00727         mShaders[\textcolor{stringliteral}{"{}standardVS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{00728     \};}
\DoxyCodeLine{00729     opaquePsoDesc.PS =}
\DoxyCodeLine{00730     \{}
\DoxyCodeLine{00731         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{00732         mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{00733     \};}
\DoxyCodeLine{00734     opaquePsoDesc.RasterizerState = CD3DX12\_RASTERIZER\_DESC(D3D12\_DEFAULT);}
\DoxyCodeLine{00735     opaquePsoDesc.RasterizerState.FillMode = D3D12\_FILL\_MODE\_SOLID;}
\DoxyCodeLine{00736     opaquePsoDesc.BlendState = CD3DX12\_BLEND\_DESC(D3D12\_DEFAULT);}
\DoxyCodeLine{00737     opaquePsoDesc.DepthStencilState = CD3DX12\_DEPTH\_STENCIL\_DESC(D3D12\_DEFAULT);}
\DoxyCodeLine{00738     opaquePsoDesc.SampleMask = UINT\_MAX;}
\DoxyCodeLine{00739     opaquePsoDesc.PrimitiveTopologyType = D3D12\_PRIMITIVE\_TOPOLOGY\_TYPE\_TRIANGLE;}
\DoxyCodeLine{00740     opaquePsoDesc.NumRenderTargets = 1;}
\DoxyCodeLine{00741     opaquePsoDesc.RTVFormats[0] = mBackBufferFormat;}
\DoxyCodeLine{00742     opaquePsoDesc.SampleDesc.Count = m4xMsaaState ? 4 : 1;}
\DoxyCodeLine{00743     opaquePsoDesc.SampleDesc.Quality = m4xMsaaState ? (m4xMsaaQuality -\/ 1) : 0;}
\DoxyCodeLine{00744     opaquePsoDesc.DSVFormat = mDepthStencilFormat;}
\DoxyCodeLine{00745     ThrowIfFailed(md3dDevice-\/>CreateGraphicsPipelineState(\&opaquePsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}opaque"{}}])));}
\DoxyCodeLine{00746 }
\DoxyCodeLine{00747 }
\DoxyCodeLine{00748     \textcolor{comment}{//}}
\DoxyCodeLine{00749     \textcolor{comment}{// PSO for opaque wireframe objects.}}
\DoxyCodeLine{00750     \textcolor{comment}{//}}
\DoxyCodeLine{00751 }
\DoxyCodeLine{00752     D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC opaqueWireframePsoDesc = opaquePsoDesc;}
\DoxyCodeLine{00753     opaqueWireframePsoDesc.RasterizerState.FillMode = D3D12\_FILL\_MODE\_WIREFRAME;}
\DoxyCodeLine{00754     ThrowIfFailed(md3dDevice-\/>CreateGraphicsPipelineState(\&opaqueWireframePsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}opaque\_wireframe"{}}])));}
\DoxyCodeLine{00755 \}}
\DoxyCodeLine{00756 }
\DoxyCodeLine{00757 \textcolor{comment}{//step6: build three frame resources}}
\DoxyCodeLine{00758 \textcolor{comment}{//FrameResource constructor:     FrameResource(ID3D12Device* device, UINT passCount, UINT objectCount);}}
\DoxyCodeLine{00759 }
\DoxyCodeLine{00760 \textcolor{keywordtype}{void} LandApp::BuildFrameResources()}
\DoxyCodeLine{00761 \{}
\DoxyCodeLine{00762     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < gNumFrameResources; ++i)}
\DoxyCodeLine{00763     \{}
\DoxyCodeLine{00764         mFrameResources.push\_back(std::make\_unique<FrameResource>(md3dDevice.Get(),}
\DoxyCodeLine{00765             1, (UINT)mAllRitems.size()));}
\DoxyCodeLine{00766     \}}
\DoxyCodeLine{00767 \}}
\DoxyCodeLine{00768 }
\DoxyCodeLine{00769 \textcolor{keywordtype}{void} LandApp::BuildRenderItems()}
\DoxyCodeLine{00770 \{}
\DoxyCodeLine{00771     \textcolor{keyword}{auto} gridRitem = std::make\_unique<RenderItem>();}
\DoxyCodeLine{00772     \textcolor{comment}{//step3}}
\DoxyCodeLine{00773     \textcolor{comment}{//XMStoreFloat4x4(\&gridRitem-\/>World, XMMatrixScaling(2.0f, 2.0f, 2.0f) * XMMatrixTranslation(0.0f, 0.5f, 0.0f));}}
\DoxyCodeLine{00774     gridRitem-\/>World = MathHelper::Identity4x4();}
\DoxyCodeLine{00775     gridRitem-\/>ObjCBIndex = 0;}
\DoxyCodeLine{00776     gridRitem-\/>Geo = mGeometries[\textcolor{stringliteral}{"{}landGeo"{}}].get();}
\DoxyCodeLine{00777     gridRitem-\/>PrimitiveType = D3D\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST;}
\DoxyCodeLine{00778     gridRitem-\/>IndexCount = gridRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}grid"{}}].IndexCount;  }
\DoxyCodeLine{00779     gridRitem-\/>StartIndexLocation = gridRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}grid"{}}].StartIndexLocation; }
\DoxyCodeLine{00780     gridRitem-\/>BaseVertexLocation = gridRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}grid"{}}].BaseVertexLocation; }
\DoxyCodeLine{00781     mAllRitems.push\_back(std::move(gridRitem));}
\DoxyCodeLine{00782 }
\DoxyCodeLine{00783 }
\DoxyCodeLine{00784     \textcolor{comment}{// All the render items are opaque.}}
\DoxyCodeLine{00785     \textcolor{comment}{//Our application will maintain lists of render items based on how they need to be}}
\DoxyCodeLine{00786     \textcolor{comment}{//drawn; that is, render items that need different PSOs will be kept in different lists.}}
\DoxyCodeLine{00787     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& e : mAllRitems)}
\DoxyCodeLine{00788         mOpaqueRitems.push\_back(e.get());}
\DoxyCodeLine{00789 \}}
\DoxyCodeLine{00790 }
\DoxyCodeLine{00791 \textcolor{keywordtype}{void} LandApp::DrawRenderItems(ID3D12GraphicsCommandList* cmdList, \textcolor{keyword}{const} std::vector<RenderItem*>\& ritems)}
\DoxyCodeLine{00792 \{}
\DoxyCodeLine{00793     UINT objCBByteSize = d3dUtil::CalcConstantBufferByteSize(\textcolor{keyword}{sizeof}(ObjectConstants));}
\DoxyCodeLine{00794 }
\DoxyCodeLine{00795     \textcolor{keyword}{auto} objectCB = mCurrFrameResource-\/>ObjectCB-\/>Resource();}
\DoxyCodeLine{00796 }
\DoxyCodeLine{00797     \textcolor{comment}{// For each render item...}}
\DoxyCodeLine{00798     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < ritems.size(); ++i)}
\DoxyCodeLine{00799     \{}
\DoxyCodeLine{00800         \textcolor{keyword}{auto} ri = ritems[i];}
\DoxyCodeLine{00801 }
\DoxyCodeLine{00802         cmdList-\/>IASetVertexBuffers(0, 1, \&ri-\/>Geo-\/>VertexBufferView());}
\DoxyCodeLine{00803         cmdList-\/>IASetIndexBuffer(\&ri-\/>Geo-\/>IndexBufferView());}
\DoxyCodeLine{00804         cmdList-\/>IASetPrimitiveTopology(ri-\/>PrimitiveType);}
\DoxyCodeLine{00805 }
\DoxyCodeLine{00806         \textcolor{comment}{// Offset to the CBV in the descriptor heap for this object and for this frame resource.}}
\DoxyCodeLine{00807         UINT cbvIndex = mCurrFrameResourceIndex * (UINT)mOpaqueRitems.size() + ri-\/>ObjCBIndex;}
\DoxyCodeLine{00808         \textcolor{keyword}{auto} cbvHandle = CD3DX12\_GPU\_DESCRIPTOR\_HANDLE(mCbvHeap-\/>GetGPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00809         cbvHandle.Offset(cbvIndex, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{00810 }
\DoxyCodeLine{00811         cmdList-\/>SetGraphicsRootDescriptorTable(0, cbvHandle);}
\DoxyCodeLine{00812 }
\DoxyCodeLine{00813         cmdList-\/>DrawIndexedInstanced(ri-\/>IndexCount, 1, ri-\/>StartIndexLocation, ri-\/>BaseVertexLocation, 0);}
\DoxyCodeLine{00814     \}}
\DoxyCodeLine{00815 \}}
\DoxyCodeLine{00816 }
\DoxyCodeLine{00817 \textcolor{keywordtype}{float} LandApp::GetHillsHeight(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} z)\textcolor{keyword}{const}}
\DoxyCodeLine{00818 \textcolor{keyword}{}\{}
\DoxyCodeLine{00819     \textcolor{keywordflow}{return} 0.3f * (z * sinf(0.1f * x) + x * cosf(0.1f * z));}
\DoxyCodeLine{00820 \}}
\DoxyCodeLine{00821 }
\DoxyCodeLine{00822 }

\end{DoxyCode}
