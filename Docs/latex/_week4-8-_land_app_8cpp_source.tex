\doxysection{Week4-\/8-\/\+Land\+App.cpp}
\label{_week4-8-_land_app_8cpp_source}\index{Week4/Week4/Week4-\/8-\/LandApp.cpp@{Week4/Week4/Week4-\/8-\/LandApp.cpp}}
\textbf{ Go to the documentation of this file.}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001 }
\DoxyCodeLine{00016 \textcolor{preprocessor}{\#include "{}../../Common/d3dApp.h"{}}}
\DoxyCodeLine{00017 \textcolor{preprocessor}{\#include "{}../../Common/MathHelper.h"{}}}
\DoxyCodeLine{00018 \textcolor{preprocessor}{\#include "{}../../Common/UploadBuffer.h"{}}}
\DoxyCodeLine{00019 \textcolor{preprocessor}{\#include "{}../../Common/GeometryGenerator.h"{}}}
\DoxyCodeLine{00020 \textcolor{preprocessor}{\#include "{}FrameResource.h"{}}}
\DoxyCodeLine{00021 }
\DoxyCodeLine{00022 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{00023 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{00024 }
\DoxyCodeLine{00025 \textcolor{keyword}{using} Microsoft::WRL::ComPtr;}
\DoxyCodeLine{00026 \textcolor{keyword}{using namespace }DirectX;}
\DoxyCodeLine{00027 \textcolor{keyword}{using namespace }DirectX::PackedVector;}
\DoxyCodeLine{00028 }
\DoxyCodeLine{00029 \textcolor{comment}{//step3: Our application class will then instantiate a vector of three frame resources, }}
\DoxyCodeLine{00030 \textcolor{keyword}{const} \textcolor{keywordtype}{int} gNumFrameResources = 3;}
\DoxyCodeLine{00031 }
\DoxyCodeLine{00032 \textcolor{comment}{// Step10: Lightweight structure stores parameters to draw a shape.  This will vary from app-\/to-\/app.}}
\DoxyCodeLine{00033 \textcolor{keyword}{struct }RenderItem}
\DoxyCodeLine{00034 \{}
\DoxyCodeLine{00035     RenderItem() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{00036 }
\DoxyCodeLine{00037     \textcolor{comment}{// World matrix of the shape that describes the object's local space}}
\DoxyCodeLine{00038     \textcolor{comment}{// relative to the world space, which defines the position, orientation,}}
\DoxyCodeLine{00039     \textcolor{comment}{// and scale of the object in the world.}}
\DoxyCodeLine{00040     XMFLOAT4X4 World = MathHelper::Identity4x4();}
\DoxyCodeLine{00041 }
\DoxyCodeLine{00042     \textcolor{comment}{// Dirty flag indicating the object data has changed and we need to update the constant buffer.}}
\DoxyCodeLine{00043     \textcolor{comment}{// Because we have an object cbuffer for each FrameResource, we have to apply the}}
\DoxyCodeLine{00044     \textcolor{comment}{// update to each FrameResource.  Thus, when we modify object data, we should set }}
\DoxyCodeLine{00045     \textcolor{comment}{// NumFramesDirty = gNumFrameResources so that each frame resource gets the update.}}
\DoxyCodeLine{00046     \textcolor{keywordtype}{int} NumFramesDirty = gNumFrameResources;}
\DoxyCodeLine{00047 }
\DoxyCodeLine{00048     \textcolor{comment}{// Index into GPU constant buffer corresponding to the ObjectCB for this render item.}}
\DoxyCodeLine{00049     UINT ObjCBIndex = -\/1;}
\DoxyCodeLine{00050 }
\DoxyCodeLine{00051     \textcolor{comment}{// Geometry associated with this render-\/item. Note that multiple}}
\DoxyCodeLine{00052     \textcolor{comment}{// render-\/items can share the same geometry.}}
\DoxyCodeLine{00053     MeshGeometry* Geo = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00054 }
\DoxyCodeLine{00055     \textcolor{comment}{// Primitive topology.}}
\DoxyCodeLine{00056     D3D12\_PRIMITIVE\_TOPOLOGY PrimitiveType = D3D\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST;}
\DoxyCodeLine{00057 }
\DoxyCodeLine{00058     \textcolor{comment}{// DrawIndexedInstanced parameters.}}
\DoxyCodeLine{00059     UINT IndexCount = 0; \textcolor{comment}{//Number of indices read from the index buffer for each instance.}}
\DoxyCodeLine{00060     UINT StartIndexLocation = 0; \textcolor{comment}{//The location of the first index read by the GPU from the index buffer.}}
\DoxyCodeLine{00061     \textcolor{keywordtype}{int} BaseVertexLocation = 0; \textcolor{comment}{//A value added to each index before reading a vertex from the vertex buffer.}}
\DoxyCodeLine{00062 \};}
\DoxyCodeLine{00063 }
\DoxyCodeLine{00064 \textcolor{keyword}{class }LandApp : \textcolor{keyword}{public} D3DApp}
\DoxyCodeLine{00065 \{}
\DoxyCodeLine{00066 \textcolor{keyword}{public}:}
\DoxyCodeLine{00067     LandApp(HINSTANCE hInstance);}
\DoxyCodeLine{00068     LandApp(\textcolor{keyword}{const} LandApp\& rhs) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00069     LandApp\& operator=(\textcolor{keyword}{const} LandApp\& rhs) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00070     \string~LandApp();}
\DoxyCodeLine{00071 }
\DoxyCodeLine{00072     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} Initialize()\textcolor{keyword}{override};}
\DoxyCodeLine{00073 }
\DoxyCodeLine{00074 \textcolor{keyword}{private}:}
\DoxyCodeLine{00075     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnResize()\textcolor{keyword}{override};}
\DoxyCodeLine{00076     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Update(\textcolor{keyword}{const} GameTimer\& gt)\textcolor{keyword}{override};}
\DoxyCodeLine{00077     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Draw(\textcolor{keyword}{const} GameTimer\& gt)\textcolor{keyword}{override};}
\DoxyCodeLine{00078 }
\DoxyCodeLine{00079     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnMouseDown(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)\textcolor{keyword}{override};}
\DoxyCodeLine{00080     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnMouseUp(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)\textcolor{keyword}{override};}
\DoxyCodeLine{00081     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnMouseMove(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)\textcolor{keyword}{override};}
\DoxyCodeLine{00082 }
\DoxyCodeLine{00083     \textcolor{keywordtype}{void} OnKeyboardInput(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00084     \textcolor{keywordtype}{void} UpdateCamera(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00085     \textcolor{keywordtype}{void} UpdateObjectCBs(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00086     \textcolor{keywordtype}{void} UpdateMainPassCB(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00087 }
\DoxyCodeLine{00088     \textcolor{keywordtype}{void} BuildDescriptorHeaps();}
\DoxyCodeLine{00089     \textcolor{keywordtype}{void} BuildConstantBufferViews();}
\DoxyCodeLine{00090     \textcolor{keywordtype}{void} BuildRootSignature();}
\DoxyCodeLine{00091     \textcolor{keywordtype}{void} BuildShadersAndInputLayout();}
\DoxyCodeLine{00092     \textcolor{keywordtype}{void} BuildLandGeometry();}
\DoxyCodeLine{00093     \textcolor{keywordtype}{void} BuildPSOs();}
\DoxyCodeLine{00094 }
\DoxyCodeLine{00095 }
\DoxyCodeLine{00096     \textcolor{keywordtype}{void} BuildFrameResources();}
\DoxyCodeLine{00097 }
\DoxyCodeLine{00098     \textcolor{keywordtype}{void} BuildRenderItems();}
\DoxyCodeLine{00099     \textcolor{keywordtype}{void} DrawRenderItems(ID3D12GraphicsCommandList* cmdList, \textcolor{keyword}{const} std::vector<RenderItem*>\& ritems);}
\DoxyCodeLine{00100     \textcolor{comment}{//step2}}
\DoxyCodeLine{00101     \textcolor{keywordtype}{float} GetHillsHeight(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} z)\textcolor{keyword}{const};}
\DoxyCodeLine{00102 }
\DoxyCodeLine{00103 \textcolor{keyword}{private}:}
\DoxyCodeLine{00104 }
\DoxyCodeLine{00105     \textcolor{comment}{//keep member variables to track the current frame resource :}}
\DoxyCodeLine{00106     std::vector<std::unique\_ptr<FrameResource>> mFrameResources;}
\DoxyCodeLine{00107     FrameResource* mCurrFrameResource = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00108     \textcolor{keywordtype}{int} mCurrFrameResourceIndex = 0;}
\DoxyCodeLine{00109 }
\DoxyCodeLine{00110     ComPtr<ID3D12RootSignature> mRootSignature = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00111     ComPtr<ID3D12DescriptorHeap> mCbvHeap = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00112 }
\DoxyCodeLine{00113     ComPtr<ID3D12DescriptorHeap> mSrvDescriptorHeap = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00114 }
\DoxyCodeLine{00115     std::unordered\_map<std::string, std::unique\_ptr<MeshGeometry>> mGeometries;}
\DoxyCodeLine{00116     std::unordered\_map<std::string, ComPtr<ID3DBlob>> mShaders;}
\DoxyCodeLine{00117     std::unordered\_map<std::string, ComPtr<ID3D12PipelineState>> mPSOs;}
\DoxyCodeLine{00118 }
\DoxyCodeLine{00119     std::vector<D3D12\_INPUT\_ELEMENT\_DESC> mInputLayout;}
\DoxyCodeLine{00120 }
\DoxyCodeLine{00121     \textcolor{comment}{// List of all the render items.}}
\DoxyCodeLine{00122     std::vector<std::unique\_ptr<RenderItem>> mAllRitems;}
\DoxyCodeLine{00123 }
\DoxyCodeLine{00124     \textcolor{comment}{//Our application will maintain lists of render items based on how they need to be}}
\DoxyCodeLine{00125     \textcolor{comment}{//drawn; that is, render items that need different PSOs will be kept in different lists.}}
\DoxyCodeLine{00126 }
\DoxyCodeLine{00127     \textcolor{comment}{// Render items divided by PSO.}}
\DoxyCodeLine{00128     std::vector<RenderItem*> mOpaqueRitems;}
\DoxyCodeLine{00129 }
\DoxyCodeLine{00130     \textcolor{comment}{//std::vector<RenderItem*> mTransparentRitems;  //we could have render items for transparant items}}
\DoxyCodeLine{00131 }
\DoxyCodeLine{00132 }
\DoxyCodeLine{00133 }
\DoxyCodeLine{00134     \textcolor{comment}{//this mMainPassCB stores constant data that is fixed over a given}}
\DoxyCodeLine{00135     \textcolor{comment}{//rendering pass such as the eye position, the view and projection matrices, and information}}
\DoxyCodeLine{00136     \textcolor{comment}{//about the screen(render target) dimensions; it also includes game timing information,}}
\DoxyCodeLine{00137     \textcolor{comment}{//which is useful data to have access to in shader programs.}}
\DoxyCodeLine{00138 }
\DoxyCodeLine{00139     PassConstants mMainPassCB;}
\DoxyCodeLine{00140 }
\DoxyCodeLine{00141     UINT mPassCbvOffset = 0;}
\DoxyCodeLine{00142 }
\DoxyCodeLine{00143     \textcolor{keywordtype}{bool} mIsWireframe = \textcolor{keyword}{false};}
\DoxyCodeLine{00144 }
\DoxyCodeLine{00145     XMFLOAT3 mEyePos = \{ 0.0f, 0.0f, 0.0f \};}
\DoxyCodeLine{00146     XMFLOAT4X4 mView = MathHelper::Identity4x4();}
\DoxyCodeLine{00147     XMFLOAT4X4 mProj = MathHelper::Identity4x4();}
\DoxyCodeLine{00148 }
\DoxyCodeLine{00149     \textcolor{comment}{//step 3}}
\DoxyCodeLine{00150     \textcolor{comment}{//float mTheta = 1.5f * XM\_PI;}}
\DoxyCodeLine{00151     \textcolor{comment}{//float mPhi = 0.2f * XM\_PI;}}
\DoxyCodeLine{00152     \textcolor{comment}{//float mRadius = 15.0f;}}
\DoxyCodeLine{00153 }
\DoxyCodeLine{00154     \textcolor{keywordtype}{float} mTheta = 1.5f * XM\_PI;}
\DoxyCodeLine{00155     \textcolor{keywordtype}{float} mPhi = XM\_PIDIV2 -\/ 0.1f;}
\DoxyCodeLine{00156     \textcolor{keywordtype}{float} mRadius = 50.0f;}
\DoxyCodeLine{00157 }
\DoxyCodeLine{00158     POINT mLastMousePos;}
\DoxyCodeLine{00159 \};}
\DoxyCodeLine{00160 }
\DoxyCodeLine{00161 \textcolor{keywordtype}{int} WINAPI WinMain(HINSTANCE hInstance, HINSTANCE prevInstance,}
\DoxyCodeLine{00162     PSTR cmdLine, \textcolor{keywordtype}{int} showCmd)}
\DoxyCodeLine{00163 \{}
\DoxyCodeLine{00164     \textcolor{comment}{// Enable run-\/time memory check for debug builds.}}
\DoxyCodeLine{00165 \textcolor{preprocessor}{\#if defined(DEBUG) | defined(\_DEBUG)}}
\DoxyCodeLine{00166     \_CrtSetDbgFlag(\_CRTDBG\_ALLOC\_MEM\_DF | \_CRTDBG\_LEAK\_CHECK\_DF);}
\DoxyCodeLine{00167 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00168 }
\DoxyCodeLine{00169     \textcolor{keywordflow}{try}}
\DoxyCodeLine{00170     \{}
\DoxyCodeLine{00171         LandApp theApp(hInstance);}
\DoxyCodeLine{00172         \textcolor{keywordflow}{if} (!theApp.Initialize())}
\DoxyCodeLine{00173             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00174 }
\DoxyCodeLine{00175         \textcolor{keywordflow}{return} theApp.Run();}
\DoxyCodeLine{00176     \}}
\DoxyCodeLine{00177     \textcolor{keywordflow}{catch} (DxException \& e)}
\DoxyCodeLine{00178     \{}
\DoxyCodeLine{00179         MessageBox(\textcolor{keyword}{nullptr}, e.ToString().c\_str(), L\textcolor{stringliteral}{"{}HR Failed"{}}, MB\_OK);}
\DoxyCodeLine{00180         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00181     \}}
\DoxyCodeLine{00182 \}}
\DoxyCodeLine{00183 }
\DoxyCodeLine{00184 LandApp::LandApp(HINSTANCE hInstance)}
\DoxyCodeLine{00185     : D3DApp(hInstance)}
\DoxyCodeLine{00186 \{}
\DoxyCodeLine{00187 \}}
\DoxyCodeLine{00188 }
\DoxyCodeLine{00189 LandApp::\string~LandApp()}
\DoxyCodeLine{00190 \{}
\DoxyCodeLine{00191     \textcolor{keywordflow}{if} (md3dDevice != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00192         FlushCommandQueue();}
\DoxyCodeLine{00193 \}}
\DoxyCodeLine{00194 }
\DoxyCodeLine{00195 \textcolor{keywordtype}{bool} LandApp::Initialize()}
\DoxyCodeLine{00196 \{}
\DoxyCodeLine{00197     \textcolor{keywordflow}{if} (!D3DApp::Initialize())}
\DoxyCodeLine{00198         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{00199 }
\DoxyCodeLine{00200     \textcolor{comment}{// Reset the command list to prep for initialization commands.}}
\DoxyCodeLine{00201     ThrowIfFailed(mCommandList-\/>Reset(mDirectCmdListAlloc.Get(), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{00202 }
\DoxyCodeLine{00203     BuildRootSignature();}
\DoxyCodeLine{00204     BuildShadersAndInputLayout();}
\DoxyCodeLine{00205     BuildLandGeometry();}
\DoxyCodeLine{00206     BuildRenderItems();}
\DoxyCodeLine{00207     BuildFrameResources();}
\DoxyCodeLine{00208     BuildDescriptorHeaps();}
\DoxyCodeLine{00209     BuildConstantBufferViews();}
\DoxyCodeLine{00210     BuildPSOs();}
\DoxyCodeLine{00211 }
\DoxyCodeLine{00212     \textcolor{comment}{// Execute the initialization commands.}}
\DoxyCodeLine{00213     ThrowIfFailed(mCommandList-\/>Close());}
\DoxyCodeLine{00214     ID3D12CommandList* cmdsLists[] = \{ mCommandList.Get() \};}
\DoxyCodeLine{00215     mCommandQueue-\/>ExecuteCommandLists(\_countof(cmdsLists), cmdsLists);}
\DoxyCodeLine{00216 }
\DoxyCodeLine{00217     \textcolor{comment}{// Wait until initialization is complete.}}
\DoxyCodeLine{00218     FlushCommandQueue();}
\DoxyCodeLine{00219 }
\DoxyCodeLine{00220     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00221 \}}
\DoxyCodeLine{00222 }
\DoxyCodeLine{00223 \textcolor{keywordtype}{void} LandApp::OnResize()}
\DoxyCodeLine{00224 \{}
\DoxyCodeLine{00225     D3DApp::OnResize();}
\DoxyCodeLine{00226 }
\DoxyCodeLine{00227     \textcolor{comment}{// The window resized, so update the aspect ratio and recompute the projection matrix.}}
\DoxyCodeLine{00228     XMMATRIX P = XMMatrixPerspectiveFovLH(0.25f * MathHelper::Pi, AspectRatio(), 1.0f, 1000.0f);}
\DoxyCodeLine{00229     XMStoreFloat4x4(\&mProj, P);}
\DoxyCodeLine{00230 \}}
\DoxyCodeLine{00231 }
\DoxyCodeLine{00232 \textcolor{comment}{//for CPU frame n, the algorithm}}
\DoxyCodeLine{00233 \textcolor{comment}{//1. Cycle through the circular frame resource array.}}
\DoxyCodeLine{00234 \textcolor{comment}{//2. Wait until the GPU has completed commands up to this fence point.}}
\DoxyCodeLine{00235 \textcolor{comment}{//3. Update resources in mCurrFrameResource (like cbuffers).}}
\DoxyCodeLine{00236 }
\DoxyCodeLine{00237 \textcolor{keywordtype}{void} LandApp::Update(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00238 \{}
\DoxyCodeLine{00239     OnKeyboardInput(gt);}
\DoxyCodeLine{00240     UpdateCamera(gt);}
\DoxyCodeLine{00241 }
\DoxyCodeLine{00242     \textcolor{comment}{// Cycle through the circular frame resource array.}}
\DoxyCodeLine{00243     mCurrFrameResourceIndex = (mCurrFrameResourceIndex + 1) \% gNumFrameResources;}
\DoxyCodeLine{00244     mCurrFrameResource = mFrameResources[mCurrFrameResourceIndex].get();}
\DoxyCodeLine{00245 }
\DoxyCodeLine{00246     \textcolor{comment}{//this section is really what D3DApp::FlushCommandQueue() used to do for us at the end of each draw() function!}}
\DoxyCodeLine{00247     \textcolor{keywordflow}{if} (mCurrFrameResource-\/>Fence != 0 \&\& mFence-\/>GetCompletedValue() < mCurrFrameResource-\/>Fence)}
\DoxyCodeLine{00248     \{}
\DoxyCodeLine{00249         HANDLE eventHandle = CreateEventEx(\textcolor{keyword}{nullptr}, \textcolor{keyword}{nullptr}, \textcolor{keyword}{false}, EVENT\_ALL\_ACCESS);}
\DoxyCodeLine{00250         ThrowIfFailed(mFence-\/>SetEventOnCompletion(mCurrFrameResource-\/>Fence, eventHandle));}
\DoxyCodeLine{00251         WaitForSingleObject(eventHandle, INFINITE);}
\DoxyCodeLine{00252         CloseHandle(eventHandle);}
\DoxyCodeLine{00253     \}}
\DoxyCodeLine{00254 }
\DoxyCodeLine{00255     \textcolor{comment}{//The idea of these changes is to group constants based on update frequency. The per}}
\DoxyCodeLine{00256     \textcolor{comment}{//pass constants only need to be updated once per rendering pass, and the object constants}}
\DoxyCodeLine{00257     \textcolor{comment}{//only need to change when an object’s world matrix changes.}}
\DoxyCodeLine{00258     UpdateObjectCBs(gt);}
\DoxyCodeLine{00259     UpdateMainPassCB(gt);}
\DoxyCodeLine{00260 \}}
\DoxyCodeLine{00261 }
\DoxyCodeLine{00262 \textcolor{keywordtype}{void} LandApp::Draw(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00263 \{}
\DoxyCodeLine{00264     \textcolor{keyword}{auto} cmdListAlloc = mCurrFrameResource-\/>CmdListAlloc;}
\DoxyCodeLine{00265 }
\DoxyCodeLine{00266     \textcolor{comment}{// Reuse the memory associated with command recording.}}
\DoxyCodeLine{00267     \textcolor{comment}{// We can only reset when the associated command lists have finished execution on the GPU.}}
\DoxyCodeLine{00268     ThrowIfFailed(cmdListAlloc-\/>Reset());}
\DoxyCodeLine{00269 }
\DoxyCodeLine{00270     \textcolor{comment}{// A command list can be reset after it has been added to the command queue via ExecuteCommandList.}}
\DoxyCodeLine{00271     \textcolor{comment}{// Reusing the command list reuses memory.}}
\DoxyCodeLine{00272     \textcolor{keywordflow}{if} (mIsWireframe)}
\DoxyCodeLine{00273     \{}
\DoxyCodeLine{00274         ThrowIfFailed(mCommandList-\/>Reset(cmdListAlloc.Get(), mPSOs[\textcolor{stringliteral}{"{}opaque\_wireframe"{}}].Get()));}
\DoxyCodeLine{00275     \}}
\DoxyCodeLine{00276     \textcolor{keywordflow}{else}}
\DoxyCodeLine{00277     \{}
\DoxyCodeLine{00278         ThrowIfFailed(mCommandList-\/>Reset(cmdListAlloc.Get(), mPSOs[\textcolor{stringliteral}{"{}opaque"{}}].Get()));}
\DoxyCodeLine{00279     \}}
\DoxyCodeLine{00280 }
\DoxyCodeLine{00281     mCommandList-\/>RSSetViewports(1, \&mScreenViewport);}
\DoxyCodeLine{00282     mCommandList-\/>RSSetScissorRects(1, \&mScissorRect);}
\DoxyCodeLine{00283 }
\DoxyCodeLine{00284     \textcolor{comment}{// Indicate a state transition on the resource usage.}}
\DoxyCodeLine{00285     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(CurrentBackBuffer(),}
\DoxyCodeLine{00286         D3D12\_RESOURCE\_STATE\_PRESENT, D3D12\_RESOURCE\_STATE\_RENDER\_TARGET));}
\DoxyCodeLine{00287 }
\DoxyCodeLine{00288     \textcolor{comment}{// Clear the back buffer and depth buffer.}}
\DoxyCodeLine{00289     mCommandList-\/>ClearRenderTargetView(CurrentBackBufferView(), Colors::LightSteelBlue, 0, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00290     mCommandList-\/>ClearDepthStencilView(DepthStencilView(), D3D12\_CLEAR\_FLAG\_DEPTH | D3D12\_CLEAR\_FLAG\_STENCIL, 1.0f, 0, 0, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00291 }
\DoxyCodeLine{00292     \textcolor{comment}{// Specify the buffers we are going to render to.}}
\DoxyCodeLine{00293     mCommandList-\/>OMSetRenderTargets(1, \&CurrentBackBufferView(), \textcolor{keyword}{true}, \&DepthStencilView());}
\DoxyCodeLine{00294 }
\DoxyCodeLine{00295     ID3D12DescriptorHeap* descriptorHeaps[] = \{ mCbvHeap.Get() \};}
\DoxyCodeLine{00296     mCommandList-\/>SetDescriptorHeaps(\_countof(descriptorHeaps), descriptorHeaps);}
\DoxyCodeLine{00297 }
\DoxyCodeLine{00298     mCommandList-\/>SetGraphicsRootSignature(mRootSignature.Get());}
\DoxyCodeLine{00299 }
\DoxyCodeLine{00300     \textcolor{keywordtype}{int} passCbvIndex = mPassCbvOffset + mCurrFrameResourceIndex;}
\DoxyCodeLine{00301     \textcolor{keyword}{auto} passCbvHandle = CD3DX12\_GPU\_DESCRIPTOR\_HANDLE(mCbvHeap-\/>GetGPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00302     passCbvHandle.Offset(passCbvIndex, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{00303     mCommandList-\/>SetGraphicsRootDescriptorTable(1, passCbvHandle);}
\DoxyCodeLine{00304 }
\DoxyCodeLine{00305     DrawRenderItems(mCommandList.Get(), mOpaqueRitems);}
\DoxyCodeLine{00306 }
\DoxyCodeLine{00307     \textcolor{comment}{// Indicate a state transition on the resource usage.}}
\DoxyCodeLine{00308     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(CurrentBackBuffer(),}
\DoxyCodeLine{00309         D3D12\_RESOURCE\_STATE\_RENDER\_TARGET, D3D12\_RESOURCE\_STATE\_PRESENT));}
\DoxyCodeLine{00310 }
\DoxyCodeLine{00311     \textcolor{comment}{// Done recording commands.}}
\DoxyCodeLine{00312     ThrowIfFailed(mCommandList-\/>Close());}
\DoxyCodeLine{00313 }
\DoxyCodeLine{00314     \textcolor{comment}{// Add the command list to the queue for execution.}}
\DoxyCodeLine{00315     ID3D12CommandList* cmdsLists[] = \{ mCommandList.Get() \};}
\DoxyCodeLine{00316     mCommandQueue-\/>ExecuteCommandLists(\_countof(cmdsLists), cmdsLists);}
\DoxyCodeLine{00317 }
\DoxyCodeLine{00318     \textcolor{comment}{// Swap the back and front buffers}}
\DoxyCodeLine{00319     ThrowIfFailed(mSwapChain-\/>Present(0, 0));}
\DoxyCodeLine{00320     mCurrBackBuffer = (mCurrBackBuffer + 1) \% SwapChainBufferCount;}
\DoxyCodeLine{00321 }
\DoxyCodeLine{00322 }
\DoxyCodeLine{00323     \textcolor{comment}{//we have been calling D3DApp::FlushCommandQueue at the end of every}}
\DoxyCodeLine{00324     \textcolor{comment}{//frame to ensure the GPU has finished executing all the commands for the frame.This solution works but is inefficient}}
\DoxyCodeLine{00325     \textcolor{comment}{//For every frame, the CPU and GPU are idling at some point.}}
\DoxyCodeLine{00326     \textcolor{comment}{//  FlushCommandQueue();}}
\DoxyCodeLine{00327 }
\DoxyCodeLine{00328     \textcolor{comment}{//Advance the fence value to mark commands up to this fence point.}}
\DoxyCodeLine{00329     mCurrFrameResource-\/>Fence = ++mCurrentFence;}
\DoxyCodeLine{00330 }
\DoxyCodeLine{00331     \textcolor{comment}{// Add an instruction to the command queue to set a new fence point. }}
\DoxyCodeLine{00332     \textcolor{comment}{// Because we are on the GPU timeline, the new fence point won't be }}
\DoxyCodeLine{00333     \textcolor{comment}{// set until the GPU finishes processing all the commands prior to this Signal().}}
\DoxyCodeLine{00334     mCommandQueue-\/>Signal(mFence.Get(), mCurrentFence);}
\DoxyCodeLine{00335 }
\DoxyCodeLine{00336     \textcolor{comment}{// Note that GPU could still be working on commands from previous}}
\DoxyCodeLine{00337         \textcolor{comment}{// frames, but that is okay, because we are not touching any frame}}
\DoxyCodeLine{00338         \textcolor{comment}{// resources associated with those frames.}}
\DoxyCodeLine{00339 }
\DoxyCodeLine{00340 \}}
\DoxyCodeLine{00341 }
\DoxyCodeLine{00342 \textcolor{keywordtype}{void} LandApp::OnMouseDown(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)}
\DoxyCodeLine{00343 \{}
\DoxyCodeLine{00344     mLastMousePos.x = x;}
\DoxyCodeLine{00345     mLastMousePos.y = y;}
\DoxyCodeLine{00346 }
\DoxyCodeLine{00347     SetCapture(mhMainWnd);}
\DoxyCodeLine{00348 \}}
\DoxyCodeLine{00349 }
\DoxyCodeLine{00350 \textcolor{keywordtype}{void} LandApp::OnMouseUp(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)}
\DoxyCodeLine{00351 \{}
\DoxyCodeLine{00352     ReleaseCapture();}
\DoxyCodeLine{00353 \}}
\DoxyCodeLine{00354 }
\DoxyCodeLine{00355 \textcolor{keywordtype}{void} LandApp::OnMouseMove(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)}
\DoxyCodeLine{00356 \{}
\DoxyCodeLine{00357     \textcolor{keywordflow}{if} ((btnState \& MK\_LBUTTON) != 0)}
\DoxyCodeLine{00358     \{}
\DoxyCodeLine{00359         \textcolor{comment}{// Make each pixel correspond to a quarter of a degree.}}
\DoxyCodeLine{00360         \textcolor{keywordtype}{float} dx = XMConvertToRadians(0.25f * \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x -\/ mLastMousePos.x));}
\DoxyCodeLine{00361         \textcolor{keywordtype}{float} dy = XMConvertToRadians(0.25f * \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(y -\/ mLastMousePos.y));}
\DoxyCodeLine{00362 }
\DoxyCodeLine{00363         \textcolor{comment}{// Update angles based on input to orbit camera around box.}}
\DoxyCodeLine{00364         mTheta += dx;}
\DoxyCodeLine{00365         mPhi += dy;}
\DoxyCodeLine{00366 }
\DoxyCodeLine{00367         \textcolor{comment}{// Restrict the angle mPhi.}}
\DoxyCodeLine{00368         mPhi = MathHelper::Clamp(mPhi, 0.1f, MathHelper::Pi -\/ 0.1f);}
\DoxyCodeLine{00369     \}}
\DoxyCodeLine{00370     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((btnState \& MK\_RBUTTON) != 0)}
\DoxyCodeLine{00371     \{}
\DoxyCodeLine{00372         \textcolor{comment}{// Make each pixel correspond to 0.2 unit in the scene.}}
\DoxyCodeLine{00373         \textcolor{keywordtype}{float} dx = 0.05f * \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x -\/ mLastMousePos.x);}
\DoxyCodeLine{00374         \textcolor{keywordtype}{float} dy = 0.05f * \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(y -\/ mLastMousePos.y);}
\DoxyCodeLine{00375 }
\DoxyCodeLine{00376         \textcolor{comment}{// Update the camera radius based on input.}}
\DoxyCodeLine{00377         mRadius += dx -\/ dy;}
\DoxyCodeLine{00378 }
\DoxyCodeLine{00379         \textcolor{comment}{// Restrict the radius.}}
\DoxyCodeLine{00380         mRadius = MathHelper::Clamp(mRadius, 5.0f, 150.0f);}
\DoxyCodeLine{00381     \}}
\DoxyCodeLine{00382 }
\DoxyCodeLine{00383     mLastMousePos.x = x;}
\DoxyCodeLine{00384     mLastMousePos.y = y;}
\DoxyCodeLine{00385 \}}
\DoxyCodeLine{00386 }
\DoxyCodeLine{00387 \textcolor{keywordtype}{void} LandApp::OnKeyboardInput(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00388 \{}
\DoxyCodeLine{00389     \textcolor{comment}{//Determines whether a key is up or down at the time the function is called, and whether the key was pressed after a previous call to GetAsyncKeyState.}}
\DoxyCodeLine{00390     \textcolor{comment}{//If the function succeeds, the return value specifies whether the key was pressed since the last call to GetAsyncKeyState, }}
\DoxyCodeLine{00391     \textcolor{comment}{//and whether the key is currently up or down. If the most significant bit is set, the key is down, and if the least significant bit is set, the key was pressed after the previous call to GetAsyncKeyState.}}
\DoxyCodeLine{00392     \textcolor{comment}{//if (GetAsyncKeyState('1') \& 0x8000)}}
\DoxyCodeLine{00393 }
\DoxyCodeLine{00394     \textcolor{keywordtype}{short} key = GetAsyncKeyState(\textcolor{charliteral}{'1'});}
\DoxyCodeLine{00395     \textcolor{keywordflow}{if} (key \& 0x8000)  \textcolor{comment}{//if one is pressed, 0x8000 = 32767 , key = -\/32767 = FFFFFFFFFFFF8001}}
\DoxyCodeLine{00396         mIsWireframe = \textcolor{keyword}{true};}
\DoxyCodeLine{00397     \textcolor{keywordflow}{else}}
\DoxyCodeLine{00398         mIsWireframe = \textcolor{keyword}{false};}
\DoxyCodeLine{00399 \}}
\DoxyCodeLine{00400 }
\DoxyCodeLine{00401 \textcolor{keywordtype}{void} LandApp::UpdateCamera(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00402 \{}
\DoxyCodeLine{00403     \textcolor{comment}{// Convert Spherical to Cartesian coordinates.}}
\DoxyCodeLine{00404     mEyePos.x = mRadius * sinf(mPhi) * cosf(mTheta);}
\DoxyCodeLine{00405     mEyePos.z = mRadius * sinf(mPhi) * sinf(mTheta);}
\DoxyCodeLine{00406     mEyePos.y = mRadius * cosf(mPhi);}
\DoxyCodeLine{00407 }
\DoxyCodeLine{00408     \textcolor{comment}{// Build the view matrix.}}
\DoxyCodeLine{00409     XMVECTOR pos = XMVectorSet(mEyePos.x, mEyePos.y, mEyePos.z, 1.0f);}
\DoxyCodeLine{00410     XMVECTOR target = XMVectorZero();}
\DoxyCodeLine{00411     XMVECTOR up = XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f);}
\DoxyCodeLine{00412 }
\DoxyCodeLine{00413     XMMATRIX view = XMMatrixLookAtLH(pos, target, up);}
\DoxyCodeLine{00414     XMStoreFloat4x4(\&mView, view);}
\DoxyCodeLine{00415 \}}
\DoxyCodeLine{00416 }
\DoxyCodeLine{00417 \textcolor{comment}{//step8: Update resources (cbuffers) in mCurrFrameResource}}
\DoxyCodeLine{00418 \textcolor{keywordtype}{void} LandApp::UpdateObjectCBs(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00419 \{}
\DoxyCodeLine{00420     \textcolor{keyword}{auto} currObjectCB = mCurrFrameResource-\/>ObjectCB.get();}
\DoxyCodeLine{00421     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& e : mAllRitems)}
\DoxyCodeLine{00422     \{}
\DoxyCodeLine{00423         \textcolor{comment}{// Only update the cbuffer data if the constants have changed.  }}
\DoxyCodeLine{00424         \textcolor{comment}{// This needs to be tracked per frame resource.}}
\DoxyCodeLine{00425         \textcolor{keywordflow}{if} (e-\/>NumFramesDirty > 0)}
\DoxyCodeLine{00426         \{}
\DoxyCodeLine{00427             XMMATRIX world = XMLoadFloat4x4(\&e-\/>World);}
\DoxyCodeLine{00428 }
\DoxyCodeLine{00429             ObjectConstants objConstants;}
\DoxyCodeLine{00430             XMStoreFloat4x4(\&objConstants.World, XMMatrixTranspose(world));}
\DoxyCodeLine{00431 }
\DoxyCodeLine{00432             currObjectCB-\/>CopyData(e-\/>ObjCBIndex, objConstants);}
\DoxyCodeLine{00433 }
\DoxyCodeLine{00434             \textcolor{comment}{// Next FrameResource need to be updated too.}}
\DoxyCodeLine{00435             e-\/>NumFramesDirty-\/-\/;}
\DoxyCodeLine{00436         \}}
\DoxyCodeLine{00437     \}}
\DoxyCodeLine{00438 \}}
\DoxyCodeLine{00439 }
\DoxyCodeLine{00440 \textcolor{comment}{//CBVs will be set at different frequencies—the per pass CBV only needs to be set once per}}
\DoxyCodeLine{00441 \textcolor{comment}{//rendering pass while the per object CBV needs to be set per render item}}
\DoxyCodeLine{00442 \textcolor{keywordtype}{void} LandApp::UpdateMainPassCB(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00443 \{}
\DoxyCodeLine{00444     XMMATRIX view = XMLoadFloat4x4(\&mView);}
\DoxyCodeLine{00445     XMMATRIX proj = XMLoadFloat4x4(\&mProj);}
\DoxyCodeLine{00446 }
\DoxyCodeLine{00447     XMMATRIX viewProj = XMMatrixMultiply(view, proj);}
\DoxyCodeLine{00448     XMMATRIX invView = XMMatrixInverse(\&XMMatrixDeterminant(view), view);}
\DoxyCodeLine{00449     XMMATRIX invProj = XMMatrixInverse(\&XMMatrixDeterminant(proj), proj);}
\DoxyCodeLine{00450     XMMATRIX invViewProj = XMMatrixInverse(\&XMMatrixDeterminant(viewProj), viewProj);}
\DoxyCodeLine{00451 }
\DoxyCodeLine{00452     XMStoreFloat4x4(\&mMainPassCB.View, XMMatrixTranspose(view));}
\DoxyCodeLine{00453     XMStoreFloat4x4(\&mMainPassCB.InvView, XMMatrixTranspose(invView));}
\DoxyCodeLine{00454     XMStoreFloat4x4(\&mMainPassCB.Proj, XMMatrixTranspose(proj));}
\DoxyCodeLine{00455     XMStoreFloat4x4(\&mMainPassCB.InvProj, XMMatrixTranspose(invProj));}
\DoxyCodeLine{00456     XMStoreFloat4x4(\&mMainPassCB.ViewProj, XMMatrixTranspose(viewProj));}
\DoxyCodeLine{00457     XMStoreFloat4x4(\&mMainPassCB.InvViewProj, XMMatrixTranspose(invViewProj));}
\DoxyCodeLine{00458     mMainPassCB.EyePosW = mEyePos;}
\DoxyCodeLine{00459     mMainPassCB.RenderTargetSize = XMFLOAT2((\textcolor{keywordtype}{float})mClientWidth, (\textcolor{keywordtype}{float})mClientHeight);}
\DoxyCodeLine{00460     mMainPassCB.InvRenderTargetSize = XMFLOAT2(1.0f / mClientWidth, 1.0f / mClientHeight);}
\DoxyCodeLine{00461     mMainPassCB.NearZ = 1.0f;}
\DoxyCodeLine{00462     mMainPassCB.FarZ = 1000.0f;}
\DoxyCodeLine{00463     mMainPassCB.TotalTime = gt.TotalTime();}
\DoxyCodeLine{00464     mMainPassCB.DeltaTime = gt.DeltaTime();}
\DoxyCodeLine{00465 }
\DoxyCodeLine{00466     \textcolor{keyword}{auto} currPassCB = mCurrFrameResource-\/>PassCB.get();}
\DoxyCodeLine{00467     currPassCB-\/>CopyData(0, mMainPassCB);}
\DoxyCodeLine{00468 \}}
\DoxyCodeLine{00469 }
\DoxyCodeLine{00470 \textcolor{keywordtype}{void} LandApp::BuildDescriptorHeaps()}
\DoxyCodeLine{00471 \{}
\DoxyCodeLine{00472     UINT objCount = (UINT)mOpaqueRitems.size();}
\DoxyCodeLine{00473 }
\DoxyCodeLine{00474     \textcolor{comment}{// Need a CBV descriptor for each object for each frame resource,}}
\DoxyCodeLine{00475     \textcolor{comment}{// +1 for the perPass CBV for each frame resource.}}
\DoxyCodeLine{00476     UINT numDescriptors = (objCount + 1) * gNumFrameResources;}
\DoxyCodeLine{00477 }
\DoxyCodeLine{00478     \textcolor{comment}{// Save an offset to the start of the pass CBVs.  These are the last 3 descriptors.}}
\DoxyCodeLine{00479     mPassCbvOffset = objCount * gNumFrameResources;}
\DoxyCodeLine{00480 }
\DoxyCodeLine{00481     D3D12\_DESCRIPTOR\_HEAP\_DESC cbvHeapDesc;}
\DoxyCodeLine{00482     cbvHeapDesc.NumDescriptors = numDescriptors;}
\DoxyCodeLine{00483     cbvHeapDesc.Type = D3D12\_DESCRIPTOR\_HEAP\_TYPE\_CBV\_SRV\_UAV;}
\DoxyCodeLine{00484     cbvHeapDesc.Flags = D3D12\_DESCRIPTOR\_HEAP\_FLAG\_SHADER\_VISIBLE;}
\DoxyCodeLine{00485     cbvHeapDesc.NodeMask = 0;}
\DoxyCodeLine{00486     ThrowIfFailed(md3dDevice-\/>CreateDescriptorHeap(\&cbvHeapDesc,}
\DoxyCodeLine{00487         IID\_PPV\_ARGS(\&mCbvHeap)));}
\DoxyCodeLine{00488 \}}
\DoxyCodeLine{00489 }
\DoxyCodeLine{00490 \textcolor{keywordtype}{void} LandApp::BuildConstantBufferViews()}
\DoxyCodeLine{00491 \{}
\DoxyCodeLine{00492     UINT objCBByteSize = d3dUtil::CalcConstantBufferByteSize(\textcolor{keyword}{sizeof}(ObjectConstants));}
\DoxyCodeLine{00493 }
\DoxyCodeLine{00494     UINT objCount = (UINT)mOpaqueRitems.size();}
\DoxyCodeLine{00495 }
\DoxyCodeLine{00496     \textcolor{comment}{// Need a CBV descriptor for each object for each frame resource.}}
\DoxyCodeLine{00497     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} frameIndex = 0; frameIndex < gNumFrameResources; ++frameIndex)}
\DoxyCodeLine{00498     \{}
\DoxyCodeLine{00499         \textcolor{keyword}{auto} objectCB = mFrameResources[frameIndex]-\/>ObjectCB-\/>Resource();}
\DoxyCodeLine{00500         \textcolor{keywordflow}{for} (UINT i = 0; i < objCount; ++i)}
\DoxyCodeLine{00501         \{}
\DoxyCodeLine{00502             D3D12\_GPU\_VIRTUAL\_ADDRESS cbAddress = objectCB-\/>GetGPUVirtualAddress();}
\DoxyCodeLine{00503 }
\DoxyCodeLine{00504             \textcolor{comment}{// Offset to the ith object constant buffer in the buffer.}}
\DoxyCodeLine{00505             cbAddress += i * objCBByteSize;}
\DoxyCodeLine{00506 }
\DoxyCodeLine{00507             \textcolor{comment}{// Offset to the object cbv in the descriptor heap.}}
\DoxyCodeLine{00508             \textcolor{keywordtype}{int} heapIndex = frameIndex * objCount + i;}
\DoxyCodeLine{00509             \textcolor{keyword}{auto} handle = CD3DX12\_CPU\_DESCRIPTOR\_HANDLE(mCbvHeap-\/>GetCPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00510             handle.Offset(heapIndex, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{00511 }
\DoxyCodeLine{00512             D3D12\_CONSTANT\_BUFFER\_VIEW\_DESC cbvDesc;}
\DoxyCodeLine{00513             cbvDesc.BufferLocation = cbAddress;}
\DoxyCodeLine{00514             cbvDesc.SizeInBytes = objCBByteSize;}
\DoxyCodeLine{00515 }
\DoxyCodeLine{00516             md3dDevice-\/>CreateConstantBufferView(\&cbvDesc, handle);}
\DoxyCodeLine{00517         \}}
\DoxyCodeLine{00518     \}}
\DoxyCodeLine{00519 }
\DoxyCodeLine{00520     UINT passCBByteSize = d3dUtil::CalcConstantBufferByteSize(\textcolor{keyword}{sizeof}(PassConstants));}
\DoxyCodeLine{00521 }
\DoxyCodeLine{00522     \textcolor{comment}{// Last three descriptors are the pass CBVs for each frame resource.}}
\DoxyCodeLine{00523     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} frameIndex = 0; frameIndex < gNumFrameResources; ++frameIndex)}
\DoxyCodeLine{00524     \{}
\DoxyCodeLine{00525         \textcolor{keyword}{auto} passCB = mFrameResources[frameIndex]-\/>PassCB-\/>Resource();}
\DoxyCodeLine{00526         D3D12\_GPU\_VIRTUAL\_ADDRESS cbAddress = passCB-\/>GetGPUVirtualAddress();}
\DoxyCodeLine{00527 }
\DoxyCodeLine{00528         \textcolor{comment}{// Offset to the pass cbv in the descriptor heap.}}
\DoxyCodeLine{00529         \textcolor{keywordtype}{int} heapIndex = mPassCbvOffset + frameIndex;}
\DoxyCodeLine{00530         \textcolor{keyword}{auto} handle = CD3DX12\_CPU\_DESCRIPTOR\_HANDLE(mCbvHeap-\/>GetCPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00531         handle.Offset(heapIndex, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{00532 }
\DoxyCodeLine{00533         D3D12\_CONSTANT\_BUFFER\_VIEW\_DESC cbvDesc;}
\DoxyCodeLine{00534         cbvDesc.BufferLocation = cbAddress;}
\DoxyCodeLine{00535         cbvDesc.SizeInBytes = passCBByteSize;}
\DoxyCodeLine{00536 }
\DoxyCodeLine{00537         md3dDevice-\/>CreateConstantBufferView(\&cbvDesc, handle);}
\DoxyCodeLine{00538     \}}
\DoxyCodeLine{00539 \}}
\DoxyCodeLine{00540 }
\DoxyCodeLine{00541 \textcolor{keywordtype}{void} LandApp::BuildRootSignature()}
\DoxyCodeLine{00542 \{}
\DoxyCodeLine{00543     \textcolor{comment}{//The resources that our shaders expect have changed; therefore, we need to update the}}
\DoxyCodeLine{00544     \textcolor{comment}{//root signature accordingly to take two descriptor tables(we need two tables because the}}
\DoxyCodeLine{00545     \textcolor{comment}{//CBVs will be set at different frequencies—the per pass CBV only needs to be set once per}}
\DoxyCodeLine{00546     \textcolor{comment}{//rendering pass while the per object CBV needs to be set per render item) :}}
\DoxyCodeLine{00547 }
\DoxyCodeLine{00548     CD3DX12\_DESCRIPTOR\_RANGE cbvTable0;}
\DoxyCodeLine{00549     cbvTable0.Init(D3D12\_DESCRIPTOR\_RANGE\_TYPE\_CBV, 1, 0);}
\DoxyCodeLine{00550 }
\DoxyCodeLine{00551     CD3DX12\_DESCRIPTOR\_RANGE cbvTable1;}
\DoxyCodeLine{00552     cbvTable1.Init(D3D12\_DESCRIPTOR\_RANGE\_TYPE\_CBV, 1, 1);}
\DoxyCodeLine{00553 }
\DoxyCodeLine{00554     \textcolor{comment}{// Root parameter can be a table, root descriptor or root constants.}}
\DoxyCodeLine{00555     CD3DX12\_ROOT\_PARAMETER slotRootParameter[2];}
\DoxyCodeLine{00556 }
\DoxyCodeLine{00557     \textcolor{comment}{// Create root CBVs.}}
\DoxyCodeLine{00558     slotRootParameter[0].InitAsDescriptorTable(1, \&cbvTable0);}
\DoxyCodeLine{00559     slotRootParameter[1].InitAsDescriptorTable(1, \&cbvTable1);}
\DoxyCodeLine{00560 }
\DoxyCodeLine{00561     \textcolor{comment}{// A root signature is an array of root parameters.}}
\DoxyCodeLine{00562     CD3DX12\_ROOT\_SIGNATURE\_DESC rootSigDesc(2, slotRootParameter, 0, \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00563         D3D12\_ROOT\_SIGNATURE\_FLAG\_ALLOW\_INPUT\_ASSEMBLER\_INPUT\_LAYOUT);}
\DoxyCodeLine{00564 }
\DoxyCodeLine{00565     \textcolor{comment}{// create a root signature with a single slot which points to a descriptor range consisting of a single constant buffer}}
\DoxyCodeLine{00566     ComPtr<ID3DBlob> serializedRootSig = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00567     ComPtr<ID3DBlob> errorBlob = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00568     HRESULT hr = D3D12SerializeRootSignature(\&rootSigDesc, D3D\_ROOT\_SIGNATURE\_VERSION\_1,}
\DoxyCodeLine{00569         serializedRootSig.GetAddressOf(), errorBlob.GetAddressOf());}
\DoxyCodeLine{00570 }
\DoxyCodeLine{00571     \textcolor{keywordflow}{if} (errorBlob != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00572     \{}
\DoxyCodeLine{00573         ::OutputDebugStringA((\textcolor{keywordtype}{char}*)errorBlob-\/>GetBufferPointer());}
\DoxyCodeLine{00574     \}}
\DoxyCodeLine{00575     ThrowIfFailed(hr);}
\DoxyCodeLine{00576 }
\DoxyCodeLine{00577     ThrowIfFailed(md3dDevice-\/>CreateRootSignature(}
\DoxyCodeLine{00578         0,}
\DoxyCodeLine{00579         serializedRootSig-\/>GetBufferPointer(),}
\DoxyCodeLine{00580         serializedRootSig-\/>GetBufferSize(),}
\DoxyCodeLine{00581         IID\_PPV\_ARGS(mRootSignature.GetAddressOf())));}
\DoxyCodeLine{00582 \}}
\DoxyCodeLine{00583 }
\DoxyCodeLine{00584 \textcolor{keywordtype}{void} LandApp::BuildShadersAndInputLayout()}
\DoxyCodeLine{00585 \{}
\DoxyCodeLine{00586     mShaders[\textcolor{stringliteral}{"{}standardVS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)VS.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}VS"{}}, \textcolor{stringliteral}{"{}vs\_5\_1"{}});}
\DoxyCodeLine{00587     mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)PS.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}PS"{}}, \textcolor{stringliteral}{"{}ps\_5\_1"{}});}
\DoxyCodeLine{00588 }
\DoxyCodeLine{00589     mInputLayout =}
\DoxyCodeLine{00590     \{}
\DoxyCodeLine{00591         \{ \textcolor{stringliteral}{"{}POSITION"{}}, 0, DXGI\_FORMAT\_R32G32B32\_FLOAT, 0, 0, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{00592         \{ \textcolor{stringliteral}{"{}COLOR"{}}, 0, DXGI\_FORMAT\_R32G32B32A32\_FLOAT, 0, 12, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{00593     \};}
\DoxyCodeLine{00594 \}}
\DoxyCodeLine{00595 }
\DoxyCodeLine{00596 \textcolor{comment}{//step1}}
\DoxyCodeLine{00597 \textcolor{keywordtype}{void} LandApp::BuildLandGeometry()}
\DoxyCodeLine{00598 \{}
\DoxyCodeLine{00599     \textcolor{comment}{//GeometryGenerator is a utility class for generating simple geometric shapes like grids, grid, grids, and boxes}}
\DoxyCodeLine{00600     GeometryGenerator geoGen;}
\DoxyCodeLine{00601     \textcolor{comment}{//The MeshData structure is a simple structure nested inside GeometryGenerator that stores a vertexand index list}}
\DoxyCodeLine{00602 }
\DoxyCodeLine{00603     \textcolor{comment}{//GeometryGenerator::CreateGrid(float width, float depth, uint32 m, uint32 n)}}
\DoxyCodeLine{00604     GeometryGenerator::MeshData grid = geoGen.CreateGrid(160.0f, 160.0f, 50, 50);}
\DoxyCodeLine{00605 }
\DoxyCodeLine{00606     \textcolor{comment}{//number of cells 2x(m-\/1)(n-\/1)}}
\DoxyCodeLine{00607     \textcolor{comment}{//Vij = [-\/0.5w+jdx, 0, 0.5=i-\/dz]}}
\DoxyCodeLine{00608 }
\DoxyCodeLine{00609     \textcolor{comment}{//}}
\DoxyCodeLine{00610     \textcolor{comment}{// Extract the vertex elements we are interested and apply the height function to}}
\DoxyCodeLine{00611     \textcolor{comment}{// each vertex.  In addition, color the vertices based on their height so we have}}
\DoxyCodeLine{00612     \textcolor{comment}{// sandy looking beaches, grassy low hills, and snow mountain peaks.}}
\DoxyCodeLine{00613     \textcolor{comment}{//}}
\DoxyCodeLine{00614 }
\DoxyCodeLine{00615     std::vector<Vertex> vertices(grid.Vertices.size());}
\DoxyCodeLine{00616     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < grid.Vertices.size(); ++i)}
\DoxyCodeLine{00617     \{}
\DoxyCodeLine{00618         \textcolor{keyword}{auto}\& p = grid.Vertices[i].Position;}
\DoxyCodeLine{00619         vertices[i].Pos = p;}
\DoxyCodeLine{00620         vertices[i].Pos.y = GetHillsHeight(p.x, p.z);}
\DoxyCodeLine{00621 }
\DoxyCodeLine{00622         \textcolor{comment}{// Color the vertex based on its height.}}
\DoxyCodeLine{00623         \textcolor{keywordflow}{if} (vertices[i].Pos.y < -\/10.0f)}
\DoxyCodeLine{00624         \{}
\DoxyCodeLine{00625             \textcolor{comment}{// Sandy beach color.}}
\DoxyCodeLine{00626             vertices[i].Color = XMFLOAT4(1.0f, 0.96f, 0.62f, 1.0f);}
\DoxyCodeLine{00627         \}}
\DoxyCodeLine{00628         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (vertices[i].Pos.y < 5.0f)}
\DoxyCodeLine{00629         \{}
\DoxyCodeLine{00630             \textcolor{comment}{// Light yellow-\/green.}}
\DoxyCodeLine{00631             vertices[i].Color = XMFLOAT4(0.48f, 0.77f, 0.46f, 1.0f);}
\DoxyCodeLine{00632         \}}
\DoxyCodeLine{00633         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (vertices[i].Pos.y < 12.0f)}
\DoxyCodeLine{00634         \{}
\DoxyCodeLine{00635             \textcolor{comment}{// Dark yellow-\/green.}}
\DoxyCodeLine{00636             vertices[i].Color = XMFLOAT4(0.1f, 0.48f, 0.19f, 1.0f);}
\DoxyCodeLine{00637         \}}
\DoxyCodeLine{00638         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (vertices[i].Pos.y < 20.0f)}
\DoxyCodeLine{00639         \{}
\DoxyCodeLine{00640             \textcolor{comment}{// Dark brown.}}
\DoxyCodeLine{00641             vertices[i].Color = XMFLOAT4(0.45f, 0.39f, 0.34f, 1.0f);}
\DoxyCodeLine{00642         \}}
\DoxyCodeLine{00643         \textcolor{keywordflow}{else}}
\DoxyCodeLine{00644         \{}
\DoxyCodeLine{00645             \textcolor{comment}{// White snow.}}
\DoxyCodeLine{00646             vertices[i].Color = XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f);}
\DoxyCodeLine{00647         \}}
\DoxyCodeLine{00648     \}}
\DoxyCodeLine{00649 }
\DoxyCodeLine{00650 }
\DoxyCodeLine{00651 }
\DoxyCodeLine{00652     \textcolor{comment}{//}}
\DoxyCodeLine{00653     \textcolor{comment}{// We are concatenating all the geometry into one big vertex/index buffer.  So}}
\DoxyCodeLine{00654     \textcolor{comment}{// define the regions in the buffer each submesh covers.}}
\DoxyCodeLine{00655     \textcolor{comment}{//}}
\DoxyCodeLine{00656 }
\DoxyCodeLine{00657     \textcolor{comment}{// Cache the vertex offsets to each object in the concatenated vertex buffer.}}
\DoxyCodeLine{00658     UINT gridVertexOffset = 0;}
\DoxyCodeLine{00659 }
\DoxyCodeLine{00660 }
\DoxyCodeLine{00661     \textcolor{comment}{// Cache the starting index for each object in the concatenated index buffer.}}
\DoxyCodeLine{00662     UINT gridIndexOffset = 0;}
\DoxyCodeLine{00663 }
\DoxyCodeLine{00664 }
\DoxyCodeLine{00665     \textcolor{comment}{// Define the SubmeshGeometry that cover different }}
\DoxyCodeLine{00666     \textcolor{comment}{// regions of the vertex/index buffers.}}
\DoxyCodeLine{00667 }
\DoxyCodeLine{00668     SubmeshGeometry gridSubmesh;}
\DoxyCodeLine{00669     gridSubmesh.IndexCount = (UINT)grid.Indices32.size();}
\DoxyCodeLine{00670     gridSubmesh.StartIndexLocation = gridIndexOffset;}
\DoxyCodeLine{00671     gridSubmesh.BaseVertexLocation = gridVertexOffset;}
\DoxyCodeLine{00672 }
\DoxyCodeLine{00673 }
\DoxyCodeLine{00674     \textcolor{comment}{//}}
\DoxyCodeLine{00675     \textcolor{comment}{// Extract the vertex elements we are interested in and pack the}}
\DoxyCodeLine{00676     \textcolor{comment}{// vertices of all the meshes into one vertex buffer.}}
\DoxyCodeLine{00677     \textcolor{comment}{//}}
\DoxyCodeLine{00678 }
\DoxyCodeLine{00679     \textcolor{comment}{//auto totalVertexCount = grid.Vertices.size();}}
\DoxyCodeLine{00680 }
\DoxyCodeLine{00681 }
\DoxyCodeLine{00682     \textcolor{comment}{//std::vector<Vertex> vertices(totalVertexCount);}}
\DoxyCodeLine{00683 }
\DoxyCodeLine{00684     \textcolor{comment}{//UINT k = 0;}}
\DoxyCodeLine{00685     \textcolor{comment}{//for (size\_t i = 0; i < grid.Vertices.size(); ++i, ++k)}}
\DoxyCodeLine{00686     \textcolor{comment}{//\{}}
\DoxyCodeLine{00687     \textcolor{comment}{//  vertices[k].Pos = grid.Vertices[i].Position;}}
\DoxyCodeLine{00688     \textcolor{comment}{//  vertices[k].Color = XMFLOAT4(DirectX::Colors::DarkOrange);}}
\DoxyCodeLine{00689     \textcolor{comment}{//\}}}
\DoxyCodeLine{00690 }
\DoxyCodeLine{00691 }
\DoxyCodeLine{00692     std::vector<std::uint16\_t> indices;}
\DoxyCodeLine{00693     indices.insert(indices.end(), std::begin(grid.GetIndices16()), std::end(grid.GetIndices16()));}
\DoxyCodeLine{00694 }
\DoxyCodeLine{00695 }
\DoxyCodeLine{00696     \textcolor{keyword}{const} UINT vbByteSize = (UINT)vertices.size() * \textcolor{keyword}{sizeof}(Vertex);}
\DoxyCodeLine{00697     \textcolor{keyword}{const} UINT ibByteSize = (UINT)indices.size() * \textcolor{keyword}{sizeof}(std::uint16\_t);}
\DoxyCodeLine{00698 }
\DoxyCodeLine{00699     \textcolor{keyword}{auto} geo = std::make\_unique<MeshGeometry>();}
\DoxyCodeLine{00700     geo-\/>Name = \textcolor{stringliteral}{"{}landGeo"{}};}
\DoxyCodeLine{00701 }
\DoxyCodeLine{00702     ThrowIfFailed(D3DCreateBlob(vbByteSize, \&geo-\/>VertexBufferCPU));}
\DoxyCodeLine{00703     CopyMemory(geo-\/>VertexBufferCPU-\/>GetBufferPointer(), vertices.data(), vbByteSize);}
\DoxyCodeLine{00704 }
\DoxyCodeLine{00705     ThrowIfFailed(D3DCreateBlob(ibByteSize, \&geo-\/>IndexBufferCPU));}
\DoxyCodeLine{00706     CopyMemory(geo-\/>IndexBufferCPU-\/>GetBufferPointer(), indices.data(), ibByteSize);}
\DoxyCodeLine{00707 }
\DoxyCodeLine{00708     geo-\/>VertexBufferGPU = d3dUtil::CreateDefaultBuffer(md3dDevice.Get(),}
\DoxyCodeLine{00709         mCommandList.Get(), vertices.data(), vbByteSize, geo-\/>VertexBufferUploader);}
\DoxyCodeLine{00710 }
\DoxyCodeLine{00711     geo-\/>IndexBufferGPU = d3dUtil::CreateDefaultBuffer(md3dDevice.Get(),}
\DoxyCodeLine{00712         mCommandList.Get(), indices.data(), ibByteSize, geo-\/>IndexBufferUploader);}
\DoxyCodeLine{00713 }
\DoxyCodeLine{00714     geo-\/>VertexByteStride = \textcolor{keyword}{sizeof}(Vertex);}
\DoxyCodeLine{00715     geo-\/>VertexBufferByteSize = vbByteSize;}
\DoxyCodeLine{00716     geo-\/>IndexFormat = DXGI\_FORMAT\_R16\_UINT;}
\DoxyCodeLine{00717     geo-\/>IndexBufferByteSize = ibByteSize;}
\DoxyCodeLine{00718 }
\DoxyCodeLine{00719     geo-\/>DrawArgs[\textcolor{stringliteral}{"{}grid"{}}] = gridSubmesh;}
\DoxyCodeLine{00720 }
\DoxyCodeLine{00721 }
\DoxyCodeLine{00722     mGeometries[geo-\/>Name] = std::move(geo);}
\DoxyCodeLine{00723 \}}
\DoxyCodeLine{00724 }
\DoxyCodeLine{00725 \textcolor{keywordtype}{void} LandApp::BuildPSOs()}
\DoxyCodeLine{00726 \{}
\DoxyCodeLine{00727     D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC opaquePsoDesc;}
\DoxyCodeLine{00728 }
\DoxyCodeLine{00729     \textcolor{comment}{//}}
\DoxyCodeLine{00730     \textcolor{comment}{// PSO for opaque objects.}}
\DoxyCodeLine{00731     \textcolor{comment}{//}}
\DoxyCodeLine{00732     ZeroMemory(\&opaquePsoDesc, \textcolor{keyword}{sizeof}(D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC));}
\DoxyCodeLine{00733     opaquePsoDesc.InputLayout = \{ mInputLayout.data(), (UINT)mInputLayout.size() \};}
\DoxyCodeLine{00734     opaquePsoDesc.pRootSignature = mRootSignature.Get();}
\DoxyCodeLine{00735     opaquePsoDesc.VS =}
\DoxyCodeLine{00736     \{}
\DoxyCodeLine{00737         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}standardVS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{00738         mShaders[\textcolor{stringliteral}{"{}standardVS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{00739     \};}
\DoxyCodeLine{00740     opaquePsoDesc.PS =}
\DoxyCodeLine{00741     \{}
\DoxyCodeLine{00742         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{00743         mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{00744     \};}
\DoxyCodeLine{00745     opaquePsoDesc.RasterizerState = CD3DX12\_RASTERIZER\_DESC(D3D12\_DEFAULT);}
\DoxyCodeLine{00746     opaquePsoDesc.RasterizerState.FillMode = D3D12\_FILL\_MODE\_SOLID;}
\DoxyCodeLine{00747     opaquePsoDesc.BlendState = CD3DX12\_BLEND\_DESC(D3D12\_DEFAULT);}
\DoxyCodeLine{00748     opaquePsoDesc.DepthStencilState = CD3DX12\_DEPTH\_STENCIL\_DESC(D3D12\_DEFAULT);}
\DoxyCodeLine{00749     opaquePsoDesc.SampleMask = UINT\_MAX;}
\DoxyCodeLine{00750     opaquePsoDesc.PrimitiveTopologyType = D3D12\_PRIMITIVE\_TOPOLOGY\_TYPE\_TRIANGLE;}
\DoxyCodeLine{00751     opaquePsoDesc.NumRenderTargets = 1;}
\DoxyCodeLine{00752     opaquePsoDesc.RTVFormats[0] = mBackBufferFormat;}
\DoxyCodeLine{00753     opaquePsoDesc.SampleDesc.Count = m4xMsaaState ? 4 : 1;}
\DoxyCodeLine{00754     opaquePsoDesc.SampleDesc.Quality = m4xMsaaState ? (m4xMsaaQuality -\/ 1) : 0;}
\DoxyCodeLine{00755     opaquePsoDesc.DSVFormat = mDepthStencilFormat;}
\DoxyCodeLine{00756     ThrowIfFailed(md3dDevice-\/>CreateGraphicsPipelineState(\&opaquePsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}opaque"{}}])));}
\DoxyCodeLine{00757 }
\DoxyCodeLine{00758 }
\DoxyCodeLine{00759     \textcolor{comment}{//}}
\DoxyCodeLine{00760     \textcolor{comment}{// PSO for opaque wireframe objects.}}
\DoxyCodeLine{00761     \textcolor{comment}{//}}
\DoxyCodeLine{00762 }
\DoxyCodeLine{00763     D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC opaqueWireframePsoDesc = opaquePsoDesc;}
\DoxyCodeLine{00764     opaqueWireframePsoDesc.RasterizerState.FillMode = D3D12\_FILL\_MODE\_WIREFRAME;}
\DoxyCodeLine{00765     ThrowIfFailed(md3dDevice-\/>CreateGraphicsPipelineState(\&opaqueWireframePsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}opaque\_wireframe"{}}])));}
\DoxyCodeLine{00766 \}}
\DoxyCodeLine{00767 }
\DoxyCodeLine{00768 \textcolor{comment}{//step6: build three frame resources}}
\DoxyCodeLine{00769 \textcolor{comment}{//FrameResource constructor:     FrameResource(ID3D12Device* device, UINT passCount, UINT objectCount);}}
\DoxyCodeLine{00770 }
\DoxyCodeLine{00771 \textcolor{keywordtype}{void} LandApp::BuildFrameResources()}
\DoxyCodeLine{00772 \{}
\DoxyCodeLine{00773     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < gNumFrameResources; ++i)}
\DoxyCodeLine{00774     \{}
\DoxyCodeLine{00775         mFrameResources.push\_back(std::make\_unique<FrameResource>(md3dDevice.Get(),}
\DoxyCodeLine{00776             1, (UINT)mAllRitems.size()));}
\DoxyCodeLine{00777     \}}
\DoxyCodeLine{00778 \}}
\DoxyCodeLine{00779 }
\DoxyCodeLine{00780 \textcolor{keywordtype}{void} LandApp::BuildRenderItems()}
\DoxyCodeLine{00781 \{}
\DoxyCodeLine{00782     \textcolor{keyword}{auto} gridRitem = std::make\_unique<RenderItem>();}
\DoxyCodeLine{00783     \textcolor{comment}{//step3}}
\DoxyCodeLine{00784     \textcolor{comment}{//XMStoreFloat4x4(\&gridRitem-\/>World, XMMatrixScaling(2.0f, 2.0f, 2.0f) * XMMatrixTranslation(0.0f, 0.5f, 0.0f));}}
\DoxyCodeLine{00785     gridRitem-\/>World = MathHelper::Identity4x4();}
\DoxyCodeLine{00786     gridRitem-\/>ObjCBIndex = 0;}
\DoxyCodeLine{00787     gridRitem-\/>Geo = mGeometries[\textcolor{stringliteral}{"{}landGeo"{}}].get();}
\DoxyCodeLine{00788     gridRitem-\/>PrimitiveType = D3D\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST;}
\DoxyCodeLine{00789     gridRitem-\/>IndexCount = gridRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}grid"{}}].IndexCount;}
\DoxyCodeLine{00790     gridRitem-\/>StartIndexLocation = gridRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}grid"{}}].StartIndexLocation;}
\DoxyCodeLine{00791     gridRitem-\/>BaseVertexLocation = gridRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}grid"{}}].BaseVertexLocation;}
\DoxyCodeLine{00792     mAllRitems.push\_back(std::move(gridRitem));}
\DoxyCodeLine{00793 }
\DoxyCodeLine{00794 }
\DoxyCodeLine{00795     \textcolor{comment}{// All the render items are opaque.}}
\DoxyCodeLine{00796     \textcolor{comment}{//Our application will maintain lists of render items based on how they need to be}}
\DoxyCodeLine{00797     \textcolor{comment}{//drawn; that is, render items that need different PSOs will be kept in different lists.}}
\DoxyCodeLine{00798     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& e : mAllRitems)}
\DoxyCodeLine{00799         mOpaqueRitems.push\_back(e.get());}
\DoxyCodeLine{00800 \}}
\DoxyCodeLine{00801 }
\DoxyCodeLine{00802 \textcolor{keywordtype}{void} LandApp::DrawRenderItems(ID3D12GraphicsCommandList* cmdList, \textcolor{keyword}{const} std::vector<RenderItem*>\& ritems)}
\DoxyCodeLine{00803 \{}
\DoxyCodeLine{00804     UINT objCBByteSize = d3dUtil::CalcConstantBufferByteSize(\textcolor{keyword}{sizeof}(ObjectConstants));}
\DoxyCodeLine{00805 }
\DoxyCodeLine{00806     \textcolor{keyword}{auto} objectCB = mCurrFrameResource-\/>ObjectCB-\/>Resource();}
\DoxyCodeLine{00807 }
\DoxyCodeLine{00808     \textcolor{comment}{// For each render item...}}
\DoxyCodeLine{00809     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < ritems.size(); ++i)}
\DoxyCodeLine{00810     \{}
\DoxyCodeLine{00811         \textcolor{keyword}{auto} ri = ritems[i];}
\DoxyCodeLine{00812 }
\DoxyCodeLine{00813         cmdList-\/>IASetVertexBuffers(0, 1, \&ri-\/>Geo-\/>VertexBufferView());}
\DoxyCodeLine{00814         cmdList-\/>IASetIndexBuffer(\&ri-\/>Geo-\/>IndexBufferView());}
\DoxyCodeLine{00815         cmdList-\/>IASetPrimitiveTopology(ri-\/>PrimitiveType);}
\DoxyCodeLine{00816 }
\DoxyCodeLine{00817         \textcolor{comment}{// Offset to the CBV in the descriptor heap for this object and for this frame resource.}}
\DoxyCodeLine{00818         UINT cbvIndex = mCurrFrameResourceIndex * (UINT)mOpaqueRitems.size() + ri-\/>ObjCBIndex;}
\DoxyCodeLine{00819         \textcolor{keyword}{auto} cbvHandle = CD3DX12\_GPU\_DESCRIPTOR\_HANDLE(mCbvHeap-\/>GetGPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00820         cbvHandle.Offset(cbvIndex, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{00821 }
\DoxyCodeLine{00822         cmdList-\/>SetGraphicsRootDescriptorTable(0, cbvHandle);}
\DoxyCodeLine{00823 }
\DoxyCodeLine{00824         cmdList-\/>DrawIndexedInstanced(ri-\/>IndexCount, 1, ri-\/>StartIndexLocation, ri-\/>BaseVertexLocation, 0);}
\DoxyCodeLine{00825     \}}
\DoxyCodeLine{00826 \}}
\DoxyCodeLine{00827 }
\DoxyCodeLine{00828 \textcolor{keywordtype}{float} LandApp::GetHillsHeight(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} z)\textcolor{keyword}{const}}
\DoxyCodeLine{00829 \textcolor{keyword}{}\{}
\DoxyCodeLine{00830     \textcolor{comment}{//https://www.geogebra.org/3d?lang=en}}
\DoxyCodeLine{00831     \textcolor{comment}{//f(x,z)=0.3 (z sin(0.1 x)+x cos(0.1 z))}}
\DoxyCodeLine{00832     \textcolor{keywordflow}{return} 0.3f * (z * sinf(0.1f * x) + x * cosf(0.1f * z));}
\DoxyCodeLine{00833 \}}
\DoxyCodeLine{00834 }
\DoxyCodeLine{00835 }

\end{DoxyCode}
