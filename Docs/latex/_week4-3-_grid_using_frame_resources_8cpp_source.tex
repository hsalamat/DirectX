\doxysection{Week4-\/3-\/\+Grid\+Using\+Frame\+Resources.cpp}
\label{_week4-3-_grid_using_frame_resources_8cpp_source}\index{Week4/Week4/Week4-\/3-\/GridUsingFrameResources.cpp@{Week4/Week4/Week4-\/3-\/GridUsingFrameResources.cpp}}
\textbf{ Go to the documentation of this file.}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001 }
\DoxyCodeLine{00012 \textcolor{preprocessor}{\#include "{}../../Common/d3dApp.h"{}}}
\DoxyCodeLine{00013 \textcolor{preprocessor}{\#include "{}../../Common/MathHelper.h"{}}}
\DoxyCodeLine{00014 \textcolor{preprocessor}{\#include "{}../../Common/UploadBuffer.h"{}}}
\DoxyCodeLine{00015 \textcolor{preprocessor}{\#include "{}../../Common/GeometryGenerator.h"{}}}
\DoxyCodeLine{00016 \textcolor{preprocessor}{\#include "{}FrameResource.h"{}}}
\DoxyCodeLine{00017 }
\DoxyCodeLine{00018 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{00019 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{00020 }
\DoxyCodeLine{00021 \textcolor{keyword}{using} Microsoft::WRL::ComPtr;}
\DoxyCodeLine{00022 \textcolor{keyword}{using namespace }DirectX;}
\DoxyCodeLine{00023 \textcolor{keyword}{using namespace }DirectX::PackedVector;}
\DoxyCodeLine{00024 }
\DoxyCodeLine{00025 \textcolor{comment}{//Our application class will then instantiate a vector of three frame resources, }}
\DoxyCodeLine{00026 \textcolor{keyword}{const} \textcolor{keywordtype}{int} gNumFrameResources = 3;}
\DoxyCodeLine{00027 }
\DoxyCodeLine{00028 \textcolor{comment}{//Lightweight structure stores parameters to draw a shape.  This will vary from app-\/to-\/app.}}
\DoxyCodeLine{00029 \textcolor{keyword}{struct }RenderItem}
\DoxyCodeLine{00030 \{}
\DoxyCodeLine{00031     RenderItem() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{00032 }
\DoxyCodeLine{00033     \textcolor{comment}{// World matrix of the shape that describes the object's local space}}
\DoxyCodeLine{00034     \textcolor{comment}{// relative to the world space, which defines the position, orientation,}}
\DoxyCodeLine{00035     \textcolor{comment}{// and scale of the object in the world.}}
\DoxyCodeLine{00036     XMFLOAT4X4 World = MathHelper::Identity4x4();}
\DoxyCodeLine{00037 }
\DoxyCodeLine{00038     \textcolor{comment}{// Dirty flag indicating the object data has changed and we need to update the constant buffer.}}
\DoxyCodeLine{00039     \textcolor{comment}{// Because we have an object cbuffer for each FrameResource, we have to apply the}}
\DoxyCodeLine{00040     \textcolor{comment}{// update to each FrameResource.  Thus, when we modify object data, we should set }}
\DoxyCodeLine{00041     \textcolor{comment}{// NumFramesDirty = gNumFrameResources so that each frame resource gets the update.}}
\DoxyCodeLine{00042     \textcolor{keywordtype}{int} NumFramesDirty = gNumFrameResources;}
\DoxyCodeLine{00043 }
\DoxyCodeLine{00044     \textcolor{comment}{// Index into GPU constant buffer corresponding to the ObjectCB for this render item.}}
\DoxyCodeLine{00045     UINT ObjCBIndex = -\/1;}
\DoxyCodeLine{00046 }
\DoxyCodeLine{00047     \textcolor{comment}{// Geometry associated with this render-\/item. Note that multiple}}
\DoxyCodeLine{00048     \textcolor{comment}{// render-\/items can share the same geometry.}}
\DoxyCodeLine{00049     MeshGeometry* Geo = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00050 }
\DoxyCodeLine{00051     \textcolor{comment}{// Primitive topology.}}
\DoxyCodeLine{00052     D3D12\_PRIMITIVE\_TOPOLOGY PrimitiveType = D3D\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST;}
\DoxyCodeLine{00053 }
\DoxyCodeLine{00054     \textcolor{comment}{// DrawIndexedInstanced parameters.}}
\DoxyCodeLine{00055     UINT IndexCount = 0; \textcolor{comment}{//Number of indices read from the index buffer for each instance.}}
\DoxyCodeLine{00056     UINT StartIndexLocation = 0; \textcolor{comment}{//The location of the first index read by the GPU from the index buffer.}}
\DoxyCodeLine{00057     \textcolor{keywordtype}{int} BaseVertexLocation = 0; \textcolor{comment}{//A value added to each index before reading a vertex from the vertex buffer.}}
\DoxyCodeLine{00058 \};}
\DoxyCodeLine{00059 }
\DoxyCodeLine{00060 \textcolor{keyword}{class }ShapesApp : \textcolor{keyword}{public} D3DApp}
\DoxyCodeLine{00061 \{}
\DoxyCodeLine{00062 \textcolor{keyword}{public}:}
\DoxyCodeLine{00063     ShapesApp(HINSTANCE hInstance);}
\DoxyCodeLine{00064     ShapesApp(\textcolor{keyword}{const} ShapesApp\& rhs) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00065     ShapesApp\& operator=(\textcolor{keyword}{const} ShapesApp\& rhs) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00066     \string~ShapesApp();}
\DoxyCodeLine{00067 }
\DoxyCodeLine{00068     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} Initialize()\textcolor{keyword}{override};}
\DoxyCodeLine{00069 }
\DoxyCodeLine{00070 \textcolor{keyword}{private}:}
\DoxyCodeLine{00071     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnResize()\textcolor{keyword}{override};}
\DoxyCodeLine{00072     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Update(\textcolor{keyword}{const} GameTimer\& gt)\textcolor{keyword}{override};}
\DoxyCodeLine{00073     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Draw(\textcolor{keyword}{const} GameTimer\& gt)\textcolor{keyword}{override};}
\DoxyCodeLine{00074 }
\DoxyCodeLine{00075     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnMouseDown(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)\textcolor{keyword}{override};}
\DoxyCodeLine{00076     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnMouseUp(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)\textcolor{keyword}{override};}
\DoxyCodeLine{00077     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} OnMouseMove(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)\textcolor{keyword}{override};}
\DoxyCodeLine{00078 }
\DoxyCodeLine{00079     \textcolor{keywordtype}{void} OnKeyboardInput(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00080     \textcolor{keywordtype}{void} UpdateCamera(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00081     \textcolor{keywordtype}{void} UpdateObjectCBs(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00082     \textcolor{keywordtype}{void} UpdateMainPassCB(\textcolor{keyword}{const} GameTimer\& gt);}
\DoxyCodeLine{00083 }
\DoxyCodeLine{00084     \textcolor{keywordtype}{void} BuildDescriptorHeaps();}
\DoxyCodeLine{00085     \textcolor{keywordtype}{void} BuildConstantBufferViews();}
\DoxyCodeLine{00086     \textcolor{keywordtype}{void} BuildRootSignature();}
\DoxyCodeLine{00087     \textcolor{keywordtype}{void} BuildShadersAndInputLayout();}
\DoxyCodeLine{00088     \textcolor{keywordtype}{void} BuildShapeGeometry();}
\DoxyCodeLine{00089     \textcolor{keywordtype}{void} BuildPSOs();}
\DoxyCodeLine{00090     \textcolor{keywordtype}{void} BuildFrameResources();}
\DoxyCodeLine{00091 }
\DoxyCodeLine{00092     \textcolor{keywordtype}{void} BuildRenderItems();}
\DoxyCodeLine{00093     \textcolor{keywordtype}{void} DrawRenderItems(ID3D12GraphicsCommandList* cmdList, \textcolor{keyword}{const} std::vector<RenderItem*>\& ritems);}
\DoxyCodeLine{00094 }
\DoxyCodeLine{00095 \textcolor{keyword}{private}:}
\DoxyCodeLine{00096 }
\DoxyCodeLine{00097     \textcolor{comment}{//keep member variables to track the current frame resource :}}
\DoxyCodeLine{00098     std::vector<std::unique\_ptr<FrameResource>> mFrameResources;}
\DoxyCodeLine{00099     FrameResource* mCurrFrameResource = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00100     \textcolor{keywordtype}{int} mCurrFrameResourceIndex = 0;}
\DoxyCodeLine{00101 }
\DoxyCodeLine{00102     ComPtr<ID3D12RootSignature> mRootSignature = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00103     ComPtr<ID3D12DescriptorHeap> mCbvHeap = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00104 }
\DoxyCodeLine{00105     ComPtr<ID3D12DescriptorHeap> mSrvDescriptorHeap = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00106 }
\DoxyCodeLine{00107     std::unordered\_map<std::string, std::unique\_ptr<MeshGeometry>> mGeometries;}
\DoxyCodeLine{00108     std::unordered\_map<std::string, ComPtr<ID3DBlob>> mShaders;}
\DoxyCodeLine{00109     std::unordered\_map<std::string, ComPtr<ID3D12PipelineState>> mPSOs;}
\DoxyCodeLine{00110 }
\DoxyCodeLine{00111     std::vector<D3D12\_INPUT\_ELEMENT\_DESC> mInputLayout;}
\DoxyCodeLine{00112 }
\DoxyCodeLine{00113     \textcolor{comment}{// List of all the render items.}}
\DoxyCodeLine{00114     std::vector<std::unique\_ptr<RenderItem>> mAllRitems;}
\DoxyCodeLine{00115 }
\DoxyCodeLine{00116     \textcolor{comment}{//Our application will maintain lists of render items based on how they need to be}}
\DoxyCodeLine{00117     \textcolor{comment}{//drawn; that is, render items that need different PSOs will be kept in different lists.}}
\DoxyCodeLine{00118 }
\DoxyCodeLine{00119     \textcolor{comment}{// Render items divided by PSO.}}
\DoxyCodeLine{00120     std::vector<RenderItem*> mOpaqueRitems;}
\DoxyCodeLine{00121 }
\DoxyCodeLine{00122     \textcolor{comment}{//std::vector<RenderItem*> mTransparentRitems;  //we could have render items for transparant items}}
\DoxyCodeLine{00123 }
\DoxyCodeLine{00124 }
\DoxyCodeLine{00125 }
\DoxyCodeLine{00126     \textcolor{comment}{//this mMainPassCB stores constant data that is fixed over a given}}
\DoxyCodeLine{00127     \textcolor{comment}{//rendering pass such as the eye position, the view and projection matrices, and information}}
\DoxyCodeLine{00128     \textcolor{comment}{//about the screen(render target) dimensions; it also includes game timing information,}}
\DoxyCodeLine{00129     \textcolor{comment}{//which is useful data to have access to in shader programs.}}
\DoxyCodeLine{00130 }
\DoxyCodeLine{00131     PassConstants mMainPassCB;}
\DoxyCodeLine{00132 }
\DoxyCodeLine{00133     UINT mPassCbvOffset = 0;}
\DoxyCodeLine{00134 }
\DoxyCodeLine{00135     \textcolor{keywordtype}{bool} mIsWireframe = \textcolor{keyword}{false};}
\DoxyCodeLine{00136 }
\DoxyCodeLine{00137     XMFLOAT3 mEyePos = \{ 0.0f, 0.0f, 0.0f \};}
\DoxyCodeLine{00138     XMFLOAT4X4 mView = MathHelper::Identity4x4();}
\DoxyCodeLine{00139     XMFLOAT4X4 mProj = MathHelper::Identity4x4();}
\DoxyCodeLine{00140 }
\DoxyCodeLine{00141     \textcolor{keywordtype}{float} mTheta = 1.5f * XM\_PI;}
\DoxyCodeLine{00142     \textcolor{keywordtype}{float} mPhi = 0.2f * XM\_PI;}
\DoxyCodeLine{00143     \textcolor{keywordtype}{float} mRadius = 15.0f;}
\DoxyCodeLine{00144 }
\DoxyCodeLine{00145     POINT mLastMousePos;}
\DoxyCodeLine{00146 \};}
\DoxyCodeLine{00147 }
\DoxyCodeLine{00148 \textcolor{keywordtype}{int} WINAPI WinMain(HINSTANCE hInstance, HINSTANCE prevInstance,}
\DoxyCodeLine{00149     PSTR cmdLine, \textcolor{keywordtype}{int} showCmd)}
\DoxyCodeLine{00150 \{}
\DoxyCodeLine{00151     \textcolor{comment}{// Enable run-\/time memory check for debug builds.}}
\DoxyCodeLine{00152 \textcolor{preprocessor}{\#if defined(DEBUG) | defined(\_DEBUG)}}
\DoxyCodeLine{00153     \_CrtSetDbgFlag(\_CRTDBG\_ALLOC\_MEM\_DF | \_CRTDBG\_LEAK\_CHECK\_DF);}
\DoxyCodeLine{00154 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00155 }
\DoxyCodeLine{00156     \textcolor{keywordflow}{try}}
\DoxyCodeLine{00157     \{}
\DoxyCodeLine{00158         ShapesApp theApp(hInstance);}
\DoxyCodeLine{00159         \textcolor{keywordflow}{if} (!theApp.Initialize())}
\DoxyCodeLine{00160             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00161 }
\DoxyCodeLine{00162         \textcolor{keywordflow}{return} theApp.Run();}
\DoxyCodeLine{00163     \}}
\DoxyCodeLine{00164     \textcolor{keywordflow}{catch} (DxException\& e)}
\DoxyCodeLine{00165     \{}
\DoxyCodeLine{00166         MessageBox(\textcolor{keyword}{nullptr}, e.ToString().c\_str(), L\textcolor{stringliteral}{"{}HR Failed"{}}, MB\_OK);}
\DoxyCodeLine{00167         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{00168     \}}
\DoxyCodeLine{00169 \}}
\DoxyCodeLine{00170 }
\DoxyCodeLine{00171 ShapesApp::ShapesApp(HINSTANCE hInstance)}
\DoxyCodeLine{00172     : D3DApp(hInstance)}
\DoxyCodeLine{00173 \{}
\DoxyCodeLine{00174 \}}
\DoxyCodeLine{00175 }
\DoxyCodeLine{00176 ShapesApp::\string~ShapesApp()}
\DoxyCodeLine{00177 \{}
\DoxyCodeLine{00178     \textcolor{keywordflow}{if} (md3dDevice != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00179         FlushCommandQueue();}
\DoxyCodeLine{00180 \}}
\DoxyCodeLine{00181 }
\DoxyCodeLine{00182 \textcolor{keywordtype}{bool} ShapesApp::Initialize()}
\DoxyCodeLine{00183 \{}
\DoxyCodeLine{00184     \textcolor{keywordflow}{if} (!D3DApp::Initialize())}
\DoxyCodeLine{00185         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{00186 }
\DoxyCodeLine{00187     \textcolor{comment}{// Reset the command list to prep for initialization commands.}}
\DoxyCodeLine{00188     ThrowIfFailed(mCommandList-\/>Reset(mDirectCmdListAlloc.Get(), \textcolor{keyword}{nullptr}));}
\DoxyCodeLine{00189 }
\DoxyCodeLine{00190     BuildRootSignature();}
\DoxyCodeLine{00191     BuildShadersAndInputLayout();}
\DoxyCodeLine{00192     BuildShapeGeometry();}
\DoxyCodeLine{00193     BuildRenderItems();}
\DoxyCodeLine{00194     BuildFrameResources();}
\DoxyCodeLine{00195     BuildDescriptorHeaps();}
\DoxyCodeLine{00196     BuildConstantBufferViews();}
\DoxyCodeLine{00197     BuildPSOs();}
\DoxyCodeLine{00198 }
\DoxyCodeLine{00199     \textcolor{comment}{// Execute the initialization commands.}}
\DoxyCodeLine{00200     ThrowIfFailed(mCommandList-\/>Close());}
\DoxyCodeLine{00201     ID3D12CommandList* cmdsLists[] = \{ mCommandList.Get() \};}
\DoxyCodeLine{00202     mCommandQueue-\/>ExecuteCommandLists(\_countof(cmdsLists), cmdsLists);}
\DoxyCodeLine{00203 }
\DoxyCodeLine{00204     \textcolor{comment}{// Wait until initialization is complete.}}
\DoxyCodeLine{00205     FlushCommandQueue();}
\DoxyCodeLine{00206 }
\DoxyCodeLine{00207     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00208 \}}
\DoxyCodeLine{00209 }
\DoxyCodeLine{00210 \textcolor{keywordtype}{void} ShapesApp::OnResize()}
\DoxyCodeLine{00211 \{}
\DoxyCodeLine{00212     D3DApp::OnResize();}
\DoxyCodeLine{00213 }
\DoxyCodeLine{00214     \textcolor{comment}{// The window resized, so update the aspect ratio and recompute the projection matrix.}}
\DoxyCodeLine{00215     XMMATRIX P = XMMatrixPerspectiveFovLH(0.25f * MathHelper::Pi, AspectRatio(), 1.0f, 1000.0f);}
\DoxyCodeLine{00216     XMStoreFloat4x4(\&mProj, P);}
\DoxyCodeLine{00217 \}}
\DoxyCodeLine{00218 }
\DoxyCodeLine{00219 \textcolor{comment}{//for CPU frame n, the algorithm}}
\DoxyCodeLine{00220 \textcolor{comment}{//1. Cycle through the circular frame resource array.}}
\DoxyCodeLine{00221 \textcolor{comment}{//2. Wait until the GPU has completed commands up to this fence point.}}
\DoxyCodeLine{00222 \textcolor{comment}{//3. Update resources in mCurrFrameResource (like cbuffers).}}
\DoxyCodeLine{00223 }
\DoxyCodeLine{00224 \textcolor{keywordtype}{void} ShapesApp::Update(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00225 \{}
\DoxyCodeLine{00226     OnKeyboardInput(gt);}
\DoxyCodeLine{00227     UpdateCamera(gt);}
\DoxyCodeLine{00228 }
\DoxyCodeLine{00229     \textcolor{comment}{// Cycle through the circular frame resource array.}}
\DoxyCodeLine{00230     mCurrFrameResourceIndex = (mCurrFrameResourceIndex + 1) \% gNumFrameResources;}
\DoxyCodeLine{00231     mCurrFrameResource = mFrameResources[mCurrFrameResourceIndex].get();}
\DoxyCodeLine{00232 }
\DoxyCodeLine{00233 }
\DoxyCodeLine{00234     \textcolor{comment}{//this section is really what D3DApp::FlushCommandQueue() used to do for us at the end of each draw() function!}}
\DoxyCodeLine{00235     \textcolor{keywordflow}{if} (mCurrFrameResource-\/>Fence != 0 \&\& mFence-\/>GetCompletedValue() < mCurrFrameResource-\/>Fence)}
\DoxyCodeLine{00236     \{}
\DoxyCodeLine{00237         HANDLE eventHandle = CreateEventEx(\textcolor{keyword}{nullptr}, \textcolor{keyword}{nullptr}, \textcolor{keyword}{false}, EVENT\_ALL\_ACCESS);}
\DoxyCodeLine{00238         ThrowIfFailed(mFence-\/>SetEventOnCompletion(mCurrFrameResource-\/>Fence, eventHandle));}
\DoxyCodeLine{00239         WaitForSingleObject(eventHandle, INFINITE);}
\DoxyCodeLine{00240         CloseHandle(eventHandle);}
\DoxyCodeLine{00241     \}}
\DoxyCodeLine{00242 }
\DoxyCodeLine{00243     \textcolor{comment}{//The idea of these changes is to group constants based on update frequency. The per}}
\DoxyCodeLine{00244     \textcolor{comment}{//pass constants only need to be updated once per rendering pass, and the object constants}}
\DoxyCodeLine{00245     \textcolor{comment}{//only need to change when an object’s world matrix changes.}}
\DoxyCodeLine{00246     UpdateObjectCBs(gt);}
\DoxyCodeLine{00247     UpdateMainPassCB(gt);}
\DoxyCodeLine{00248 \}}
\DoxyCodeLine{00249 }
\DoxyCodeLine{00250 \textcolor{keywordtype}{void} ShapesApp::Draw(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00251 \{}
\DoxyCodeLine{00252     \textcolor{keyword}{auto} cmdListAlloc = mCurrFrameResource-\/>CmdListAlloc;}
\DoxyCodeLine{00253 }
\DoxyCodeLine{00254     \textcolor{comment}{// Reuse the memory associated with command recording.}}
\DoxyCodeLine{00255     \textcolor{comment}{// We can only reset when the associated command lists have finished execution on the GPU.}}
\DoxyCodeLine{00256     ThrowIfFailed(cmdListAlloc-\/>Reset());}
\DoxyCodeLine{00257 }
\DoxyCodeLine{00258     \textcolor{comment}{// A command list can be reset after it has been added to the command queue via ExecuteCommandList.}}
\DoxyCodeLine{00259     \textcolor{comment}{// Reusing the command list reuses memory.}}
\DoxyCodeLine{00260     \textcolor{keywordflow}{if} (mIsWireframe)}
\DoxyCodeLine{00261     \{}
\DoxyCodeLine{00262         ThrowIfFailed(mCommandList-\/>Reset(cmdListAlloc.Get(), mPSOs[\textcolor{stringliteral}{"{}opaque\_wireframe"{}}].Get()));}
\DoxyCodeLine{00263     \}}
\DoxyCodeLine{00264     \textcolor{keywordflow}{else}}
\DoxyCodeLine{00265     \{}
\DoxyCodeLine{00266         ThrowIfFailed(mCommandList-\/>Reset(cmdListAlloc.Get(), mPSOs[\textcolor{stringliteral}{"{}opaque"{}}].Get()));}
\DoxyCodeLine{00267     \}}
\DoxyCodeLine{00268 }
\DoxyCodeLine{00269     mCommandList-\/>RSSetViewports(1, \&mScreenViewport);}
\DoxyCodeLine{00270     mCommandList-\/>RSSetScissorRects(1, \&mScissorRect);}
\DoxyCodeLine{00271 }
\DoxyCodeLine{00272     \textcolor{comment}{// Indicate a state transition on the resource usage.}}
\DoxyCodeLine{00273     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(CurrentBackBuffer(),}
\DoxyCodeLine{00274         D3D12\_RESOURCE\_STATE\_PRESENT, D3D12\_RESOURCE\_STATE\_RENDER\_TARGET));}
\DoxyCodeLine{00275 }
\DoxyCodeLine{00276     \textcolor{comment}{// Clear the back buffer and depth buffer.}}
\DoxyCodeLine{00277     mCommandList-\/>ClearRenderTargetView(CurrentBackBufferView(), Colors::LightSteelBlue, 0, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00278     mCommandList-\/>ClearDepthStencilView(DepthStencilView(), D3D12\_CLEAR\_FLAG\_DEPTH | D3D12\_CLEAR\_FLAG\_STENCIL, 1.0f, 0, 0, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00279 }
\DoxyCodeLine{00280     \textcolor{comment}{// Specify the buffers we are going to render to.}}
\DoxyCodeLine{00281     mCommandList-\/>OMSetRenderTargets(1, \&CurrentBackBufferView(), \textcolor{keyword}{true}, \&DepthStencilView());}
\DoxyCodeLine{00282 }
\DoxyCodeLine{00283     ID3D12DescriptorHeap* descriptorHeaps[] = \{ mCbvHeap.Get() \};}
\DoxyCodeLine{00284     mCommandList-\/>SetDescriptorHeaps(\_countof(descriptorHeaps), descriptorHeaps);}
\DoxyCodeLine{00285 }
\DoxyCodeLine{00286     mCommandList-\/>SetGraphicsRootSignature(mRootSignature.Get());}
\DoxyCodeLine{00287 }
\DoxyCodeLine{00288     \textcolor{keywordtype}{int} passCbvIndex = mPassCbvOffset + mCurrFrameResourceIndex;}
\DoxyCodeLine{00289     \textcolor{keyword}{auto} passCbvHandle = CD3DX12\_GPU\_DESCRIPTOR\_HANDLE(mCbvHeap-\/>GetGPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00290     passCbvHandle.Offset(passCbvIndex, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{00291     mCommandList-\/>SetGraphicsRootDescriptorTable(1, passCbvHandle);}
\DoxyCodeLine{00292 }
\DoxyCodeLine{00293     DrawRenderItems(mCommandList.Get(), mOpaqueRitems);}
\DoxyCodeLine{00294 }
\DoxyCodeLine{00295     \textcolor{comment}{// Indicate a state transition on the resource usage.}}
\DoxyCodeLine{00296     mCommandList-\/>ResourceBarrier(1, \&CD3DX12\_RESOURCE\_BARRIER::Transition(CurrentBackBuffer(),}
\DoxyCodeLine{00297         D3D12\_RESOURCE\_STATE\_RENDER\_TARGET, D3D12\_RESOURCE\_STATE\_PRESENT));}
\DoxyCodeLine{00298 }
\DoxyCodeLine{00299     \textcolor{comment}{// Done recording commands.}}
\DoxyCodeLine{00300     ThrowIfFailed(mCommandList-\/>Close());}
\DoxyCodeLine{00301 }
\DoxyCodeLine{00302     \textcolor{comment}{// Add the command list to the queue for execution.}}
\DoxyCodeLine{00303     ID3D12CommandList* cmdsLists[] = \{ mCommandList.Get() \};}
\DoxyCodeLine{00304     mCommandQueue-\/>ExecuteCommandLists(\_countof(cmdsLists), cmdsLists);}
\DoxyCodeLine{00305 }
\DoxyCodeLine{00306     \textcolor{comment}{// Swap the back and front buffers}}
\DoxyCodeLine{00307     ThrowIfFailed(mSwapChain-\/>Present(0, 0));}
\DoxyCodeLine{00308     mCurrBackBuffer = (mCurrBackBuffer + 1) \% SwapChainBufferCount;}
\DoxyCodeLine{00309 }
\DoxyCodeLine{00310 }
\DoxyCodeLine{00311     \textcolor{comment}{//we have been calling D3DApp::FlushCommandQueue at the end of every}}
\DoxyCodeLine{00312     \textcolor{comment}{//frame to ensure the GPU has finished executing all the commands for the frame.This solution works but is inefficient}}
\DoxyCodeLine{00313     \textcolor{comment}{//For every frame, the CPU and GPU are idling at some point.}}
\DoxyCodeLine{00314     \textcolor{comment}{//  FlushCommandQueue();}}
\DoxyCodeLine{00315 }
\DoxyCodeLine{00316     \textcolor{comment}{//step9:  Advance the fence value to mark commands up to this fence point.}}
\DoxyCodeLine{00317     mCurrFrameResource-\/>Fence = ++mCurrentFence;}
\DoxyCodeLine{00318 }
\DoxyCodeLine{00319     \textcolor{comment}{// Add an instruction to the command queue to set a new fence point. }}
\DoxyCodeLine{00320     \textcolor{comment}{// Because we are on the GPU timeline, the new fence point won't be }}
\DoxyCodeLine{00321     \textcolor{comment}{// set until the GPU finishes processing all the commands prior to this Signal().}}
\DoxyCodeLine{00322     mCommandQueue-\/>Signal(mFence.Get(), mCurrentFence);}
\DoxyCodeLine{00323 }
\DoxyCodeLine{00324     \textcolor{comment}{// Note that GPU could still be working on commands from previous}}
\DoxyCodeLine{00325     \textcolor{comment}{// frames, but that is okay, because we are not touching any frame}}
\DoxyCodeLine{00326     \textcolor{comment}{// resources associated with those frames.}}
\DoxyCodeLine{00327 }
\DoxyCodeLine{00328 \}}
\DoxyCodeLine{00329 }
\DoxyCodeLine{00330 \textcolor{keywordtype}{void} ShapesApp::OnMouseDown(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)}
\DoxyCodeLine{00331 \{}
\DoxyCodeLine{00332     mLastMousePos.x = x;}
\DoxyCodeLine{00333     mLastMousePos.y = y;}
\DoxyCodeLine{00334 }
\DoxyCodeLine{00335     SetCapture(mhMainWnd);}
\DoxyCodeLine{00336 \}}
\DoxyCodeLine{00337 }
\DoxyCodeLine{00338 \textcolor{keywordtype}{void} ShapesApp::OnMouseUp(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)}
\DoxyCodeLine{00339 \{}
\DoxyCodeLine{00340     ReleaseCapture();}
\DoxyCodeLine{00341 \}}
\DoxyCodeLine{00342 }
\DoxyCodeLine{00343 \textcolor{keywordtype}{void} ShapesApp::OnMouseMove(WPARAM btnState, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y)}
\DoxyCodeLine{00344 \{}
\DoxyCodeLine{00345     \textcolor{keywordflow}{if} ((btnState \& MK\_LBUTTON) != 0)}
\DoxyCodeLine{00346     \{}
\DoxyCodeLine{00347         \textcolor{comment}{// Make each pixel correspond to a quarter of a degree.}}
\DoxyCodeLine{00348         \textcolor{keywordtype}{float} dx = XMConvertToRadians(0.25f * \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x -\/ mLastMousePos.x));}
\DoxyCodeLine{00349         \textcolor{keywordtype}{float} dy = XMConvertToRadians(0.25f * \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(y -\/ mLastMousePos.y));}
\DoxyCodeLine{00350 }
\DoxyCodeLine{00351         \textcolor{comment}{// Update angles based on input to orbit camera around box.}}
\DoxyCodeLine{00352         mTheta += dx;}
\DoxyCodeLine{00353         mPhi += dy;}
\DoxyCodeLine{00354 }
\DoxyCodeLine{00355         \textcolor{comment}{// Restrict the angle mPhi.}}
\DoxyCodeLine{00356         mPhi = MathHelper::Clamp(mPhi, 0.1f, MathHelper::Pi -\/ 0.1f);}
\DoxyCodeLine{00357     \}}
\DoxyCodeLine{00358     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((btnState \& MK\_RBUTTON) != 0)}
\DoxyCodeLine{00359     \{}
\DoxyCodeLine{00360         \textcolor{comment}{// Make each pixel correspond to 0.2 unit in the scene.}}
\DoxyCodeLine{00361         \textcolor{keywordtype}{float} dx = 0.05f * \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x -\/ mLastMousePos.x);}
\DoxyCodeLine{00362         \textcolor{keywordtype}{float} dy = 0.05f * \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(y -\/ mLastMousePos.y);}
\DoxyCodeLine{00363 }
\DoxyCodeLine{00364         \textcolor{comment}{// Update the camera radius based on input.}}
\DoxyCodeLine{00365         mRadius += dx -\/ dy;}
\DoxyCodeLine{00366 }
\DoxyCodeLine{00367         \textcolor{comment}{// Restrict the radius.}}
\DoxyCodeLine{00368         mRadius = MathHelper::Clamp(mRadius, 5.0f, 150.0f);}
\DoxyCodeLine{00369     \}}
\DoxyCodeLine{00370 }
\DoxyCodeLine{00371     mLastMousePos.x = x;}
\DoxyCodeLine{00372     mLastMousePos.y = y;}
\DoxyCodeLine{00373 \}}
\DoxyCodeLine{00374 }
\DoxyCodeLine{00375 \textcolor{keywordtype}{void} ShapesApp::OnKeyboardInput(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00376 \{}
\DoxyCodeLine{00377     \textcolor{comment}{//Determines whether a key is up or down at the time the function is called, and whether the key was pressed after a previous call to GetAsyncKeyState.}}
\DoxyCodeLine{00378     \textcolor{comment}{//If the function succeeds, the return value specifies whether the key was pressed since the last call to GetAsyncKeyState, }}
\DoxyCodeLine{00379     \textcolor{comment}{//and whether the key is currently up or down. If the most significant bit is set, the key is down, and if the least significant bit is set, the key was pressed after the previous call to GetAsyncKeyState.}}
\DoxyCodeLine{00380     \textcolor{comment}{//if (GetAsyncKeyState('1') \& 0x8000)}}
\DoxyCodeLine{00381 }
\DoxyCodeLine{00382     \textcolor{keywordtype}{short} key = GetAsyncKeyState(\textcolor{charliteral}{'1'});}
\DoxyCodeLine{00383     \textcolor{keywordflow}{if} (key \& 0x8000)  \textcolor{comment}{//if one is pressed, 0x8000 = 32767 , key = -\/32767 = FFFFFFFFFFFF8001}}
\DoxyCodeLine{00384         mIsWireframe = \textcolor{keyword}{true};}
\DoxyCodeLine{00385     \textcolor{keywordflow}{else}}
\DoxyCodeLine{00386         mIsWireframe = \textcolor{keyword}{false};}
\DoxyCodeLine{00387 \}}
\DoxyCodeLine{00388 }
\DoxyCodeLine{00389 \textcolor{keywordtype}{void} ShapesApp::UpdateCamera(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00390 \{}
\DoxyCodeLine{00391     \textcolor{comment}{// Convert Spherical to Cartesian coordinates.}}
\DoxyCodeLine{00392     mEyePos.x = mRadius * sinf(mPhi) * cosf(mTheta);}
\DoxyCodeLine{00393     mEyePos.z = mRadius * sinf(mPhi) * sinf(mTheta);}
\DoxyCodeLine{00394     mEyePos.y = mRadius * cosf(mPhi);}
\DoxyCodeLine{00395 }
\DoxyCodeLine{00396     \textcolor{comment}{// Build the view matrix.}}
\DoxyCodeLine{00397     XMVECTOR pos = XMVectorSet(mEyePos.x, mEyePos.y, mEyePos.z, 1.0f);}
\DoxyCodeLine{00398     XMVECTOR target = XMVectorZero();}
\DoxyCodeLine{00399     XMVECTOR up = XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f);}
\DoxyCodeLine{00400 }
\DoxyCodeLine{00401     XMMATRIX view = XMMatrixLookAtLH(pos, target, up);}
\DoxyCodeLine{00402     XMStoreFloat4x4(\&mView, view);}
\DoxyCodeLine{00403 \}}
\DoxyCodeLine{00404 }
\DoxyCodeLine{00405 \textcolor{comment}{//Update resources (cbuffers) in mCurrFrameResource}}
\DoxyCodeLine{00406 \textcolor{keywordtype}{void} ShapesApp::UpdateObjectCBs(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00407 \{}
\DoxyCodeLine{00408     \textcolor{keyword}{auto} currObjectCB = mCurrFrameResource-\/>ObjectCB.get();}
\DoxyCodeLine{00409     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& e : mAllRitems)}
\DoxyCodeLine{00410     \{}
\DoxyCodeLine{00411         \textcolor{comment}{// Only update the cbuffer data if the constants have changed.  }}
\DoxyCodeLine{00412         \textcolor{comment}{// This needs to be tracked per frame resource.}}
\DoxyCodeLine{00413         \textcolor{keywordflow}{if} (e-\/>NumFramesDirty > 0)}
\DoxyCodeLine{00414         \{}
\DoxyCodeLine{00415             XMMATRIX world = XMLoadFloat4x4(\&e-\/>World);}
\DoxyCodeLine{00416 }
\DoxyCodeLine{00417             ObjectConstants objConstants;}
\DoxyCodeLine{00418             XMStoreFloat4x4(\&objConstants.World, XMMatrixTranspose(world));}
\DoxyCodeLine{00419 }
\DoxyCodeLine{00420             currObjectCB-\/>CopyData(e-\/>ObjCBIndex, objConstants);}
\DoxyCodeLine{00421 }
\DoxyCodeLine{00422             \textcolor{comment}{// Next FrameResource need to be updated too.}}
\DoxyCodeLine{00423             e-\/>NumFramesDirty-\/-\/;}
\DoxyCodeLine{00424         \}}
\DoxyCodeLine{00425     \}}
\DoxyCodeLine{00426 \}}
\DoxyCodeLine{00427 }
\DoxyCodeLine{00428 \textcolor{comment}{//CBVs will be set at different frequencies—the per pass CBV only needs to be set once per}}
\DoxyCodeLine{00429 \textcolor{comment}{//rendering pass while the per object CBV needs to be set per render item}}
\DoxyCodeLine{00430 \textcolor{keywordtype}{void} ShapesApp::UpdateMainPassCB(\textcolor{keyword}{const} GameTimer\& gt)}
\DoxyCodeLine{00431 \{}
\DoxyCodeLine{00432     XMMATRIX view = XMLoadFloat4x4(\&mView);}
\DoxyCodeLine{00433     XMMATRIX proj = XMLoadFloat4x4(\&mProj);}
\DoxyCodeLine{00434 }
\DoxyCodeLine{00435     XMMATRIX viewProj = XMMatrixMultiply(view, proj);}
\DoxyCodeLine{00436     XMMATRIX invView = XMMatrixInverse(\&XMMatrixDeterminant(view), view);}
\DoxyCodeLine{00437     XMMATRIX invProj = XMMatrixInverse(\&XMMatrixDeterminant(proj), proj);}
\DoxyCodeLine{00438     XMMATRIX invViewProj = XMMatrixInverse(\&XMMatrixDeterminant(viewProj), viewProj);}
\DoxyCodeLine{00439 }
\DoxyCodeLine{00440     XMStoreFloat4x4(\&mMainPassCB.View, XMMatrixTranspose(view));}
\DoxyCodeLine{00441     XMStoreFloat4x4(\&mMainPassCB.InvView, XMMatrixTranspose(invView));}
\DoxyCodeLine{00442     XMStoreFloat4x4(\&mMainPassCB.Proj, XMMatrixTranspose(proj));}
\DoxyCodeLine{00443     XMStoreFloat4x4(\&mMainPassCB.InvProj, XMMatrixTranspose(invProj));}
\DoxyCodeLine{00444     XMStoreFloat4x4(\&mMainPassCB.ViewProj, XMMatrixTranspose(viewProj));}
\DoxyCodeLine{00445     XMStoreFloat4x4(\&mMainPassCB.InvViewProj, XMMatrixTranspose(invViewProj));}
\DoxyCodeLine{00446     mMainPassCB.EyePosW = mEyePos;}
\DoxyCodeLine{00447     mMainPassCB.RenderTargetSize = XMFLOAT2((\textcolor{keywordtype}{float})mClientWidth, (\textcolor{keywordtype}{float})mClientHeight);}
\DoxyCodeLine{00448     mMainPassCB.InvRenderTargetSize = XMFLOAT2(1.0f / mClientWidth, 1.0f / mClientHeight);}
\DoxyCodeLine{00449     mMainPassCB.NearZ = 1.0f;}
\DoxyCodeLine{00450     mMainPassCB.FarZ = 1000.0f;}
\DoxyCodeLine{00451     mMainPassCB.TotalTime = gt.TotalTime();}
\DoxyCodeLine{00452     mMainPassCB.DeltaTime = gt.DeltaTime();}
\DoxyCodeLine{00453 }
\DoxyCodeLine{00454     \textcolor{keyword}{auto} currPassCB = mCurrFrameResource-\/>PassCB.get();}
\DoxyCodeLine{00455     currPassCB-\/>CopyData(0, mMainPassCB);}
\DoxyCodeLine{00456 \}}
\DoxyCodeLine{00457 }
\DoxyCodeLine{00458 \textcolor{keywordtype}{void} ShapesApp::BuildDescriptorHeaps()}
\DoxyCodeLine{00459 \{}
\DoxyCodeLine{00460     UINT objCount = (UINT)mOpaqueRitems.size();}
\DoxyCodeLine{00461 }
\DoxyCodeLine{00462     \textcolor{comment}{// Need a CBV descriptor for each object for each frame resource,}}
\DoxyCodeLine{00463     \textcolor{comment}{// +1 for the perPass CBV for each frame resource.}}
\DoxyCodeLine{00464     UINT numDescriptors = (objCount + 1) * gNumFrameResources;}
\DoxyCodeLine{00465 }
\DoxyCodeLine{00466     \textcolor{comment}{// Save an offset to the start of the pass CBVs.  These are the last 3 descriptors.}}
\DoxyCodeLine{00467     mPassCbvOffset = objCount * gNumFrameResources;}
\DoxyCodeLine{00468 }
\DoxyCodeLine{00469     D3D12\_DESCRIPTOR\_HEAP\_DESC cbvHeapDesc;}
\DoxyCodeLine{00470     cbvHeapDesc.NumDescriptors = numDescriptors;}
\DoxyCodeLine{00471     cbvHeapDesc.Type = D3D12\_DESCRIPTOR\_HEAP\_TYPE\_CBV\_SRV\_UAV;}
\DoxyCodeLine{00472     cbvHeapDesc.Flags = D3D12\_DESCRIPTOR\_HEAP\_FLAG\_SHADER\_VISIBLE;}
\DoxyCodeLine{00473     cbvHeapDesc.NodeMask = 0;}
\DoxyCodeLine{00474     ThrowIfFailed(md3dDevice-\/>CreateDescriptorHeap(\&cbvHeapDesc,}
\DoxyCodeLine{00475         IID\_PPV\_ARGS(\&mCbvHeap)));}
\DoxyCodeLine{00476 \}}
\DoxyCodeLine{00477 }
\DoxyCodeLine{00478 \textcolor{keywordtype}{void} ShapesApp::BuildConstantBufferViews()}
\DoxyCodeLine{00479 \{}
\DoxyCodeLine{00480     UINT objCBByteSize = d3dUtil::CalcConstantBufferByteSize(\textcolor{keyword}{sizeof}(ObjectConstants));}
\DoxyCodeLine{00481 }
\DoxyCodeLine{00482     UINT objCount = (UINT)mOpaqueRitems.size();}
\DoxyCodeLine{00483 }
\DoxyCodeLine{00484     \textcolor{comment}{// Need a CBV descriptor for each object for each frame resource.}}
\DoxyCodeLine{00485     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} frameIndex = 0; frameIndex < gNumFrameResources; ++frameIndex)}
\DoxyCodeLine{00486     \{}
\DoxyCodeLine{00487         \textcolor{keyword}{auto} objectCB = mFrameResources[frameIndex]-\/>ObjectCB-\/>Resource();}
\DoxyCodeLine{00488         \textcolor{keywordflow}{for} (UINT i = 0; i < objCount; ++i)}
\DoxyCodeLine{00489         \{}
\DoxyCodeLine{00490             D3D12\_GPU\_VIRTUAL\_ADDRESS cbAddress = objectCB-\/>GetGPUVirtualAddress();}
\DoxyCodeLine{00491 }
\DoxyCodeLine{00492             \textcolor{comment}{// Offset to the ith object constant buffer in the buffer.}}
\DoxyCodeLine{00493             cbAddress += i * objCBByteSize;}
\DoxyCodeLine{00494 }
\DoxyCodeLine{00495             \textcolor{comment}{// Offset to the object cbv in the descriptor heap.}}
\DoxyCodeLine{00496             \textcolor{keywordtype}{int} heapIndex = frameIndex * objCount + i;}
\DoxyCodeLine{00497             \textcolor{keyword}{auto} handle = CD3DX12\_CPU\_DESCRIPTOR\_HANDLE(mCbvHeap-\/>GetCPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00498             handle.Offset(heapIndex, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{00499 }
\DoxyCodeLine{00500             D3D12\_CONSTANT\_BUFFER\_VIEW\_DESC cbvDesc;}
\DoxyCodeLine{00501             cbvDesc.BufferLocation = cbAddress;}
\DoxyCodeLine{00502             cbvDesc.SizeInBytes = objCBByteSize;}
\DoxyCodeLine{00503 }
\DoxyCodeLine{00504             md3dDevice-\/>CreateConstantBufferView(\&cbvDesc, handle);}
\DoxyCodeLine{00505         \}}
\DoxyCodeLine{00506     \}}
\DoxyCodeLine{00507 }
\DoxyCodeLine{00508     UINT passCBByteSize = d3dUtil::CalcConstantBufferByteSize(\textcolor{keyword}{sizeof}(PassConstants));}
\DoxyCodeLine{00509 }
\DoxyCodeLine{00510     \textcolor{comment}{// Last three descriptors are the pass CBVs for each frame resource.}}
\DoxyCodeLine{00511     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} frameIndex = 0; frameIndex < gNumFrameResources; ++frameIndex)}
\DoxyCodeLine{00512     \{}
\DoxyCodeLine{00513         \textcolor{keyword}{auto} passCB = mFrameResources[frameIndex]-\/>PassCB-\/>Resource();}
\DoxyCodeLine{00514         D3D12\_GPU\_VIRTUAL\_ADDRESS cbAddress = passCB-\/>GetGPUVirtualAddress();}
\DoxyCodeLine{00515 }
\DoxyCodeLine{00516         \textcolor{comment}{// Offset to the pass cbv in the descriptor heap.}}
\DoxyCodeLine{00517         \textcolor{keywordtype}{int} heapIndex = mPassCbvOffset + frameIndex;}
\DoxyCodeLine{00518         \textcolor{keyword}{auto} handle = CD3DX12\_CPU\_DESCRIPTOR\_HANDLE(mCbvHeap-\/>GetCPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00519         handle.Offset(heapIndex, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{00520 }
\DoxyCodeLine{00521         D3D12\_CONSTANT\_BUFFER\_VIEW\_DESC cbvDesc;}
\DoxyCodeLine{00522         cbvDesc.BufferLocation = cbAddress;}
\DoxyCodeLine{00523         cbvDesc.SizeInBytes = passCBByteSize;}
\DoxyCodeLine{00524 }
\DoxyCodeLine{00525         md3dDevice-\/>CreateConstantBufferView(\&cbvDesc, handle);}
\DoxyCodeLine{00526     \}}
\DoxyCodeLine{00527 \}}
\DoxyCodeLine{00528 }
\DoxyCodeLine{00529 \textcolor{keywordtype}{void} ShapesApp::BuildRootSignature()}
\DoxyCodeLine{00530 \{}
\DoxyCodeLine{00531     \textcolor{comment}{//The resources that our shaders expect have changed; therefore, we need to update the}}
\DoxyCodeLine{00532     \textcolor{comment}{//root signature accordingly to take two descriptor tables(we need two tables because the}}
\DoxyCodeLine{00533     \textcolor{comment}{//CBVs will be set at different frequencies—the per pass CBV only needs to be set once per}}
\DoxyCodeLine{00534     \textcolor{comment}{//rendering pass while the per object CBV needs to be set per render item) :}}
\DoxyCodeLine{00535 }
\DoxyCodeLine{00536     CD3DX12\_DESCRIPTOR\_RANGE cbvTable0;}
\DoxyCodeLine{00537     cbvTable0.Init(D3D12\_DESCRIPTOR\_RANGE\_TYPE\_CBV, 1, 0);}
\DoxyCodeLine{00538 }
\DoxyCodeLine{00539     CD3DX12\_DESCRIPTOR\_RANGE cbvTable1;}
\DoxyCodeLine{00540     cbvTable1.Init(D3D12\_DESCRIPTOR\_RANGE\_TYPE\_CBV, 1, 1);}
\DoxyCodeLine{00541 }
\DoxyCodeLine{00542     \textcolor{comment}{// Root parameter can be a table, root descriptor or root constants.}}
\DoxyCodeLine{00543     CD3DX12\_ROOT\_PARAMETER slotRootParameter[2];}
\DoxyCodeLine{00544 }
\DoxyCodeLine{00545     \textcolor{comment}{// Create root CBVs.}}
\DoxyCodeLine{00546     slotRootParameter[0].InitAsDescriptorTable(1, \&cbvTable0);}
\DoxyCodeLine{00547     slotRootParameter[1].InitAsDescriptorTable(1, \&cbvTable1);}
\DoxyCodeLine{00548 }
\DoxyCodeLine{00549     \textcolor{comment}{// A root signature is an array of root parameters.}}
\DoxyCodeLine{00550     CD3DX12\_ROOT\_SIGNATURE\_DESC rootSigDesc(2, slotRootParameter, 0, \textcolor{keyword}{nullptr},}
\DoxyCodeLine{00551         D3D12\_ROOT\_SIGNATURE\_FLAG\_ALLOW\_INPUT\_ASSEMBLER\_INPUT\_LAYOUT);}
\DoxyCodeLine{00552 }
\DoxyCodeLine{00553     \textcolor{comment}{// create a root signature with a single slot which points to a descriptor range consisting of a single constant buffer}}
\DoxyCodeLine{00554     ComPtr<ID3DBlob> serializedRootSig = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00555     ComPtr<ID3DBlob> errorBlob = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00556     HRESULT hr = D3D12SerializeRootSignature(\&rootSigDesc, D3D\_ROOT\_SIGNATURE\_VERSION\_1,}
\DoxyCodeLine{00557         serializedRootSig.GetAddressOf(), errorBlob.GetAddressOf());}
\DoxyCodeLine{00558 }
\DoxyCodeLine{00559     \textcolor{keywordflow}{if} (errorBlob != \textcolor{keyword}{nullptr})}
\DoxyCodeLine{00560     \{}
\DoxyCodeLine{00561         ::OutputDebugStringA((\textcolor{keywordtype}{char}*)errorBlob-\/>GetBufferPointer());}
\DoxyCodeLine{00562     \}}
\DoxyCodeLine{00563     ThrowIfFailed(hr);}
\DoxyCodeLine{00564 }
\DoxyCodeLine{00565     ThrowIfFailed(md3dDevice-\/>CreateRootSignature(}
\DoxyCodeLine{00566         0,}
\DoxyCodeLine{00567         serializedRootSig-\/>GetBufferPointer(),}
\DoxyCodeLine{00568         serializedRootSig-\/>GetBufferSize(),}
\DoxyCodeLine{00569         IID\_PPV\_ARGS(mRootSignature.GetAddressOf())));}
\DoxyCodeLine{00570 \}}
\DoxyCodeLine{00571 }
\DoxyCodeLine{00572 \textcolor{keywordtype}{void} ShapesApp::BuildShadersAndInputLayout()}
\DoxyCodeLine{00573 \{}
\DoxyCodeLine{00574     mShaders[\textcolor{stringliteral}{"{}standardVS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)VS.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}VS"{}}, \textcolor{stringliteral}{"{}vs\_5\_1"{}});}
\DoxyCodeLine{00575     mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}] = d3dUtil::CompileShader(L\textcolor{stringliteral}{"{}Shaders\(\backslash\)\(\backslash\)PS.hlsl"{}}, \textcolor{keyword}{nullptr}, \textcolor{stringliteral}{"{}PS"{}}, \textcolor{stringliteral}{"{}ps\_5\_1"{}});}
\DoxyCodeLine{00576 }
\DoxyCodeLine{00577     mInputLayout =}
\DoxyCodeLine{00578     \{}
\DoxyCodeLine{00579         \{ \textcolor{stringliteral}{"{}POSITION"{}}, 0, DXGI\_FORMAT\_R32G32B32\_FLOAT, 0, 0, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{00580         \{ \textcolor{stringliteral}{"{}COLOR"{}}, 0, DXGI\_FORMAT\_R32G32B32A32\_FLOAT, 0, 12, D3D12\_INPUT\_CLASSIFICATION\_PER\_VERTEX\_DATA, 0 \},}
\DoxyCodeLine{00581     \};}
\DoxyCodeLine{00582 \}}
\DoxyCodeLine{00583 }
\DoxyCodeLine{00584 \textcolor{comment}{//step1}}
\DoxyCodeLine{00585 \textcolor{keywordtype}{void} ShapesApp::BuildShapeGeometry()}
\DoxyCodeLine{00586 \{}
\DoxyCodeLine{00587     \textcolor{comment}{//GeometryGenerator is a utility class for generating simple geometric shapes like grids, grid, grids, and boxes}}
\DoxyCodeLine{00588     GeometryGenerator geoGen;}
\DoxyCodeLine{00589     \textcolor{comment}{//The MeshData structure is a simple structure nested inside GeometryGenerator that stores a vertexand index list}}
\DoxyCodeLine{00590 }
\DoxyCodeLine{00591     \textcolor{comment}{//GeometryGenerator::CreateGrid(float width, float depth, uint32 m, uint32 n)}}
\DoxyCodeLine{00592     GeometryGenerator::MeshData grid = geoGen.CreateGrid(20.0f, 30.0f, 60, 40);}
\DoxyCodeLine{00593     \textcolor{comment}{// We are concatenating all the geometry into one big vertex/index buffer.  So}}
\DoxyCodeLine{00594     \textcolor{comment}{// define the regions in the buffer each submesh covers.}}
\DoxyCodeLine{00595 }
\DoxyCodeLine{00596     \textcolor{comment}{// Cache the vertex offsets to each object in the concatenated vertex buffer.}}
\DoxyCodeLine{00597     UINT gridVertexOffset = 0;}
\DoxyCodeLine{00598 }
\DoxyCodeLine{00599 }
\DoxyCodeLine{00600     \textcolor{comment}{// Cache the starting index for each object in the concatenated index buffer.}}
\DoxyCodeLine{00601     UINT gridIndexOffset = 0;}
\DoxyCodeLine{00602 }
\DoxyCodeLine{00603 }
\DoxyCodeLine{00604     \textcolor{comment}{// Define the SubmeshGeometry that cover different }}
\DoxyCodeLine{00605     \textcolor{comment}{// regions of the vertex/index buffers.}}
\DoxyCodeLine{00606     SubmeshGeometry gridSubmesh;}
\DoxyCodeLine{00607     gridSubmesh.IndexCount = (UINT)grid.Indices32.size();}
\DoxyCodeLine{00608     gridSubmesh.StartIndexLocation = gridIndexOffset;}
\DoxyCodeLine{00609     gridSubmesh.BaseVertexLocation = gridVertexOffset;}
\DoxyCodeLine{00610 }
\DoxyCodeLine{00611     \textcolor{comment}{// Extract the vertex elements we are interested in and pack the}}
\DoxyCodeLine{00612     \textcolor{comment}{// vertices of all the meshes into one vertex buffer.}}
\DoxyCodeLine{00613 }
\DoxyCodeLine{00614     \textcolor{keyword}{auto} totalVertexCount = grid.Vertices.size();}
\DoxyCodeLine{00615 }
\DoxyCodeLine{00616     std::vector<Vertex> vertices(totalVertexCount);}
\DoxyCodeLine{00617 }
\DoxyCodeLine{00618     UINT k = 0;}
\DoxyCodeLine{00619     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < grid.Vertices.size(); ++i, ++k)}
\DoxyCodeLine{00620     \{}
\DoxyCodeLine{00621         vertices[k].Pos = grid.Vertices[i].Position;}
\DoxyCodeLine{00622         vertices[k].Color = XMFLOAT4(DirectX::Colors::DarkOrange);}
\DoxyCodeLine{00623     \}}
\DoxyCodeLine{00624 }
\DoxyCodeLine{00625 }
\DoxyCodeLine{00626     std::vector<std::uint16\_t> indices;}
\DoxyCodeLine{00627     indices.insert(indices.end(), std::begin(grid.GetIndices16()), std::end(grid.GetIndices16()));}
\DoxyCodeLine{00628 }
\DoxyCodeLine{00629 }
\DoxyCodeLine{00630     \textcolor{keyword}{const} UINT vbByteSize = (UINT)vertices.size() * \textcolor{keyword}{sizeof}(Vertex);}
\DoxyCodeLine{00631     \textcolor{keyword}{const} UINT ibByteSize = (UINT)indices.size() * \textcolor{keyword}{sizeof}(std::uint16\_t);}
\DoxyCodeLine{00632 }
\DoxyCodeLine{00633     \textcolor{keyword}{auto} geo = std::make\_unique<MeshGeometry>();}
\DoxyCodeLine{00634     geo-\/>Name = \textcolor{stringliteral}{"{}shapeGeo"{}};}
\DoxyCodeLine{00635 }
\DoxyCodeLine{00636     ThrowIfFailed(D3DCreateBlob(vbByteSize, \&geo-\/>VertexBufferCPU));}
\DoxyCodeLine{00637     CopyMemory(geo-\/>VertexBufferCPU-\/>GetBufferPointer(), vertices.data(), vbByteSize);}
\DoxyCodeLine{00638 }
\DoxyCodeLine{00639     ThrowIfFailed(D3DCreateBlob(ibByteSize, \&geo-\/>IndexBufferCPU));}
\DoxyCodeLine{00640     CopyMemory(geo-\/>IndexBufferCPU-\/>GetBufferPointer(), indices.data(), ibByteSize);}
\DoxyCodeLine{00641 }
\DoxyCodeLine{00642     geo-\/>VertexBufferGPU = d3dUtil::CreateDefaultBuffer(md3dDevice.Get(),}
\DoxyCodeLine{00643         mCommandList.Get(), vertices.data(), vbByteSize, geo-\/>VertexBufferUploader);}
\DoxyCodeLine{00644 }
\DoxyCodeLine{00645     geo-\/>IndexBufferGPU = d3dUtil::CreateDefaultBuffer(md3dDevice.Get(),}
\DoxyCodeLine{00646         mCommandList.Get(), indices.data(), ibByteSize, geo-\/>IndexBufferUploader);}
\DoxyCodeLine{00647 }
\DoxyCodeLine{00648     geo-\/>VertexByteStride = \textcolor{keyword}{sizeof}(Vertex);}
\DoxyCodeLine{00649     geo-\/>VertexBufferByteSize = vbByteSize;}
\DoxyCodeLine{00650     geo-\/>IndexFormat = DXGI\_FORMAT\_R16\_UINT;}
\DoxyCodeLine{00651     geo-\/>IndexBufferByteSize = ibByteSize;}
\DoxyCodeLine{00652 }
\DoxyCodeLine{00653     geo-\/>DrawArgs[\textcolor{stringliteral}{"{}grid"{}}] = gridSubmesh;}
\DoxyCodeLine{00654 }
\DoxyCodeLine{00655 }
\DoxyCodeLine{00656     mGeometries[geo-\/>Name] = std::move(geo);}
\DoxyCodeLine{00657 \}}
\DoxyCodeLine{00658 }
\DoxyCodeLine{00659 \textcolor{keywordtype}{void} ShapesApp::BuildPSOs()}
\DoxyCodeLine{00660 \{}
\DoxyCodeLine{00661     D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC opaquePsoDesc;}
\DoxyCodeLine{00662 }
\DoxyCodeLine{00663     \textcolor{comment}{//}}
\DoxyCodeLine{00664     \textcolor{comment}{// PSO for opaque objects.}}
\DoxyCodeLine{00665     \textcolor{comment}{//}}
\DoxyCodeLine{00666     ZeroMemory(\&opaquePsoDesc, \textcolor{keyword}{sizeof}(D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC));}
\DoxyCodeLine{00667     opaquePsoDesc.InputLayout = \{ mInputLayout.data(), (UINT)mInputLayout.size() \};}
\DoxyCodeLine{00668     opaquePsoDesc.pRootSignature = mRootSignature.Get();}
\DoxyCodeLine{00669     opaquePsoDesc.VS =}
\DoxyCodeLine{00670     \{}
\DoxyCodeLine{00671         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}standardVS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{00672         mShaders[\textcolor{stringliteral}{"{}standardVS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{00673     \};}
\DoxyCodeLine{00674     opaquePsoDesc.PS =}
\DoxyCodeLine{00675     \{}
\DoxyCodeLine{00676         \textcolor{keyword}{reinterpret\_cast<}BYTE*\textcolor{keyword}{>}(mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}]-\/>GetBufferPointer()),}
\DoxyCodeLine{00677         mShaders[\textcolor{stringliteral}{"{}opaquePS"{}}]-\/>GetBufferSize()}
\DoxyCodeLine{00678     \};}
\DoxyCodeLine{00679     opaquePsoDesc.RasterizerState = CD3DX12\_RASTERIZER\_DESC(D3D12\_DEFAULT);}
\DoxyCodeLine{00680     opaquePsoDesc.RasterizerState.FillMode = D3D12\_FILL\_MODE\_SOLID;}
\DoxyCodeLine{00681     opaquePsoDesc.BlendState = CD3DX12\_BLEND\_DESC(D3D12\_DEFAULT);}
\DoxyCodeLine{00682     opaquePsoDesc.DepthStencilState = CD3DX12\_DEPTH\_STENCIL\_DESC(D3D12\_DEFAULT);}
\DoxyCodeLine{00683     opaquePsoDesc.SampleMask = UINT\_MAX;}
\DoxyCodeLine{00684     opaquePsoDesc.PrimitiveTopologyType = D3D12\_PRIMITIVE\_TOPOLOGY\_TYPE\_TRIANGLE;}
\DoxyCodeLine{00685     opaquePsoDesc.NumRenderTargets = 1;}
\DoxyCodeLine{00686     opaquePsoDesc.RTVFormats[0] = mBackBufferFormat;}
\DoxyCodeLine{00687     opaquePsoDesc.SampleDesc.Count = m4xMsaaState ? 4 : 1;}
\DoxyCodeLine{00688     opaquePsoDesc.SampleDesc.Quality = m4xMsaaState ? (m4xMsaaQuality -\/ 1) : 0;}
\DoxyCodeLine{00689     opaquePsoDesc.DSVFormat = mDepthStencilFormat;}
\DoxyCodeLine{00690     ThrowIfFailed(md3dDevice-\/>CreateGraphicsPipelineState(\&opaquePsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}opaque"{}}])));}
\DoxyCodeLine{00691 }
\DoxyCodeLine{00692     \textcolor{comment}{// PSO for opaque wireframe objects.}}
\DoxyCodeLine{00693 }
\DoxyCodeLine{00694     D3D12\_GRAPHICS\_PIPELINE\_STATE\_DESC opaqueWireframePsoDesc = opaquePsoDesc;}
\DoxyCodeLine{00695     opaqueWireframePsoDesc.RasterizerState.FillMode = D3D12\_FILL\_MODE\_WIREFRAME;}
\DoxyCodeLine{00696     ThrowIfFailed(md3dDevice-\/>CreateGraphicsPipelineState(\&opaqueWireframePsoDesc, IID\_PPV\_ARGS(\&mPSOs[\textcolor{stringliteral}{"{}opaque\_wireframe"{}}])));}
\DoxyCodeLine{00697 \}}
\DoxyCodeLine{00698 }
\DoxyCodeLine{00699 \textcolor{comment}{//build three frame resources}}
\DoxyCodeLine{00700 \textcolor{comment}{//FrameResource constructor:     FrameResource(ID3D12Device* device, UINT passCount, UINT objectCount);}}
\DoxyCodeLine{00701 }
\DoxyCodeLine{00702 \textcolor{keywordtype}{void} ShapesApp::BuildFrameResources()}
\DoxyCodeLine{00703 \{}
\DoxyCodeLine{00704     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < gNumFrameResources; ++i)}
\DoxyCodeLine{00705     \{}
\DoxyCodeLine{00706         mFrameResources.push\_back(std::make\_unique<FrameResource>(md3dDevice.Get(),}
\DoxyCodeLine{00707             1, (UINT)mAllRitems.size()));}
\DoxyCodeLine{00708     \}}
\DoxyCodeLine{00709 \}}
\DoxyCodeLine{00710 }
\DoxyCodeLine{00711 \textcolor{keywordtype}{void} ShapesApp::BuildRenderItems()}
\DoxyCodeLine{00712 \{}
\DoxyCodeLine{00713     \textcolor{keyword}{auto} gridRitem = std::make\_unique<RenderItem>();}
\DoxyCodeLine{00714     XMStoreFloat4x4(\&gridRitem-\/>World, XMMatrixScaling(2.0f, 2.0f, 2.0f) * XMMatrixTranslation(0.0f, 0.5f, 0.0f));}
\DoxyCodeLine{00715     gridRitem-\/>ObjCBIndex = 0;}
\DoxyCodeLine{00716     gridRitem-\/>Geo = mGeometries[\textcolor{stringliteral}{"{}shapeGeo"{}}].get();}
\DoxyCodeLine{00717     gridRitem-\/>PrimitiveType = D3D\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST;}
\DoxyCodeLine{00718     gridRitem-\/>IndexCount = gridRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}grid"{}}].IndexCount;  \textcolor{comment}{//13806}}
\DoxyCodeLine{00719     gridRitem-\/>StartIndexLocation = gridRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}grid"{}}].StartIndexLocation; \textcolor{comment}{//0}}
\DoxyCodeLine{00720     gridRitem-\/>BaseVertexLocation = gridRitem-\/>Geo-\/>DrawArgs[\textcolor{stringliteral}{"{}grid"{}}].BaseVertexLocation; \textcolor{comment}{//0}}
\DoxyCodeLine{00721     mAllRitems.push\_back(std::move(gridRitem));}
\DoxyCodeLine{00722 }
\DoxyCodeLine{00723 }
\DoxyCodeLine{00724     \textcolor{comment}{// All the render items are opaque.}}
\DoxyCodeLine{00725     \textcolor{comment}{//Our application will maintain lists of render items based on how they need to be}}
\DoxyCodeLine{00726     \textcolor{comment}{//drawn; that is, render items that need different PSOs will be kept in different lists.}}
\DoxyCodeLine{00727     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& e : mAllRitems)}
\DoxyCodeLine{00728         mOpaqueRitems.push\_back(e.get());}
\DoxyCodeLine{00729 \}}
\DoxyCodeLine{00730 }
\DoxyCodeLine{00731 \textcolor{keywordtype}{void} ShapesApp::DrawRenderItems(ID3D12GraphicsCommandList* cmdList, \textcolor{keyword}{const} std::vector<RenderItem*>\& ritems)}
\DoxyCodeLine{00732 \{}
\DoxyCodeLine{00733     UINT objCBByteSize = d3dUtil::CalcConstantBufferByteSize(\textcolor{keyword}{sizeof}(ObjectConstants));}
\DoxyCodeLine{00734 }
\DoxyCodeLine{00735     \textcolor{keyword}{auto} objectCB = mCurrFrameResource-\/>ObjectCB-\/>Resource();}
\DoxyCodeLine{00736 }
\DoxyCodeLine{00737     \textcolor{comment}{// For each render item...}}
\DoxyCodeLine{00738     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < ritems.size(); ++i)}
\DoxyCodeLine{00739     \{}
\DoxyCodeLine{00740         \textcolor{keyword}{auto} ri = ritems[i];}
\DoxyCodeLine{00741 }
\DoxyCodeLine{00742         cmdList-\/>IASetVertexBuffers(0, 1, \&ri-\/>Geo-\/>VertexBufferView());}
\DoxyCodeLine{00743         cmdList-\/>IASetIndexBuffer(\&ri-\/>Geo-\/>IndexBufferView());}
\DoxyCodeLine{00744         cmdList-\/>IASetPrimitiveTopology(ri-\/>PrimitiveType);}
\DoxyCodeLine{00745 }
\DoxyCodeLine{00746         \textcolor{comment}{// Offset to the CBV in the descriptor heap for this object and for this frame resource.}}
\DoxyCodeLine{00747         UINT cbvIndex = mCurrFrameResourceIndex * (UINT)mOpaqueRitems.size() + ri-\/>ObjCBIndex;}
\DoxyCodeLine{00748         \textcolor{keyword}{auto} cbvHandle = CD3DX12\_GPU\_DESCRIPTOR\_HANDLE(mCbvHeap-\/>GetGPUDescriptorHandleForHeapStart());}
\DoxyCodeLine{00749         cbvHandle.Offset(cbvIndex, mCbvSrvUavDescriptorSize);}
\DoxyCodeLine{00750 }
\DoxyCodeLine{00751         cmdList-\/>SetGraphicsRootDescriptorTable(0, cbvHandle);}
\DoxyCodeLine{00752 }
\DoxyCodeLine{00753         cmdList-\/>DrawIndexedInstanced(ri-\/>IndexCount, 1, ri-\/>StartIndexLocation, ri-\/>BaseVertexLocation, 0);}
\DoxyCodeLine{00754     \}}
\DoxyCodeLine{00755 \}}
\DoxyCodeLine{00756 }
\DoxyCodeLine{00757 }

\end{DoxyCode}
